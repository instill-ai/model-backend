// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/model-backend/pkg/datamodel"
	modelpb "github.com/instill-ai/protogen-go/model/model/v1alpha"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"gorm.io/gorm"
)

// RepositoryMock implements repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPinnedUser          func(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB)
	inspectFuncCheckPinnedUser   func(ctx context.Context, db *gorm.DB, table string)
	afterCheckPinnedUserCounter  uint64
	beforeCheckPinnedUserCounter uint64
	CheckPinnedUserMock          mRepositoryMockCheckPinnedUser

	funcCreateModelRun          func(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error)
	inspectFuncCreateModelRun   func(ctx context.Context, modelRun *datamodel.ModelRun)
	afterCreateModelRunCounter  uint64
	beforeCreateModelRunCounter uint64
	CreateModelRunMock          mRepositoryMockCreateModelRun

	funcCreateModelTags          func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)
	inspectFuncCreateModelTags   func(ctx context.Context, modelUID uuid.UUID, tagNames []string)
	afterCreateModelTagsCounter  uint64
	beforeCreateModelTagsCounter uint64
	CreateModelTagsMock          mRepositoryMockCreateModelTags

	funcCreateModelVersion          func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error)
	inspectFuncCreateModelVersion   func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion)
	afterCreateModelVersionCounter  uint64
	beforeCreateModelVersionCounter uint64
	CreateModelVersionMock          mRepositoryMockCreateModelVersion

	funcCreateNamespaceModel          func(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error)
	inspectFuncCreateNamespaceModel   func(ctx context.Context, ownerPermalink string, model *datamodel.Model)
	afterCreateNamespaceModelCounter  uint64
	beforeCreateNamespaceModelCounter uint64
	CreateNamespaceModelMock          mRepositoryMockCreateNamespaceModel

	funcDeleteModelTags          func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)
	inspectFuncDeleteModelTags   func(ctx context.Context, modelUID uuid.UUID, tagNames []string)
	afterDeleteModelTagsCounter  uint64
	beforeDeleteModelTagsCounter uint64
	DeleteModelTagsMock          mRepositoryMockDeleteModelTags

	funcDeleteModelVersionByDigest          func(ctx context.Context, modelUID uuid.UUID, digest string) (err error)
	inspectFuncDeleteModelVersionByDigest   func(ctx context.Context, modelUID uuid.UUID, digest string)
	afterDeleteModelVersionByDigestCounter  uint64
	beforeDeleteModelVersionByDigestCounter uint64
	DeleteModelVersionByDigestMock          mRepositoryMockDeleteModelVersionByDigest

	funcDeleteModelVersionByID          func(ctx context.Context, modelUID uuid.UUID, versionID string) (err error)
	inspectFuncDeleteModelVersionByID   func(ctx context.Context, modelUID uuid.UUID, versionID string)
	afterDeleteModelVersionByIDCounter  uint64
	beforeDeleteModelVersionByIDCounter uint64
	DeleteModelVersionByIDMock          mRepositoryMockDeleteModelVersionByID

	funcDeleteNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	inspectFuncDeleteNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespaceModelByIDCounter  uint64
	beforeDeleteNamespaceModelByIDCounter uint64
	DeleteNamespaceModelByIDMock          mRepositoryMockDeleteNamespaceModelByID

	funcGetLatestModelRunByModelUID          func(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error)
	inspectFuncGetLatestModelRunByModelUID   func(ctx context.Context, userUID string, modelUID string)
	afterGetLatestModelRunByModelUIDCounter  uint64
	beforeGetLatestModelRunByModelUIDCounter uint64
	GetLatestModelRunByModelUIDMock          mRepositoryMockGetLatestModelRunByModelUID

	funcGetLatestModelVersionByModelUID          func(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error)
	inspectFuncGetLatestModelVersionByModelUID   func(ctx context.Context, modelUID uuid.UUID)
	afterGetLatestModelVersionByModelUIDCounter  uint64
	beforeGetLatestModelVersionByModelUIDCounter uint64
	GetLatestModelVersionByModelUIDMock          mRepositoryMockGetLatestModelVersionByModelUID

	funcGetLatestModelVersionRunByModelUID          func(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error)
	inspectFuncGetLatestModelVersionRunByModelUID   func(ctx context.Context, userUID string, modelUID string, version string)
	afterGetLatestModelVersionRunByModelUIDCounter  uint64
	beforeGetLatestModelVersionRunByModelUIDCounter uint64
	GetLatestModelVersionRunByModelUIDMock          mRepositoryMockGetLatestModelVersionRunByModelUID

	funcGetModelByUID          func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	inspectFuncGetModelByUID   func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)
	afterGetModelByUIDCounter  uint64
	beforeGetModelByUIDCounter uint64
	GetModelByUIDMock          mRepositoryMockGetModelByUID

	funcGetModelByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	inspectFuncGetModelByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)
	afterGetModelByUIDAdminCounter  uint64
	beforeGetModelByUIDAdminCounter uint64
	GetModelByUIDAdminMock          mRepositoryMockGetModelByUIDAdmin

	funcGetModelDefinition          func(id string) (mp1 *datamodel.ModelDefinition, err error)
	inspectFuncGetModelDefinition   func(id string)
	afterGetModelDefinitionCounter  uint64
	beforeGetModelDefinitionCounter uint64
	GetModelDefinitionMock          mRepositoryMockGetModelDefinition

	funcGetModelDefinitionByUID          func(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error)
	inspectFuncGetModelDefinitionByUID   func(uid uuid.UUID)
	afterGetModelDefinitionByUIDCounter  uint64
	beforeGetModelDefinitionByUIDCounter uint64
	GetModelDefinitionByUIDMock          mRepositoryMockGetModelDefinitionByUID

	funcGetModelRunByUID          func(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error)
	inspectFuncGetModelRunByUID   func(ctx context.Context, triggerUID string)
	afterGetModelRunByUIDCounter  uint64
	beforeGetModelRunByUIDCounter uint64
	GetModelRunByUIDMock          mRepositoryMockGetModelRunByUID

	funcGetModelVersionByID          func(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error)
	inspectFuncGetModelVersionByID   func(ctx context.Context, modelUID uuid.UUID, versionID string)
	afterGetModelVersionByIDCounter  uint64
	beforeGetModelVersionByIDCounter uint64
	GetModelVersionByIDMock          mRepositoryMockGetModelVersionByID

	funcGetNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	inspectFuncGetNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool)
	afterGetNamespaceModelByIDCounter  uint64
	beforeGetNamespaceModelByIDCounter uint64
	GetNamespaceModelByIDMock          mRepositoryMockGetNamespaceModelByID

	funcListModelDefinitions          func(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error)
	inspectFuncListModelDefinitions   func(view modelpb.View, pageSize int64, pageToken string)
	afterListModelDefinitionsCounter  uint64
	beforeListModelDefinitionsCounter uint64
	ListModelDefinitionsMock          mRepositoryMockListModelDefinitions

	funcListModelRuns          func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error)
	inspectFuncListModelRuns   func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string)
	afterListModelRunsCounter  uint64
	beforeListModelRunsCounter uint64
	ListModelRunsMock          mRepositoryMockListModelRuns

	funcListModelTags          func(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error)
	inspectFuncListModelTags   func(ctx context.Context, modelUID uuid.UUID)
	afterListModelTagsCounter  uint64
	beforeListModelTagsCounter uint64
	ListModelTagsMock          mRepositoryMockListModelTags

	funcListModelVersions          func(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error)
	inspectFuncListModelVersions   func(ctx context.Context, modelUID uuid.UUID, groupDigest bool)
	afterListModelVersionsCounter  uint64
	beforeListModelVersionsCounter uint64
	ListModelVersionsMock          mRepositoryMockListModelVersions

	funcListModelVersionsByDigest          func(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error)
	inspectFuncListModelVersionsByDigest   func(ctx context.Context, modelUID uuid.UUID, digest string)
	afterListModelVersionsByDigestCounter  uint64
	beforeListModelVersionsByDigestCounter uint64
	ListModelVersionsByDigestMock          mRepositoryMockListModelVersionsByDigest

	funcListModels          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)
	inspectFuncListModels   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)
	afterListModelsCounter  uint64
	beforeListModelsCounter uint64
	ListModelsMock          mRepositoryMockListModels

	funcListModelsAdmin          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error)
	inspectFuncListModelsAdmin   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool)
	afterListModelsAdminCounter  uint64
	beforeListModelsAdminCounter uint64
	ListModelsAdminMock          mRepositoryMockListModelsAdmin

	funcListNamespaceModels          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)
	inspectFuncListNamespaceModels   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)
	afterListNamespaceModelsCounter  uint64
	beforeListNamespaceModelsCounter uint64
	ListNamespaceModelsMock          mRepositoryMockListNamespaceModels

	funcPinUser          func(ctx context.Context, table string)
	inspectFuncPinUser   func(ctx context.Context, table string)
	afterPinUserCounter  uint64
	beforePinUserCounter uint64
	PinUserMock          mRepositoryMockPinUser

	funcUpdateModelRun          func(ctx context.Context, modelRun *datamodel.ModelRun) (err error)
	inspectFuncUpdateModelRun   func(ctx context.Context, modelRun *datamodel.ModelRun)
	afterUpdateModelRunCounter  uint64
	beforeUpdateModelRunCounter uint64
	UpdateModelRunMock          mRepositoryMockUpdateModelRun

	funcUpdateModelVersionDigestByID          func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error)
	inspectFuncUpdateModelVersionDigestByID   func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string)
	afterUpdateModelVersionDigestByIDCounter  uint64
	beforeUpdateModelVersionDigestByIDCounter uint64
	UpdateModelVersionDigestByIDMock          mRepositoryMockUpdateModelVersionDigestByID

	funcUpdateNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error)
	inspectFuncUpdateNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model)
	afterUpdateNamespaceModelByIDCounter  uint64
	beforeUpdateNamespaceModelByIDCounter uint64
	UpdateNamespaceModelByIDMock          mRepositoryMockUpdateNamespaceModelByID

	funcUpdateNamespaceModelIDByID          func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)
	inspectFuncUpdateNamespaceModelIDByID   func(ctx context.Context, ownerPermalink string, id string, newID string)
	afterUpdateNamespaceModelIDByIDCounter  uint64
	beforeUpdateNamespaceModelIDByIDCounter uint64
	UpdateNamespaceModelIDByIDMock          mRepositoryMockUpdateNamespaceModelIDByID
}

// NewRepositoryMock returns a mock for repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPinnedUserMock = mRepositoryMockCheckPinnedUser{mock: m}
	m.CheckPinnedUserMock.callArgs = []*RepositoryMockCheckPinnedUserParams{}

	m.CreateModelRunMock = mRepositoryMockCreateModelRun{mock: m}
	m.CreateModelRunMock.callArgs = []*RepositoryMockCreateModelRunParams{}

	m.CreateModelTagsMock = mRepositoryMockCreateModelTags{mock: m}
	m.CreateModelTagsMock.callArgs = []*RepositoryMockCreateModelTagsParams{}

	m.CreateModelVersionMock = mRepositoryMockCreateModelVersion{mock: m}
	m.CreateModelVersionMock.callArgs = []*RepositoryMockCreateModelVersionParams{}

	m.CreateNamespaceModelMock = mRepositoryMockCreateNamespaceModel{mock: m}
	m.CreateNamespaceModelMock.callArgs = []*RepositoryMockCreateNamespaceModelParams{}

	m.DeleteModelTagsMock = mRepositoryMockDeleteModelTags{mock: m}
	m.DeleteModelTagsMock.callArgs = []*RepositoryMockDeleteModelTagsParams{}

	m.DeleteModelVersionByDigestMock = mRepositoryMockDeleteModelVersionByDigest{mock: m}
	m.DeleteModelVersionByDigestMock.callArgs = []*RepositoryMockDeleteModelVersionByDigestParams{}

	m.DeleteModelVersionByIDMock = mRepositoryMockDeleteModelVersionByID{mock: m}
	m.DeleteModelVersionByIDMock.callArgs = []*RepositoryMockDeleteModelVersionByIDParams{}

	m.DeleteNamespaceModelByIDMock = mRepositoryMockDeleteNamespaceModelByID{mock: m}
	m.DeleteNamespaceModelByIDMock.callArgs = []*RepositoryMockDeleteNamespaceModelByIDParams{}

	m.GetLatestModelRunByModelUIDMock = mRepositoryMockGetLatestModelRunByModelUID{mock: m}
	m.GetLatestModelRunByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelRunByModelUIDParams{}

	m.GetLatestModelVersionByModelUIDMock = mRepositoryMockGetLatestModelVersionByModelUID{mock: m}
	m.GetLatestModelVersionByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelVersionByModelUIDParams{}

	m.GetLatestModelVersionRunByModelUIDMock = mRepositoryMockGetLatestModelVersionRunByModelUID{mock: m}
	m.GetLatestModelVersionRunByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelVersionRunByModelUIDParams{}

	m.GetModelByUIDMock = mRepositoryMockGetModelByUID{mock: m}
	m.GetModelByUIDMock.callArgs = []*RepositoryMockGetModelByUIDParams{}

	m.GetModelByUIDAdminMock = mRepositoryMockGetModelByUIDAdmin{mock: m}
	m.GetModelByUIDAdminMock.callArgs = []*RepositoryMockGetModelByUIDAdminParams{}

	m.GetModelDefinitionMock = mRepositoryMockGetModelDefinition{mock: m}
	m.GetModelDefinitionMock.callArgs = []*RepositoryMockGetModelDefinitionParams{}

	m.GetModelDefinitionByUIDMock = mRepositoryMockGetModelDefinitionByUID{mock: m}
	m.GetModelDefinitionByUIDMock.callArgs = []*RepositoryMockGetModelDefinitionByUIDParams{}

	m.GetModelRunByUIDMock = mRepositoryMockGetModelRunByUID{mock: m}
	m.GetModelRunByUIDMock.callArgs = []*RepositoryMockGetModelRunByUIDParams{}

	m.GetModelVersionByIDMock = mRepositoryMockGetModelVersionByID{mock: m}
	m.GetModelVersionByIDMock.callArgs = []*RepositoryMockGetModelVersionByIDParams{}

	m.GetNamespaceModelByIDMock = mRepositoryMockGetNamespaceModelByID{mock: m}
	m.GetNamespaceModelByIDMock.callArgs = []*RepositoryMockGetNamespaceModelByIDParams{}

	m.ListModelDefinitionsMock = mRepositoryMockListModelDefinitions{mock: m}
	m.ListModelDefinitionsMock.callArgs = []*RepositoryMockListModelDefinitionsParams{}

	m.ListModelRunsMock = mRepositoryMockListModelRuns{mock: m}
	m.ListModelRunsMock.callArgs = []*RepositoryMockListModelRunsParams{}

	m.ListModelTagsMock = mRepositoryMockListModelTags{mock: m}
	m.ListModelTagsMock.callArgs = []*RepositoryMockListModelTagsParams{}

	m.ListModelVersionsMock = mRepositoryMockListModelVersions{mock: m}
	m.ListModelVersionsMock.callArgs = []*RepositoryMockListModelVersionsParams{}

	m.ListModelVersionsByDigestMock = mRepositoryMockListModelVersionsByDigest{mock: m}
	m.ListModelVersionsByDigestMock.callArgs = []*RepositoryMockListModelVersionsByDigestParams{}

	m.ListModelsMock = mRepositoryMockListModels{mock: m}
	m.ListModelsMock.callArgs = []*RepositoryMockListModelsParams{}

	m.ListModelsAdminMock = mRepositoryMockListModelsAdmin{mock: m}
	m.ListModelsAdminMock.callArgs = []*RepositoryMockListModelsAdminParams{}

	m.ListNamespaceModelsMock = mRepositoryMockListNamespaceModels{mock: m}
	m.ListNamespaceModelsMock.callArgs = []*RepositoryMockListNamespaceModelsParams{}

	m.PinUserMock = mRepositoryMockPinUser{mock: m}
	m.PinUserMock.callArgs = []*RepositoryMockPinUserParams{}

	m.UpdateModelRunMock = mRepositoryMockUpdateModelRun{mock: m}
	m.UpdateModelRunMock.callArgs = []*RepositoryMockUpdateModelRunParams{}

	m.UpdateModelVersionDigestByIDMock = mRepositoryMockUpdateModelVersionDigestByID{mock: m}
	m.UpdateModelVersionDigestByIDMock.callArgs = []*RepositoryMockUpdateModelVersionDigestByIDParams{}

	m.UpdateNamespaceModelByIDMock = mRepositoryMockUpdateNamespaceModelByID{mock: m}
	m.UpdateNamespaceModelByIDMock.callArgs = []*RepositoryMockUpdateNamespaceModelByIDParams{}

	m.UpdateNamespaceModelIDByIDMock = mRepositoryMockUpdateNamespaceModelIDByID{mock: m}
	m.UpdateNamespaceModelIDByIDMock.callArgs = []*RepositoryMockUpdateNamespaceModelIDByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCheckPinnedUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckPinnedUserExpectation
	expectations       []*RepositoryMockCheckPinnedUserExpectation

	callArgs []*RepositoryMockCheckPinnedUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCheckPinnedUserExpectation specifies expectation struct of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCheckPinnedUserParams
	paramPtrs *RepositoryMockCheckPinnedUserParamPtrs
	results   *RepositoryMockCheckPinnedUserResults
	Counter   uint64
}

// RepositoryMockCheckPinnedUserParams contains parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParams struct {
	ctx   context.Context
	db    *gorm.DB
	table string
}

// RepositoryMockCheckPinnedUserParamPtrs contains pointers to parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParamPtrs struct {
	ctx   *context.Context
	db    **gorm.DB
	table *string
}

// RepositoryMockCheckPinnedUserResults contains results of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserResults struct {
	dp1 *gorm.DB
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Optional() *mRepositoryMockCheckPinnedUser {
	mmCheckPinnedUser.optional = true
	return mmCheckPinnedUser
}

// Expect sets up expected params for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Expect(ctx context.Context, db *gorm.DB, table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by ExpectParams functions")
	}

	mmCheckPinnedUser.defaultExpectation.params = &RepositoryMockCheckPinnedUserParams{ctx, db, table}
	for _, e := range mmCheckPinnedUser.expectations {
		if minimock.Equal(e.params, mmCheckPinnedUser.defaultExpectation.params) {
			mmCheckPinnedUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPinnedUser.defaultExpectation.params)
		}
	}

	return mmCheckPinnedUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCheckPinnedUser
}

// ExpectDbParam2 sets up expected param db for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectDbParam2(db *gorm.DB) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.db = &db

	return mmCheckPinnedUser
}

// ExpectTableParam3 sets up expected param table for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectTableParam3(table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.table = &table

	return mmCheckPinnedUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Inspect(f func(ctx context.Context, db *gorm.DB, table string)) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckPinnedUser")
	}

	mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser = f

	return mmCheckPinnedUser
}

// Return sets up results that will be returned by Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Return(dp1 *gorm.DB) *RepositoryMock {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{mock: mmCheckPinnedUser.mock}
	}
	mmCheckPinnedUser.defaultExpectation.results = &RepositoryMockCheckPinnedUserResults{dp1}
	return mmCheckPinnedUser.mock
}

// Set uses given function f to mock the Repository.CheckPinnedUser method
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Set(f func(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB)) *RepositoryMock {
	if mmCheckPinnedUser.defaultExpectation != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Default expectation is already set for the Repository.CheckPinnedUser method")
	}

	if len(mmCheckPinnedUser.expectations) > 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Some expectations are already set for the Repository.CheckPinnedUser method")
	}

	mmCheckPinnedUser.mock.funcCheckPinnedUser = f
	return mmCheckPinnedUser.mock
}

// When sets expectation for the Repository.CheckPinnedUser which will trigger the result defined by the following
// Then helper
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) When(ctx context.Context, db *gorm.DB, table string) *RepositoryMockCheckPinnedUserExpectation {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	expectation := &RepositoryMockCheckPinnedUserExpectation{
		mock:   mmCheckPinnedUser.mock,
		params: &RepositoryMockCheckPinnedUserParams{ctx, db, table},
	}
	mmCheckPinnedUser.expectations = append(mmCheckPinnedUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckPinnedUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckPinnedUserExpectation) Then(dp1 *gorm.DB) *RepositoryMock {
	e.results = &RepositoryMockCheckPinnedUserResults{dp1}
	return e.mock
}

// Times sets number of times Repository.CheckPinnedUser should be invoked
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Times(n uint64) *mRepositoryMockCheckPinnedUser {
	if n == 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Times of RepositoryMock.CheckPinnedUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPinnedUser.expectedInvocations, n)
	return mmCheckPinnedUser
}

func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) invocationsDone() bool {
	if len(mmCheckPinnedUser.expectations) == 0 && mmCheckPinnedUser.defaultExpectation == nil && mmCheckPinnedUser.mock.funcCheckPinnedUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.mock.afterCheckPinnedUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPinnedUser implements repository.Repository
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUser(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB) {
	mm_atomic.AddUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter, 1)

	if mmCheckPinnedUser.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.inspectFuncCheckPinnedUser(ctx, db, table)
	}

	mm_params := RepositoryMockCheckPinnedUserParams{ctx, db, table}

	// Record call args
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Lock()
	mmCheckPinnedUser.CheckPinnedUserMock.callArgs = append(mmCheckPinnedUser.CheckPinnedUserMock.callArgs, &mm_params)
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Unlock()

	for _, e := range mmCheckPinnedUser.CheckPinnedUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1
		}
	}

	if mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckPinnedUserParams{ctx, db, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.db != nil && !minimock.Equal(*mm_want_ptrs.db, mm_got.db) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter db, want: %#v, got: %#v%s\n", *mm_want_ptrs.db, mm_got.db, minimock.Diff(*mm_want_ptrs.db, mm_got.db))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter table, want: %#v, got: %#v%s\n", *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPinnedUser.t.Fatal("No results are set for the RepositoryMock.CheckPinnedUser")
		}
		return (*mm_results).dp1
	}
	if mmCheckPinnedUser.funcCheckPinnedUser != nil {
		return mmCheckPinnedUser.funcCheckPinnedUser(ctx, db, table)
	}
	mmCheckPinnedUser.t.Fatalf("Unexpected call to RepositoryMock.CheckPinnedUser. %v %v %v", ctx, db, table)
	return
}

// CheckPinnedUserAfterCounter returns a count of finished RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter)
}

// CheckPinnedUserBeforeCounter returns a count of RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckPinnedUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Calls() []*RepositoryMockCheckPinnedUserParams {
	mmCheckPinnedUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckPinnedUserParams, len(mmCheckPinnedUser.callArgs))
	copy(argCopy, mmCheckPinnedUser.callArgs)

	mmCheckPinnedUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPinnedUserDone returns true if the count of the CheckPinnedUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckPinnedUserDone() bool {
	if m.CheckPinnedUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPinnedUserMock.invocationsDone()
}

// MinimockCheckPinnedUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckPinnedUserInspect() {
	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser with params: %#v", *e.params)
		}
	}

	afterCheckPinnedUserCounter := mm_atomic.LoadUint64(&m.afterCheckPinnedUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPinnedUserMock.defaultExpectation != nil && afterCheckPinnedUserCounter < 1 {
		if m.CheckPinnedUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CheckPinnedUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser with params: %#v", *m.CheckPinnedUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPinnedUser != nil && afterCheckPinnedUserCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CheckPinnedUser")
	}

	if !m.CheckPinnedUserMock.invocationsDone() && afterCheckPinnedUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckPinnedUser but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPinnedUserMock.expectedInvocations), afterCheckPinnedUserCounter)
	}
}

type mRepositoryMockCreateModelRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelRunExpectation
	expectations       []*RepositoryMockCreateModelRunExpectation

	callArgs []*RepositoryMockCreateModelRunParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateModelRunExpectation specifies expectation struct of the Repository.CreateModelRun
type RepositoryMockCreateModelRunExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateModelRunParams
	paramPtrs *RepositoryMockCreateModelRunParamPtrs
	results   *RepositoryMockCreateModelRunResults
	Counter   uint64
}

// RepositoryMockCreateModelRunParams contains parameters of the Repository.CreateModelRun
type RepositoryMockCreateModelRunParams struct {
	ctx      context.Context
	modelRun *datamodel.ModelRun
}

// RepositoryMockCreateModelRunParamPtrs contains pointers to parameters of the Repository.CreateModelRun
type RepositoryMockCreateModelRunParamPtrs struct {
	ctx      *context.Context
	modelRun **datamodel.ModelRun
}

// RepositoryMockCreateModelRunResults contains results of the Repository.CreateModelRun
type RepositoryMockCreateModelRunResults struct {
	mp1 *datamodel.ModelRun
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Optional() *mRepositoryMockCreateModelRun {
	mmCreateModelRun.optional = true
	return mmCreateModelRun
}

// Expect sets up expected params for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Expect(ctx context.Context, modelRun *datamodel.ModelRun) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by ExpectParams functions")
	}

	mmCreateModelRun.defaultExpectation.params = &RepositoryMockCreateModelRunParams{ctx, modelRun}
	for _, e := range mmCreateModelRun.expectations {
		if minimock.Equal(e.params, mmCreateModelRun.defaultExpectation.params) {
			mmCreateModelRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelRun.defaultExpectation.params)
		}
	}

	return mmCreateModelRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.params != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Expect")
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs == nil {
		mmCreateModelRun.defaultExpectation.paramPtrs = &RepositoryMockCreateModelRunParamPtrs{}
	}
	mmCreateModelRun.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateModelRun
}

// ExpectModelRunParam2 sets up expected param modelRun for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) ExpectModelRunParam2(modelRun *datamodel.ModelRun) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.params != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Expect")
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs == nil {
		mmCreateModelRun.defaultExpectation.paramPtrs = &RepositoryMockCreateModelRunParamPtrs{}
	}
	mmCreateModelRun.defaultExpectation.paramPtrs.modelRun = &modelRun

	return mmCreateModelRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Inspect(f func(ctx context.Context, modelRun *datamodel.ModelRun)) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.inspectFuncCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelRun")
	}

	mmCreateModelRun.mock.inspectFuncCreateModelRun = f

	return mmCreateModelRun
}

// Return sets up results that will be returned by Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Return(mp1 *datamodel.ModelRun, err error) *RepositoryMock {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{mock: mmCreateModelRun.mock}
	}
	mmCreateModelRun.defaultExpectation.results = &RepositoryMockCreateModelRunResults{mp1, err}
	return mmCreateModelRun.mock
}

// Set uses given function f to mock the Repository.CreateModelRun method
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Set(f func(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmCreateModelRun.defaultExpectation != nil {
		mmCreateModelRun.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelRun method")
	}

	if len(mmCreateModelRun.expectations) > 0 {
		mmCreateModelRun.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelRun method")
	}

	mmCreateModelRun.mock.funcCreateModelRun = f
	return mmCreateModelRun.mock
}

// When sets expectation for the Repository.CreateModelRun which will trigger the result defined by the following
// Then helper
func (mmCreateModelRun *mRepositoryMockCreateModelRun) When(ctx context.Context, modelRun *datamodel.ModelRun) *RepositoryMockCreateModelRunExpectation {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelRunExpectation{
		mock:   mmCreateModelRun.mock,
		params: &RepositoryMockCreateModelRunParams{ctx, modelRun},
	}
	mmCreateModelRun.expectations = append(mmCreateModelRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelRunExpectation) Then(mp1 *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelRunResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateModelRun should be invoked
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Times(n uint64) *mRepositoryMockCreateModelRun {
	if n == 0 {
		mmCreateModelRun.mock.t.Fatalf("Times of RepositoryMock.CreateModelRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelRun.expectedInvocations, n)
	return mmCreateModelRun
}

func (mmCreateModelRun *mRepositoryMockCreateModelRun) invocationsDone() bool {
	if len(mmCreateModelRun.expectations) == 0 && mmCreateModelRun.defaultExpectation == nil && mmCreateModelRun.mock.funcCreateModelRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelRun.mock.afterCreateModelRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelRun implements repository.Repository
func (mmCreateModelRun *RepositoryMock) CreateModelRun(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmCreateModelRun.beforeCreateModelRunCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelRun.afterCreateModelRunCounter, 1)

	if mmCreateModelRun.inspectFuncCreateModelRun != nil {
		mmCreateModelRun.inspectFuncCreateModelRun(ctx, modelRun)
	}

	mm_params := RepositoryMockCreateModelRunParams{ctx, modelRun}

	// Record call args
	mmCreateModelRun.CreateModelRunMock.mutex.Lock()
	mmCreateModelRun.CreateModelRunMock.callArgs = append(mmCreateModelRun.CreateModelRunMock.callArgs, &mm_params)
	mmCreateModelRun.CreateModelRunMock.mutex.Unlock()

	for _, e := range mmCreateModelRun.CreateModelRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmCreateModelRun.CreateModelRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelRun.CreateModelRunMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelRun.CreateModelRunMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelRun.CreateModelRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelRunParams{ctx, modelRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelRun != nil && !minimock.Equal(*mm_want_ptrs.modelRun, mm_got.modelRun) {
				mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameter modelRun, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelRun, mm_got.modelRun, minimock.Diff(*mm_want_ptrs.modelRun, mm_got.modelRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelRun.CreateModelRunMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelRun.t.Fatal("No results are set for the RepositoryMock.CreateModelRun")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmCreateModelRun.funcCreateModelRun != nil {
		return mmCreateModelRun.funcCreateModelRun(ctx, modelRun)
	}
	mmCreateModelRun.t.Fatalf("Unexpected call to RepositoryMock.CreateModelRun. %v %v", ctx, modelRun)
	return
}

// CreateModelRunAfterCounter returns a count of finished RepositoryMock.CreateModelRun invocations
func (mmCreateModelRun *RepositoryMock) CreateModelRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelRun.afterCreateModelRunCounter)
}

// CreateModelRunBeforeCounter returns a count of RepositoryMock.CreateModelRun invocations
func (mmCreateModelRun *RepositoryMock) CreateModelRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelRun.beforeCreateModelRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Calls() []*RepositoryMockCreateModelRunParams {
	mmCreateModelRun.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelRunParams, len(mmCreateModelRun.callArgs))
	copy(argCopy, mmCreateModelRun.callArgs)

	mmCreateModelRun.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelRunDone returns true if the count of the CreateModelRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelRunDone() bool {
	if m.CreateModelRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelRunMock.invocationsDone()
}

// MinimockCreateModelRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelRunInspect() {
	for _, e := range m.CreateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelRun with params: %#v", *e.params)
		}
	}

	afterCreateModelRunCounter := mm_atomic.LoadUint64(&m.afterCreateModelRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelRunMock.defaultExpectation != nil && afterCreateModelRunCounter < 1 {
		if m.CreateModelRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateModelRun")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelRun with params: %#v", *m.CreateModelRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelRun != nil && afterCreateModelRunCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateModelRun")
	}

	if !m.CreateModelRunMock.invocationsDone() && afterCreateModelRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelRun but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelRunMock.expectedInvocations), afterCreateModelRunCounter)
	}
}

type mRepositoryMockCreateModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelTagsExpectation
	expectations       []*RepositoryMockCreateModelTagsExpectation

	callArgs []*RepositoryMockCreateModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateModelTagsExpectation specifies expectation struct of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateModelTagsParams
	paramPtrs *RepositoryMockCreateModelTagsParamPtrs
	results   *RepositoryMockCreateModelTagsResults
	Counter   uint64
}

// RepositoryMockCreateModelTagsParams contains parameters of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	tagNames []string
}

// RepositoryMockCreateModelTagsParamPtrs contains pointers to parameters of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	tagNames *[]string
}

// RepositoryMockCreateModelTagsResults contains results of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Optional() *mRepositoryMockCreateModelTags {
	mmCreateModelTags.optional = true
	return mmCreateModelTags
}

// Expect sets up expected params for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Expect(ctx context.Context, modelUID uuid.UUID, tagNames []string) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by ExpectParams functions")
	}

	mmCreateModelTags.defaultExpectation.params = &RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}
	for _, e := range mmCreateModelTags.expectations {
		if minimock.Equal(e.params, mmCreateModelTags.defaultExpectation.params) {
			mmCreateModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelTags.defaultExpectation.params)
		}
	}

	return mmCreateModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmCreateModelTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.tagNames = &tagNames

	return mmCreateModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string)) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.inspectFuncCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelTags")
	}

	mmCreateModelTags.mock.inspectFuncCreateModelTags = f

	return mmCreateModelTags
}

// Return sets up results that will be returned by Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Return(err error) *RepositoryMock {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{mock: mmCreateModelTags.mock}
	}
	mmCreateModelTags.defaultExpectation.results = &RepositoryMockCreateModelTagsResults{err}
	return mmCreateModelTags.mock
}

// Set uses given function f to mock the Repository.CreateModelTags method
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmCreateModelTags.defaultExpectation != nil {
		mmCreateModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelTags method")
	}

	if len(mmCreateModelTags.expectations) > 0 {
		mmCreateModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelTags method")
	}

	mmCreateModelTags.mock.funcCreateModelTags = f
	return mmCreateModelTags.mock
}

// When sets expectation for the Repository.CreateModelTags which will trigger the result defined by the following
// Then helper
func (mmCreateModelTags *mRepositoryMockCreateModelTags) When(ctx context.Context, modelUID uuid.UUID, tagNames []string) *RepositoryMockCreateModelTagsExpectation {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelTagsExpectation{
		mock:   mmCreateModelTags.mock,
		params: &RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames},
	}
	mmCreateModelTags.expectations = append(mmCreateModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateModelTags should be invoked
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Times(n uint64) *mRepositoryMockCreateModelTags {
	if n == 0 {
		mmCreateModelTags.mock.t.Fatalf("Times of RepositoryMock.CreateModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelTags.expectedInvocations, n)
	return mmCreateModelTags
}

func (mmCreateModelTags *mRepositoryMockCreateModelTags) invocationsDone() bool {
	if len(mmCreateModelTags.expectations) == 0 && mmCreateModelTags.defaultExpectation == nil && mmCreateModelTags.mock.funcCreateModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelTags.mock.afterCreateModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelTags implements repository.Repository
func (mmCreateModelTags *RepositoryMock) CreateModelTags(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmCreateModelTags.beforeCreateModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelTags.afterCreateModelTagsCounter, 1)

	if mmCreateModelTags.inspectFuncCreateModelTags != nil {
		mmCreateModelTags.inspectFuncCreateModelTags(ctx, modelUID, tagNames)
	}

	mm_params := RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}

	// Record call args
	mmCreateModelTags.CreateModelTagsMock.mutex.Lock()
	mmCreateModelTags.CreateModelTagsMock.callArgs = append(mmCreateModelTags.CreateModelTagsMock.callArgs, &mm_params)
	mmCreateModelTags.CreateModelTagsMock.mutex.Unlock()

	for _, e := range mmCreateModelTags.CreateModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateModelTags.CreateModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelTags.CreateModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter tagNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelTags.t.Fatal("No results are set for the RepositoryMock.CreateModelTags")
		}
		return (*mm_results).err
	}
	if mmCreateModelTags.funcCreateModelTags != nil {
		return mmCreateModelTags.funcCreateModelTags(ctx, modelUID, tagNames)
	}
	mmCreateModelTags.t.Fatalf("Unexpected call to RepositoryMock.CreateModelTags. %v %v %v", ctx, modelUID, tagNames)
	return
}

// CreateModelTagsAfterCounter returns a count of finished RepositoryMock.CreateModelTags invocations
func (mmCreateModelTags *RepositoryMock) CreateModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelTags.afterCreateModelTagsCounter)
}

// CreateModelTagsBeforeCounter returns a count of RepositoryMock.CreateModelTags invocations
func (mmCreateModelTags *RepositoryMock) CreateModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelTags.beforeCreateModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Calls() []*RepositoryMockCreateModelTagsParams {
	mmCreateModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelTagsParams, len(mmCreateModelTags.callArgs))
	copy(argCopy, mmCreateModelTags.callArgs)

	mmCreateModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelTagsDone returns true if the count of the CreateModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelTagsDone() bool {
	if m.CreateModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelTagsMock.invocationsDone()
}

// MinimockCreateModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelTagsInspect() {
	for _, e := range m.CreateModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelTags with params: %#v", *e.params)
		}
	}

	afterCreateModelTagsCounter := mm_atomic.LoadUint64(&m.afterCreateModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelTagsMock.defaultExpectation != nil && afterCreateModelTagsCounter < 1 {
		if m.CreateModelTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateModelTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelTags with params: %#v", *m.CreateModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelTags != nil && afterCreateModelTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateModelTags")
	}

	if !m.CreateModelTagsMock.invocationsDone() && afterCreateModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelTags but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelTagsMock.expectedInvocations), afterCreateModelTagsCounter)
	}
}

type mRepositoryMockCreateModelVersion struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelVersionExpectation
	expectations       []*RepositoryMockCreateModelVersionExpectation

	callArgs []*RepositoryMockCreateModelVersionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateModelVersionExpectation specifies expectation struct of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateModelVersionParams
	paramPtrs *RepositoryMockCreateModelVersionParamPtrs
	results   *RepositoryMockCreateModelVersionResults
	Counter   uint64
}

// RepositoryMockCreateModelVersionParams contains parameters of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionParams struct {
	ctx            context.Context
	ownerPermalink string
	version        *datamodel.ModelVersion
}

// RepositoryMockCreateModelVersionParamPtrs contains pointers to parameters of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	version        **datamodel.ModelVersion
}

// RepositoryMockCreateModelVersionResults contains results of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Optional() *mRepositoryMockCreateModelVersion {
	mmCreateModelVersion.optional = true
	return mmCreateModelVersion
}

// Expect sets up expected params for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Expect(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by ExpectParams functions")
	}

	mmCreateModelVersion.defaultExpectation.params = &RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}
	for _, e := range mmCreateModelVersion.expectations {
		if minimock.Equal(e.params, mmCreateModelVersion.defaultExpectation.params) {
			mmCreateModelVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelVersion.defaultExpectation.params)
		}
	}

	return mmCreateModelVersion
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateModelVersion
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmCreateModelVersion
}

// ExpectVersionParam3 sets up expected param version for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectVersionParam3(version *datamodel.ModelVersion) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.version = &version

	return mmCreateModelVersion
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Inspect(f func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion)) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.inspectFuncCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelVersion")
	}

	mmCreateModelVersion.mock.inspectFuncCreateModelVersion = f

	return mmCreateModelVersion
}

// Return sets up results that will be returned by Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Return(err error) *RepositoryMock {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{mock: mmCreateModelVersion.mock}
	}
	mmCreateModelVersion.defaultExpectation.results = &RepositoryMockCreateModelVersionResults{err}
	return mmCreateModelVersion.mock
}

// Set uses given function f to mock the Repository.CreateModelVersion method
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Set(f func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error)) *RepositoryMock {
	if mmCreateModelVersion.defaultExpectation != nil {
		mmCreateModelVersion.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelVersion method")
	}

	if len(mmCreateModelVersion.expectations) > 0 {
		mmCreateModelVersion.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelVersion method")
	}

	mmCreateModelVersion.mock.funcCreateModelVersion = f
	return mmCreateModelVersion.mock
}

// When sets expectation for the Repository.CreateModelVersion which will trigger the result defined by the following
// Then helper
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) When(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) *RepositoryMockCreateModelVersionExpectation {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelVersionExpectation{
		mock:   mmCreateModelVersion.mock,
		params: &RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version},
	}
	mmCreateModelVersion.expectations = append(mmCreateModelVersion.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelVersion return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelVersionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelVersionResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateModelVersion should be invoked
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Times(n uint64) *mRepositoryMockCreateModelVersion {
	if n == 0 {
		mmCreateModelVersion.mock.t.Fatalf("Times of RepositoryMock.CreateModelVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelVersion.expectedInvocations, n)
	return mmCreateModelVersion
}

func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) invocationsDone() bool {
	if len(mmCreateModelVersion.expectations) == 0 && mmCreateModelVersion.defaultExpectation == nil && mmCreateModelVersion.mock.funcCreateModelVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelVersion.mock.afterCreateModelVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelVersion implements repository.Repository
func (mmCreateModelVersion *RepositoryMock) CreateModelVersion(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error) {
	mm_atomic.AddUint64(&mmCreateModelVersion.beforeCreateModelVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelVersion.afterCreateModelVersionCounter, 1)

	if mmCreateModelVersion.inspectFuncCreateModelVersion != nil {
		mmCreateModelVersion.inspectFuncCreateModelVersion(ctx, ownerPermalink, version)
	}

	mm_params := RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}

	// Record call args
	mmCreateModelVersion.CreateModelVersionMock.mutex.Lock()
	mmCreateModelVersion.CreateModelVersionMock.callArgs = append(mmCreateModelVersion.CreateModelVersionMock.callArgs, &mm_params)
	mmCreateModelVersion.CreateModelVersionMock.mutex.Unlock()

	for _, e := range mmCreateModelVersion.CreateModelVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateModelVersion.CreateModelVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter version, want: %#v, got: %#v%s\n", *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelVersion.t.Fatal("No results are set for the RepositoryMock.CreateModelVersion")
		}
		return (*mm_results).err
	}
	if mmCreateModelVersion.funcCreateModelVersion != nil {
		return mmCreateModelVersion.funcCreateModelVersion(ctx, ownerPermalink, version)
	}
	mmCreateModelVersion.t.Fatalf("Unexpected call to RepositoryMock.CreateModelVersion. %v %v %v", ctx, ownerPermalink, version)
	return
}

// CreateModelVersionAfterCounter returns a count of finished RepositoryMock.CreateModelVersion invocations
func (mmCreateModelVersion *RepositoryMock) CreateModelVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelVersion.afterCreateModelVersionCounter)
}

// CreateModelVersionBeforeCounter returns a count of RepositoryMock.CreateModelVersion invocations
func (mmCreateModelVersion *RepositoryMock) CreateModelVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelVersion.beforeCreateModelVersionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Calls() []*RepositoryMockCreateModelVersionParams {
	mmCreateModelVersion.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelVersionParams, len(mmCreateModelVersion.callArgs))
	copy(argCopy, mmCreateModelVersion.callArgs)

	mmCreateModelVersion.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelVersionDone returns true if the count of the CreateModelVersion invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelVersionDone() bool {
	if m.CreateModelVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelVersionMock.invocationsDone()
}

// MinimockCreateModelVersionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelVersionInspect() {
	for _, e := range m.CreateModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion with params: %#v", *e.params)
		}
	}

	afterCreateModelVersionCounter := mm_atomic.LoadUint64(&m.afterCreateModelVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelVersionMock.defaultExpectation != nil && afterCreateModelVersionCounter < 1 {
		if m.CreateModelVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateModelVersion")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion with params: %#v", *m.CreateModelVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelVersion != nil && afterCreateModelVersionCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateModelVersion")
	}

	if !m.CreateModelVersionMock.invocationsDone() && afterCreateModelVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelVersion but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelVersionMock.expectedInvocations), afterCreateModelVersionCounter)
	}
}

type mRepositoryMockCreateNamespaceModel struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceModelExpectation
	expectations       []*RepositoryMockCreateNamespaceModelExpectation

	callArgs []*RepositoryMockCreateNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockCreateNamespaceModelExpectation specifies expectation struct of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockCreateNamespaceModelParams
	paramPtrs *RepositoryMockCreateNamespaceModelParamPtrs
	results   *RepositoryMockCreateNamespaceModelResults
	Counter   uint64
}

// RepositoryMockCreateNamespaceModelParams contains parameters of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelParams struct {
	ctx            context.Context
	ownerPermalink string
	model          *datamodel.Model
}

// RepositoryMockCreateNamespaceModelParamPtrs contains pointers to parameters of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	model          **datamodel.Model
}

// RepositoryMockCreateNamespaceModelResults contains results of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Optional() *mRepositoryMockCreateNamespaceModel {
	mmCreateNamespaceModel.optional = true
	return mmCreateNamespaceModel
}

// Expect sets up expected params for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Expect(ctx context.Context, ownerPermalink string, model *datamodel.Model) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceModel.defaultExpectation.params = &RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}
	for _, e := range mmCreateNamespaceModel.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceModel.defaultExpectation.params) {
			mmCreateNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceModel.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateNamespaceModel
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmCreateNamespaceModel
}

// ExpectModelParam3 sets up expected param model for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectModelParam3(model *datamodel.Model) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.model = &model

	return mmCreateNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Inspect(f func(ctx context.Context, ownerPermalink string, model *datamodel.Model)) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceModel")
	}

	mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel = f

	return mmCreateNamespaceModel
}

// Return sets up results that will be returned by Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Return(err error) *RepositoryMock {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{mock: mmCreateNamespaceModel.mock}
	}
	mmCreateNamespaceModel.defaultExpectation.results = &RepositoryMockCreateNamespaceModelResults{err}
	return mmCreateNamespaceModel.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceModel method
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Set(f func(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error)) *RepositoryMock {
	if mmCreateNamespaceModel.defaultExpectation != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceModel method")
	}

	if len(mmCreateNamespaceModel.expectations) > 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceModel method")
	}

	mmCreateNamespaceModel.mock.funcCreateNamespaceModel = f
	return mmCreateNamespaceModel.mock
}

// When sets expectation for the Repository.CreateNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) When(ctx context.Context, ownerPermalink string, model *datamodel.Model) *RepositoryMockCreateNamespaceModelExpectation {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceModelExpectation{
		mock:   mmCreateNamespaceModel.mock,
		params: &RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model},
	}
	mmCreateNamespaceModel.expectations = append(mmCreateNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceModel return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceModelExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceModelResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceModel should be invoked
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Times(n uint64) *mRepositoryMockCreateNamespaceModel {
	if n == 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceModel.expectedInvocations, n)
	return mmCreateNamespaceModel
}

func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) invocationsDone() bool {
	if len(mmCreateNamespaceModel.expectations) == 0 && mmCreateNamespaceModel.defaultExpectation == nil && mmCreateNamespaceModel.mock.funcCreateNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.mock.afterCreateNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceModel implements repository.Repository
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModel(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter, 1)

	if mmCreateNamespaceModel.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.inspectFuncCreateNamespaceModel(ctx, ownerPermalink, model)
	}

	mm_params := RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}

	// Record call args
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Lock()
	mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs = append(mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs, &mm_params)
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceModel.CreateNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter model, want: %#v, got: %#v%s\n", *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceModel.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceModel")
		}
		return (*mm_results).err
	}
	if mmCreateNamespaceModel.funcCreateNamespaceModel != nil {
		return mmCreateNamespaceModel.funcCreateNamespaceModel(ctx, ownerPermalink, model)
	}
	mmCreateNamespaceModel.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceModel. %v %v %v", ctx, ownerPermalink, model)
	return
}

// CreateNamespaceModelAfterCounter returns a count of finished RepositoryMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter)
}

// CreateNamespaceModelBeforeCounter returns a count of RepositoryMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Calls() []*RepositoryMockCreateNamespaceModelParams {
	mmCreateNamespaceModel.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceModelParams, len(mmCreateNamespaceModel.callArgs))
	copy(argCopy, mmCreateNamespaceModel.callArgs)

	mmCreateNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceModelDone returns true if the count of the CreateNamespaceModel invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceModelDone() bool {
	if m.CreateNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceModelMock.invocationsDone()
}

// MinimockCreateNamespaceModelInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceModelInspect() {
	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel with params: %#v", *e.params)
		}
	}

	afterCreateNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceModelMock.defaultExpectation != nil && afterCreateNamespaceModelCounter < 1 {
		if m.CreateNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateNamespaceModel")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel with params: %#v", *m.CreateNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceModel != nil && afterCreateNamespaceModelCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateNamespaceModel")
	}

	if !m.CreateNamespaceModelMock.invocationsDone() && afterCreateNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceModel but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceModelMock.expectedInvocations), afterCreateNamespaceModelCounter)
	}
}

type mRepositoryMockDeleteModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelTagsExpectation
	expectations       []*RepositoryMockDeleteModelTagsExpectation

	callArgs []*RepositoryMockDeleteModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteModelTagsExpectation specifies expectation struct of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteModelTagsParams
	paramPtrs *RepositoryMockDeleteModelTagsParamPtrs
	results   *RepositoryMockDeleteModelTagsResults
	Counter   uint64
}

// RepositoryMockDeleteModelTagsParams contains parameters of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	tagNames []string
}

// RepositoryMockDeleteModelTagsParamPtrs contains pointers to parameters of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	tagNames *[]string
}

// RepositoryMockDeleteModelTagsResults contains results of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Optional() *mRepositoryMockDeleteModelTags {
	mmDeleteModelTags.optional = true
	return mmDeleteModelTags
}

// Expect sets up expected params for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Expect(ctx context.Context, modelUID uuid.UUID, tagNames []string) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by ExpectParams functions")
	}

	mmDeleteModelTags.defaultExpectation.params = &RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}
	for _, e := range mmDeleteModelTags.expectations {
		if minimock.Equal(e.params, mmDeleteModelTags.defaultExpectation.params) {
			mmDeleteModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelTags.defaultExpectation.params)
		}
	}

	return mmDeleteModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmDeleteModelTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.tagNames = &tagNames

	return mmDeleteModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string)) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.inspectFuncDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelTags")
	}

	mmDeleteModelTags.mock.inspectFuncDeleteModelTags = f

	return mmDeleteModelTags
}

// Return sets up results that will be returned by Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Return(err error) *RepositoryMock {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{mock: mmDeleteModelTags.mock}
	}
	mmDeleteModelTags.defaultExpectation.results = &RepositoryMockDeleteModelTagsResults{err}
	return mmDeleteModelTags.mock
}

// Set uses given function f to mock the Repository.DeleteModelTags method
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmDeleteModelTags.defaultExpectation != nil {
		mmDeleteModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelTags method")
	}

	if len(mmDeleteModelTags.expectations) > 0 {
		mmDeleteModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelTags method")
	}

	mmDeleteModelTags.mock.funcDeleteModelTags = f
	return mmDeleteModelTags.mock
}

// When sets expectation for the Repository.DeleteModelTags which will trigger the result defined by the following
// Then helper
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) When(ctx context.Context, modelUID uuid.UUID, tagNames []string) *RepositoryMockDeleteModelTagsExpectation {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelTagsExpectation{
		mock:   mmDeleteModelTags.mock,
		params: &RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames},
	}
	mmDeleteModelTags.expectations = append(mmDeleteModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelTags should be invoked
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Times(n uint64) *mRepositoryMockDeleteModelTags {
	if n == 0 {
		mmDeleteModelTags.mock.t.Fatalf("Times of RepositoryMock.DeleteModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelTags.expectedInvocations, n)
	return mmDeleteModelTags
}

func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) invocationsDone() bool {
	if len(mmDeleteModelTags.expectations) == 0 && mmDeleteModelTags.defaultExpectation == nil && mmDeleteModelTags.mock.funcDeleteModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelTags.mock.afterDeleteModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelTags implements repository.Repository
func (mmDeleteModelTags *RepositoryMock) DeleteModelTags(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelTags.beforeDeleteModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelTags.afterDeleteModelTagsCounter, 1)

	if mmDeleteModelTags.inspectFuncDeleteModelTags != nil {
		mmDeleteModelTags.inspectFuncDeleteModelTags(ctx, modelUID, tagNames)
	}

	mm_params := RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}

	// Record call args
	mmDeleteModelTags.DeleteModelTagsMock.mutex.Lock()
	mmDeleteModelTags.DeleteModelTagsMock.callArgs = append(mmDeleteModelTags.DeleteModelTagsMock.callArgs, &mm_params)
	mmDeleteModelTags.DeleteModelTagsMock.mutex.Unlock()

	for _, e := range mmDeleteModelTags.DeleteModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter tagNames, want: %#v, got: %#v%s\n", *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelTags.t.Fatal("No results are set for the RepositoryMock.DeleteModelTags")
		}
		return (*mm_results).err
	}
	if mmDeleteModelTags.funcDeleteModelTags != nil {
		return mmDeleteModelTags.funcDeleteModelTags(ctx, modelUID, tagNames)
	}
	mmDeleteModelTags.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelTags. %v %v %v", ctx, modelUID, tagNames)
	return
}

// DeleteModelTagsAfterCounter returns a count of finished RepositoryMock.DeleteModelTags invocations
func (mmDeleteModelTags *RepositoryMock) DeleteModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelTags.afterDeleteModelTagsCounter)
}

// DeleteModelTagsBeforeCounter returns a count of RepositoryMock.DeleteModelTags invocations
func (mmDeleteModelTags *RepositoryMock) DeleteModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelTags.beforeDeleteModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Calls() []*RepositoryMockDeleteModelTagsParams {
	mmDeleteModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelTagsParams, len(mmDeleteModelTags.callArgs))
	copy(argCopy, mmDeleteModelTags.callArgs)

	mmDeleteModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelTagsDone returns true if the count of the DeleteModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelTagsDone() bool {
	if m.DeleteModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelTagsMock.invocationsDone()
}

// MinimockDeleteModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelTagsInspect() {
	for _, e := range m.DeleteModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags with params: %#v", *e.params)
		}
	}

	afterDeleteModelTagsCounter := mm_atomic.LoadUint64(&m.afterDeleteModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelTagsMock.defaultExpectation != nil && afterDeleteModelTagsCounter < 1 {
		if m.DeleteModelTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteModelTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags with params: %#v", *m.DeleteModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelTags != nil && afterDeleteModelTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteModelTags")
	}

	if !m.DeleteModelTagsMock.invocationsDone() && afterDeleteModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelTags but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelTagsMock.expectedInvocations), afterDeleteModelTagsCounter)
	}
}

type mRepositoryMockDeleteModelVersionByDigest struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelVersionByDigestExpectation
	expectations       []*RepositoryMockDeleteModelVersionByDigestExpectation

	callArgs []*RepositoryMockDeleteModelVersionByDigestParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteModelVersionByDigestExpectation specifies expectation struct of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteModelVersionByDigestParams
	paramPtrs *RepositoryMockDeleteModelVersionByDigestParamPtrs
	results   *RepositoryMockDeleteModelVersionByDigestResults
	Counter   uint64
}

// RepositoryMockDeleteModelVersionByDigestParams contains parameters of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	digest   string
}

// RepositoryMockDeleteModelVersionByDigestParamPtrs contains pointers to parameters of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	digest   *string
}

// RepositoryMockDeleteModelVersionByDigestResults contains results of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Optional() *mRepositoryMockDeleteModelVersionByDigest {
	mmDeleteModelVersionByDigest.optional = true
	return mmDeleteModelVersionByDigest
}

// Expect sets up expected params for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Expect(ctx context.Context, modelUID uuid.UUID, digest string) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by ExpectParams functions")
	}

	mmDeleteModelVersionByDigest.defaultExpectation.params = &RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}
	for _, e := range mmDeleteModelVersionByDigest.expectations {
		if minimock.Equal(e.params, mmDeleteModelVersionByDigest.defaultExpectation.params) {
			mmDeleteModelVersionByDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelVersionByDigest.defaultExpectation.params)
		}
	}

	return mmDeleteModelVersionByDigest
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteModelVersionByDigest
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmDeleteModelVersionByDigest
}

// ExpectDigestParam3 sets up expected param digest for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectDigestParam3(digest string) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.digest = &digest

	return mmDeleteModelVersionByDigest
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Inspect(f func(ctx context.Context, modelUID uuid.UUID, digest string)) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.inspectFuncDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelVersionByDigest")
	}

	mmDeleteModelVersionByDigest.mock.inspectFuncDeleteModelVersionByDigest = f

	return mmDeleteModelVersionByDigest
}

// Return sets up results that will be returned by Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Return(err error) *RepositoryMock {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{mock: mmDeleteModelVersionByDigest.mock}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.results = &RepositoryMockDeleteModelVersionByDigestResults{err}
	return mmDeleteModelVersionByDigest.mock
}

// Set uses given function f to mock the Repository.DeleteModelVersionByDigest method
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Set(f func(ctx context.Context, modelUID uuid.UUID, digest string) (err error)) *RepositoryMock {
	if mmDeleteModelVersionByDigest.defaultExpectation != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelVersionByDigest method")
	}

	if len(mmDeleteModelVersionByDigest.expectations) > 0 {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelVersionByDigest method")
	}

	mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest = f
	return mmDeleteModelVersionByDigest.mock
}

// When sets expectation for the Repository.DeleteModelVersionByDigest which will trigger the result defined by the following
// Then helper
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) When(ctx context.Context, modelUID uuid.UUID, digest string) *RepositoryMockDeleteModelVersionByDigestExpectation {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelVersionByDigestExpectation{
		mock:   mmDeleteModelVersionByDigest.mock,
		params: &RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest},
	}
	mmDeleteModelVersionByDigest.expectations = append(mmDeleteModelVersionByDigest.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelVersionByDigest return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelVersionByDigestExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelVersionByDigestResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelVersionByDigest should be invoked
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Times(n uint64) *mRepositoryMockDeleteModelVersionByDigest {
	if n == 0 {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Times of RepositoryMock.DeleteModelVersionByDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelVersionByDigest.expectedInvocations, n)
	return mmDeleteModelVersionByDigest
}

func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) invocationsDone() bool {
	if len(mmDeleteModelVersionByDigest.expectations) == 0 && mmDeleteModelVersionByDigest.defaultExpectation == nil && mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.mock.afterDeleteModelVersionByDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelVersionByDigest implements repository.Repository
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigest(ctx context.Context, modelUID uuid.UUID, digest string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.beforeDeleteModelVersionByDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.afterDeleteModelVersionByDigestCounter, 1)

	if mmDeleteModelVersionByDigest.inspectFuncDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.inspectFuncDeleteModelVersionByDigest(ctx, modelUID, digest)
	}

	mm_params := RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}

	// Record call args
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.mutex.Lock()
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.callArgs = append(mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.callArgs, &mm_params)
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.mutex.Unlock()

	for _, e := range mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter digest, want: %#v, got: %#v%s\n", *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelVersionByDigest.t.Fatal("No results are set for the RepositoryMock.DeleteModelVersionByDigest")
		}
		return (*mm_results).err
	}
	if mmDeleteModelVersionByDigest.funcDeleteModelVersionByDigest != nil {
		return mmDeleteModelVersionByDigest.funcDeleteModelVersionByDigest(ctx, modelUID, digest)
	}
	mmDeleteModelVersionByDigest.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelVersionByDigest. %v %v %v", ctx, modelUID, digest)
	return
}

// DeleteModelVersionByDigestAfterCounter returns a count of finished RepositoryMock.DeleteModelVersionByDigest invocations
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.afterDeleteModelVersionByDigestCounter)
}

// DeleteModelVersionByDigestBeforeCounter returns a count of RepositoryMock.DeleteModelVersionByDigest invocations
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.beforeDeleteModelVersionByDigestCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelVersionByDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Calls() []*RepositoryMockDeleteModelVersionByDigestParams {
	mmDeleteModelVersionByDigest.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelVersionByDigestParams, len(mmDeleteModelVersionByDigest.callArgs))
	copy(argCopy, mmDeleteModelVersionByDigest.callArgs)

	mmDeleteModelVersionByDigest.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelVersionByDigestDone returns true if the count of the DeleteModelVersionByDigest invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelVersionByDigestDone() bool {
	if m.DeleteModelVersionByDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelVersionByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelVersionByDigestMock.invocationsDone()
}

// MinimockDeleteModelVersionByDigestInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelVersionByDigestInspect() {
	for _, e := range m.DeleteModelVersionByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest with params: %#v", *e.params)
		}
	}

	afterDeleteModelVersionByDigestCounter := mm_atomic.LoadUint64(&m.afterDeleteModelVersionByDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelVersionByDigestMock.defaultExpectation != nil && afterDeleteModelVersionByDigestCounter < 1 {
		if m.DeleteModelVersionByDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteModelVersionByDigest")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest with params: %#v", *m.DeleteModelVersionByDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelVersionByDigest != nil && afterDeleteModelVersionByDigestCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteModelVersionByDigest")
	}

	if !m.DeleteModelVersionByDigestMock.invocationsDone() && afterDeleteModelVersionByDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelVersionByDigest but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelVersionByDigestMock.expectedInvocations), afterDeleteModelVersionByDigestCounter)
	}
}

type mRepositoryMockDeleteModelVersionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelVersionByIDExpectation
	expectations       []*RepositoryMockDeleteModelVersionByIDExpectation

	callArgs []*RepositoryMockDeleteModelVersionByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteModelVersionByIDExpectation specifies expectation struct of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteModelVersionByIDParams
	paramPtrs *RepositoryMockDeleteModelVersionByIDParamPtrs
	results   *RepositoryMockDeleteModelVersionByIDResults
	Counter   uint64
}

// RepositoryMockDeleteModelVersionByIDParams contains parameters of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
}

// RepositoryMockDeleteModelVersionByIDParamPtrs contains pointers to parameters of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
}

// RepositoryMockDeleteModelVersionByIDResults contains results of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Optional() *mRepositoryMockDeleteModelVersionByID {
	mmDeleteModelVersionByID.optional = true
	return mmDeleteModelVersionByID
}

// Expect sets up expected params for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by ExpectParams functions")
	}

	mmDeleteModelVersionByID.defaultExpectation.params = &RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}
	for _, e := range mmDeleteModelVersionByID.expectations {
		if minimock.Equal(e.params, mmDeleteModelVersionByID.defaultExpectation.params) {
			mmDeleteModelVersionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelVersionByID.defaultExpectation.params)
		}
	}

	return mmDeleteModelVersionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteModelVersionByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmDeleteModelVersionByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.versionID = &versionID

	return mmDeleteModelVersionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string)) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.inspectFuncDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelVersionByID")
	}

	mmDeleteModelVersionByID.mock.inspectFuncDeleteModelVersionByID = f

	return mmDeleteModelVersionByID
}

// Return sets up results that will be returned by Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Return(err error) *RepositoryMock {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{mock: mmDeleteModelVersionByID.mock}
	}
	mmDeleteModelVersionByID.defaultExpectation.results = &RepositoryMockDeleteModelVersionByIDResults{err}
	return mmDeleteModelVersionByID.mock
}

// Set uses given function f to mock the Repository.DeleteModelVersionByID method
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string) (err error)) *RepositoryMock {
	if mmDeleteModelVersionByID.defaultExpectation != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelVersionByID method")
	}

	if len(mmDeleteModelVersionByID.expectations) > 0 {
		mmDeleteModelVersionByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelVersionByID method")
	}

	mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID = f
	return mmDeleteModelVersionByID.mock
}

// When sets expectation for the Repository.DeleteModelVersionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) When(ctx context.Context, modelUID uuid.UUID, versionID string) *RepositoryMockDeleteModelVersionByIDExpectation {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelVersionByIDExpectation{
		mock:   mmDeleteModelVersionByID.mock,
		params: &RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID},
	}
	mmDeleteModelVersionByID.expectations = append(mmDeleteModelVersionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelVersionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelVersionByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelVersionByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelVersionByID should be invoked
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Times(n uint64) *mRepositoryMockDeleteModelVersionByID {
	if n == 0 {
		mmDeleteModelVersionByID.mock.t.Fatalf("Times of RepositoryMock.DeleteModelVersionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelVersionByID.expectedInvocations, n)
	return mmDeleteModelVersionByID
}

func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) invocationsDone() bool {
	if len(mmDeleteModelVersionByID.expectations) == 0 && mmDeleteModelVersionByID.defaultExpectation == nil && mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByID.mock.afterDeleteModelVersionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelVersionByID implements repository.Repository
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByID(ctx context.Context, modelUID uuid.UUID, versionID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelVersionByID.beforeDeleteModelVersionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelVersionByID.afterDeleteModelVersionByIDCounter, 1)

	if mmDeleteModelVersionByID.inspectFuncDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.inspectFuncDeleteModelVersionByID(ctx, modelUID, versionID)
	}

	mm_params := RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}

	// Record call args
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.mutex.Lock()
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.callArgs = append(mmDeleteModelVersionByID.DeleteModelVersionByIDMock.callArgs, &mm_params)
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteModelVersionByID.DeleteModelVersionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter versionID, want: %#v, got: %#v%s\n", *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelVersionByID.t.Fatal("No results are set for the RepositoryMock.DeleteModelVersionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteModelVersionByID.funcDeleteModelVersionByID != nil {
		return mmDeleteModelVersionByID.funcDeleteModelVersionByID(ctx, modelUID, versionID)
	}
	mmDeleteModelVersionByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelVersionByID. %v %v %v", ctx, modelUID, versionID)
	return
}

// DeleteModelVersionByIDAfterCounter returns a count of finished RepositoryMock.DeleteModelVersionByID invocations
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByID.afterDeleteModelVersionByIDCounter)
}

// DeleteModelVersionByIDBeforeCounter returns a count of RepositoryMock.DeleteModelVersionByID invocations
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByID.beforeDeleteModelVersionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelVersionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Calls() []*RepositoryMockDeleteModelVersionByIDParams {
	mmDeleteModelVersionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelVersionByIDParams, len(mmDeleteModelVersionByID.callArgs))
	copy(argCopy, mmDeleteModelVersionByID.callArgs)

	mmDeleteModelVersionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelVersionByIDDone returns true if the count of the DeleteModelVersionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelVersionByIDDone() bool {
	if m.DeleteModelVersionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelVersionByIDMock.invocationsDone()
}

// MinimockDeleteModelVersionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelVersionByIDInspect() {
	for _, e := range m.DeleteModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID with params: %#v", *e.params)
		}
	}

	afterDeleteModelVersionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteModelVersionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelVersionByIDMock.defaultExpectation != nil && afterDeleteModelVersionByIDCounter < 1 {
		if m.DeleteModelVersionByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteModelVersionByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID with params: %#v", *m.DeleteModelVersionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelVersionByID != nil && afterDeleteModelVersionByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteModelVersionByID")
	}

	if !m.DeleteModelVersionByIDMock.invocationsDone() && afterDeleteModelVersionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelVersionByID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelVersionByIDMock.expectedInvocations), afterDeleteModelVersionByIDCounter)
	}
}

type mRepositoryMockDeleteNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceModelByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceModelByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteNamespaceModelByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteNamespaceModelByIDParams
	paramPtrs *RepositoryMockDeleteNamespaceModelByIDParamPtrs
	results   *RepositoryMockDeleteNamespaceModelByIDResults
	Counter   uint64
}

// RepositoryMockDeleteNamespaceModelByIDParams contains parameters of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespaceModelByIDResults contains results of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Optional() *mRepositoryMockDeleteNamespaceModelByID {
	mmDeleteNamespaceModelByID.optional = true
	return mmDeleteNamespaceModelByID
}

// Expect sets up expected params for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceModelByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}
	for _, e := range mmDeleteNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceModelByID.defaultExpectation.params) {
			mmDeleteNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmDeleteNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.id = &id

	return mmDeleteNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.inspectFuncDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceModelByID")
	}

	mmDeleteNamespaceModelByID.mock.inspectFuncDeleteNamespaceModelByID = f

	return mmDeleteNamespaceModelByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{mock: mmDeleteNamespaceModelByID.mock}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceModelByIDResults{err}
	return mmDeleteNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceModelByID method
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceModelByID.defaultExpectation != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceModelByID method")
	}

	if len(mmDeleteNamespaceModelByID.expectations) > 0 {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceModelByID method")
	}

	mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID = f
	return mmDeleteNamespaceModelByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespaceModelByIDExpectation {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceModelByIDExpectation{
		mock:   mmDeleteNamespaceModelByID.mock,
		params: &RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id},
	}
	mmDeleteNamespaceModelByID.expectations = append(mmDeleteNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceModelByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceModelByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceModelByID should be invoked
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Times(n uint64) *mRepositoryMockDeleteNamespaceModelByID {
	if n == 0 {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceModelByID.expectedInvocations, n)
	return mmDeleteNamespaceModelByID
}

func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) invocationsDone() bool {
	if len(mmDeleteNamespaceModelByID.expectations) == 0 && mmDeleteNamespaceModelByID.defaultExpectation == nil && mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.mock.afterDeleteNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceModelByID implements repository.Repository
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.beforeDeleteNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.afterDeleteNamespaceModelByIDCounter, 1)

	if mmDeleteNamespaceModelByID.inspectFuncDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.inspectFuncDeleteNamespaceModelByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.mutex.Lock()
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.callArgs = append(mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceModelByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceModelByID.funcDeleteNamespaceModelByID != nil {
		return mmDeleteNamespaceModelByID.funcDeleteNamespaceModelByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceModelByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceModelByID invocations
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.afterDeleteNamespaceModelByIDCounter)
}

// DeleteNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceModelByID invocations
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.beforeDeleteNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Calls() []*RepositoryMockDeleteNamespaceModelByIDParams {
	mmDeleteNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceModelByIDParams, len(mmDeleteNamespaceModelByID.callArgs))
	copy(argCopy, mmDeleteNamespaceModelByID.callArgs)

	mmDeleteNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceModelByIDDone returns true if the count of the DeleteNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceModelByIDDone() bool {
	if m.DeleteNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceModelByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceModelByIDInspect() {
	for _, e := range m.DeleteNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID with params: %#v", *e.params)
		}
	}

	afterDeleteNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceModelByIDMock.defaultExpectation != nil && afterDeleteNamespaceModelByIDCounter < 1 {
		if m.DeleteNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteNamespaceModelByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID with params: %#v", *m.DeleteNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceModelByID != nil && afterDeleteNamespaceModelByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteNamespaceModelByID")
	}

	if !m.DeleteNamespaceModelByIDMock.invocationsDone() && afterDeleteNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceModelByID but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceModelByIDMock.expectedInvocations), afterDeleteNamespaceModelByIDCounter)
	}
}

type mRepositoryMockGetLatestModelRunByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelRunByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelRunByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelRunByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetLatestModelRunByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetLatestModelRunByModelUIDParams
	paramPtrs *RepositoryMockGetLatestModelRunByModelUIDParamPtrs
	results   *RepositoryMockGetLatestModelRunByModelUIDResults
	Counter   uint64
}

// RepositoryMockGetLatestModelRunByModelUIDParams contains parameters of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDParams struct {
	ctx      context.Context
	userUID  string
	modelUID string
}

// RepositoryMockGetLatestModelRunByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDParamPtrs struct {
	ctx      *context.Context
	userUID  *string
	modelUID *string
}

// RepositoryMockGetLatestModelRunByModelUIDResults contains results of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Optional() *mRepositoryMockGetLatestModelRunByModelUID {
	mmGetLatestModelRunByModelUID.optional = true
	return mmGetLatestModelRunByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Expect(ctx context.Context, userUID string, modelUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelRunByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}
	for _, e := range mmGetLatestModelRunByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelRunByModelUID.defaultExpectation.params) {
			mmGetLatestModelRunByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelRunByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelRunByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetLatestModelRunByModelUID
}

// ExpectUserUIDParam2 sets up expected param userUID for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectUserUIDParam2(userUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.userUID = &userUID

	return mmGetLatestModelRunByModelUID
}

// ExpectModelUIDParam3 sets up expected param modelUID for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectModelUIDParam3(modelUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmGetLatestModelRunByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Inspect(f func(ctx context.Context, userUID string, modelUID string)) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.inspectFuncGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelRunByModelUID")
	}

	mmGetLatestModelRunByModelUID.mock.inspectFuncGetLatestModelRunByModelUID = f

	return mmGetLatestModelRunByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{mock: mmGetLatestModelRunByModelUID.mock}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelRunByModelUIDResults{modelRun, err}
	return mmGetLatestModelRunByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelRunByModelUID method
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Set(f func(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetLatestModelRunByModelUID.defaultExpectation != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelRunByModelUID method")
	}

	if len(mmGetLatestModelRunByModelUID.expectations) > 0 {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelRunByModelUID method")
	}

	mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID = f
	return mmGetLatestModelRunByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelRunByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) When(ctx context.Context, userUID string, modelUID string) *RepositoryMockGetLatestModelRunByModelUIDExpectation {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelRunByModelUIDExpectation{
		mock:   mmGetLatestModelRunByModelUID.mock,
		params: &RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID},
	}
	mmGetLatestModelRunByModelUID.expectations = append(mmGetLatestModelRunByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelRunByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelRunByModelUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelRunByModelUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelRunByModelUID should be invoked
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelRunByModelUID {
	if n == 0 {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelRunByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelRunByModelUID.expectedInvocations, n)
	return mmGetLatestModelRunByModelUID
}

func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelRunByModelUID.expectations) == 0 && mmGetLatestModelRunByModelUID.defaultExpectation == nil && mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.mock.afterGetLatestModelRunByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelRunByModelUID implements repository.Repository
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUID(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.beforeGetLatestModelRunByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.afterGetLatestModelRunByModelUIDCounter, 1)

	if mmGetLatestModelRunByModelUID.inspectFuncGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.inspectFuncGetLatestModelRunByModelUID(ctx, userUID, modelUID)
	}

	mm_params := RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}

	// Record call args
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.mutex.Lock()
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.callArgs = append(mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter userUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelRunByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelRunByModelUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetLatestModelRunByModelUID.funcGetLatestModelRunByModelUID != nil {
		return mmGetLatestModelRunByModelUID.funcGetLatestModelRunByModelUID(ctx, userUID, modelUID)
	}
	mmGetLatestModelRunByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelRunByModelUID. %v %v %v", ctx, userUID, modelUID)
	return
}

// GetLatestModelRunByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelRunByModelUID invocations
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.afterGetLatestModelRunByModelUIDCounter)
}

// GetLatestModelRunByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelRunByModelUID invocations
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.beforeGetLatestModelRunByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelRunByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Calls() []*RepositoryMockGetLatestModelRunByModelUIDParams {
	mmGetLatestModelRunByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelRunByModelUIDParams, len(mmGetLatestModelRunByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelRunByModelUID.callArgs)

	mmGetLatestModelRunByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelRunByModelUIDDone returns true if the count of the GetLatestModelRunByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelRunByModelUIDDone() bool {
	if m.GetLatestModelRunByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelRunByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelRunByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelRunByModelUIDInspect() {
	for _, e := range m.GetLatestModelRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID with params: %#v", *e.params)
		}
	}

	afterGetLatestModelRunByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelRunByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelRunByModelUIDMock.defaultExpectation != nil && afterGetLatestModelRunByModelUIDCounter < 1 {
		if m.GetLatestModelRunByModelUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetLatestModelRunByModelUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID with params: %#v", *m.GetLatestModelRunByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelRunByModelUID != nil && afterGetLatestModelRunByModelUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLatestModelRunByModelUID")
	}

	if !m.GetLatestModelRunByModelUIDMock.invocationsDone() && afterGetLatestModelRunByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelRunByModelUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelRunByModelUIDMock.expectedInvocations), afterGetLatestModelRunByModelUIDCounter)
	}
}

type mRepositoryMockGetLatestModelVersionByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelVersionByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelVersionByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelVersionByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetLatestModelVersionByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetLatestModelVersionByModelUIDParams
	paramPtrs *RepositoryMockGetLatestModelVersionByModelUIDParamPtrs
	results   *RepositoryMockGetLatestModelVersionByModelUIDResults
	Counter   uint64
}

// RepositoryMockGetLatestModelVersionByModelUIDParams contains parameters of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// RepositoryMockGetLatestModelVersionByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// RepositoryMockGetLatestModelVersionByModelUIDResults contains results of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDResults struct {
	version *datamodel.ModelVersion
	err     error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Optional() *mRepositoryMockGetLatestModelVersionByModelUID {
	mmGetLatestModelVersionByModelUID.optional = true
	return mmGetLatestModelVersionByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Expect(ctx context.Context, modelUID uuid.UUID) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelVersionByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}
	for _, e := range mmGetLatestModelVersionByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelVersionByModelUID.defaultExpectation.params) {
			mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelVersionByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelVersionByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetLatestModelVersionByModelUID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmGetLatestModelVersionByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.inspectFuncGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelVersionByModelUID")
	}

	mmGetLatestModelVersionByModelUID.mock.inspectFuncGetLatestModelVersionByModelUID = f

	return mmGetLatestModelVersionByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Return(version *datamodel.ModelVersion, err error) *RepositoryMock {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{mock: mmGetLatestModelVersionByModelUID.mock}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelVersionByModelUIDResults{version, err}
	return mmGetLatestModelVersionByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelVersionByModelUID method
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Set(f func(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmGetLatestModelVersionByModelUID.defaultExpectation != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelVersionByModelUID method")
	}

	if len(mmGetLatestModelVersionByModelUID.expectations) > 0 {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelVersionByModelUID method")
	}

	mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID = f
	return mmGetLatestModelVersionByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelVersionByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) When(ctx context.Context, modelUID uuid.UUID) *RepositoryMockGetLatestModelVersionByModelUIDExpectation {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelVersionByModelUIDExpectation{
		mock:   mmGetLatestModelVersionByModelUID.mock,
		params: &RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID},
	}
	mmGetLatestModelVersionByModelUID.expectations = append(mmGetLatestModelVersionByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelVersionByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelVersionByModelUIDExpectation) Then(version *datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelVersionByModelUIDResults{version, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelVersionByModelUID should be invoked
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelVersionByModelUID {
	if n == 0 {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelVersionByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelVersionByModelUID.expectedInvocations, n)
	return mmGetLatestModelVersionByModelUID
}

func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelVersionByModelUID.expectations) == 0 && mmGetLatestModelVersionByModelUID.defaultExpectation == nil && mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.mock.afterGetLatestModelVersionByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelVersionByModelUID implements repository.Repository
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUID(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.beforeGetLatestModelVersionByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.afterGetLatestModelVersionByModelUIDCounter, 1)

	if mmGetLatestModelVersionByModelUID.inspectFuncGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.inspectFuncGetLatestModelVersionByModelUID(ctx, modelUID)
	}

	mm_params := RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}

	// Record call args
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.mutex.Lock()
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.callArgs = append(mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.version, e.results.err
		}
	}

	if mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelVersionByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelVersionByModelUID")
		}
		return (*mm_results).version, (*mm_results).err
	}
	if mmGetLatestModelVersionByModelUID.funcGetLatestModelVersionByModelUID != nil {
		return mmGetLatestModelVersionByModelUID.funcGetLatestModelVersionByModelUID(ctx, modelUID)
	}
	mmGetLatestModelVersionByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelVersionByModelUID. %v %v", ctx, modelUID)
	return
}

// GetLatestModelVersionByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelVersionByModelUID invocations
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.afterGetLatestModelVersionByModelUIDCounter)
}

// GetLatestModelVersionByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelVersionByModelUID invocations
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.beforeGetLatestModelVersionByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelVersionByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Calls() []*RepositoryMockGetLatestModelVersionByModelUIDParams {
	mmGetLatestModelVersionByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelVersionByModelUIDParams, len(mmGetLatestModelVersionByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelVersionByModelUID.callArgs)

	mmGetLatestModelVersionByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelVersionByModelUIDDone returns true if the count of the GetLatestModelVersionByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelVersionByModelUIDDone() bool {
	if m.GetLatestModelVersionByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelVersionByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelVersionByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelVersionByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelVersionByModelUIDInspect() {
	for _, e := range m.GetLatestModelVersionByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID with params: %#v", *e.params)
		}
	}

	afterGetLatestModelVersionByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelVersionByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelVersionByModelUIDMock.defaultExpectation != nil && afterGetLatestModelVersionByModelUIDCounter < 1 {
		if m.GetLatestModelVersionByModelUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetLatestModelVersionByModelUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID with params: %#v", *m.GetLatestModelVersionByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelVersionByModelUID != nil && afterGetLatestModelVersionByModelUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLatestModelVersionByModelUID")
	}

	if !m.GetLatestModelVersionByModelUIDMock.invocationsDone() && afterGetLatestModelVersionByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelVersionByModelUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelVersionByModelUIDMock.expectedInvocations), afterGetLatestModelVersionByModelUIDCounter)
	}
}

type mRepositoryMockGetLatestModelVersionRunByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelVersionRunByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelVersionRunByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetLatestModelVersionRunByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetLatestModelVersionRunByModelUIDParams
	paramPtrs *RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs
	results   *RepositoryMockGetLatestModelVersionRunByModelUIDResults
	Counter   uint64
}

// RepositoryMockGetLatestModelVersionRunByModelUIDParams contains parameters of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDParams struct {
	ctx      context.Context
	userUID  string
	modelUID string
	version  string
}

// RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs struct {
	ctx      *context.Context
	userUID  *string
	modelUID *string
	version  *string
}

// RepositoryMockGetLatestModelVersionRunByModelUIDResults contains results of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Optional() *mRepositoryMockGetLatestModelVersionRunByModelUID {
	mmGetLatestModelVersionRunByModelUID.optional = true
	return mmGetLatestModelVersionRunByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Expect(ctx context.Context, userUID string, modelUID string, version string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelVersionRunByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}
	for _, e := range mmGetLatestModelVersionRunByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelVersionRunByModelUID.defaultExpectation.params) {
			mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelVersionRunByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectUserUIDParam2 sets up expected param userUID for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectUserUIDParam2(userUID string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.userUID = &userUID

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectModelUIDParam3 sets up expected param modelUID for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectModelUIDParam3(modelUID string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectVersionParam4 sets up expected param version for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectVersionParam4(version string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.version = &version

	return mmGetLatestModelVersionRunByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Inspect(f func(ctx context.Context, userUID string, modelUID string, version string)) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.inspectFuncGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelVersionRunByModelUID")
	}

	mmGetLatestModelVersionRunByModelUID.mock.inspectFuncGetLatestModelVersionRunByModelUID = f

	return mmGetLatestModelVersionRunByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{mock: mmGetLatestModelVersionRunByModelUID.mock}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelVersionRunByModelUIDResults{modelRun, err}
	return mmGetLatestModelVersionRunByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelVersionRunByModelUID method
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Set(f func(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetLatestModelVersionRunByModelUID.defaultExpectation != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelVersionRunByModelUID method")
	}

	if len(mmGetLatestModelVersionRunByModelUID.expectations) > 0 {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelVersionRunByModelUID method")
	}

	mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID = f
	return mmGetLatestModelVersionRunByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelVersionRunByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) When(ctx context.Context, userUID string, modelUID string, version string) *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{
		mock:   mmGetLatestModelVersionRunByModelUID.mock,
		params: &RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version},
	}
	mmGetLatestModelVersionRunByModelUID.expectations = append(mmGetLatestModelVersionRunByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelVersionRunByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelVersionRunByModelUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelVersionRunByModelUID should be invoked
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if n == 0 {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelVersionRunByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelVersionRunByModelUID.expectedInvocations, n)
	return mmGetLatestModelVersionRunByModelUID
}

func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelVersionRunByModelUID.expectations) == 0 && mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil && mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.mock.afterGetLatestModelVersionRunByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelVersionRunByModelUID implements repository.Repository
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUID(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.beforeGetLatestModelVersionRunByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.afterGetLatestModelVersionRunByModelUIDCounter, 1)

	if mmGetLatestModelVersionRunByModelUID.inspectFuncGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.inspectFuncGetLatestModelVersionRunByModelUID(ctx, userUID, modelUID, version)
	}

	mm_params := RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}

	// Record call args
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.mutex.Lock()
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.callArgs = append(mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter userUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter version, want: %#v, got: %#v%s\n", *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelVersionRunByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelVersionRunByModelUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetLatestModelVersionRunByModelUID.funcGetLatestModelVersionRunByModelUID != nil {
		return mmGetLatestModelVersionRunByModelUID.funcGetLatestModelVersionRunByModelUID(ctx, userUID, modelUID, version)
	}
	mmGetLatestModelVersionRunByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelVersionRunByModelUID. %v %v %v %v", ctx, userUID, modelUID, version)
	return
}

// GetLatestModelVersionRunByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelVersionRunByModelUID invocations
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.afterGetLatestModelVersionRunByModelUIDCounter)
}

// GetLatestModelVersionRunByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelVersionRunByModelUID invocations
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.beforeGetLatestModelVersionRunByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelVersionRunByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Calls() []*RepositoryMockGetLatestModelVersionRunByModelUIDParams {
	mmGetLatestModelVersionRunByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelVersionRunByModelUIDParams, len(mmGetLatestModelVersionRunByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelVersionRunByModelUID.callArgs)

	mmGetLatestModelVersionRunByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelVersionRunByModelUIDDone returns true if the count of the GetLatestModelVersionRunByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelVersionRunByModelUIDDone() bool {
	if m.GetLatestModelVersionRunByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelVersionRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelVersionRunByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelVersionRunByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelVersionRunByModelUIDInspect() {
	for _, e := range m.GetLatestModelVersionRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID with params: %#v", *e.params)
		}
	}

	afterGetLatestModelVersionRunByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelVersionRunByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation != nil && afterGetLatestModelVersionRunByModelUIDCounter < 1 {
		if m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID with params: %#v", *m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelVersionRunByModelUID != nil && afterGetLatestModelVersionRunByModelUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID")
	}

	if !m.GetLatestModelVersionRunByModelUIDMock.invocationsDone() && afterGetLatestModelVersionRunByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelVersionRunByModelUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelVersionRunByModelUIDMock.expectedInvocations), afterGetLatestModelVersionRunByModelUIDCounter)
	}
}

type mRepositoryMockGetModelByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelByUIDExpectation
	expectations       []*RepositoryMockGetModelByUIDExpectation

	callArgs []*RepositoryMockGetModelByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelByUIDExpectation specifies expectation struct of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelByUIDParams
	paramPtrs *RepositoryMockGetModelByUIDParamPtrs
	results   *RepositoryMockGetModelByUIDResults
	Counter   uint64
}

// RepositoryMockGetModelByUIDParams contains parameters of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	includeAvatar bool
}

// RepositoryMockGetModelByUIDParamPtrs contains pointers to parameters of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	includeAvatar *bool
}

// RepositoryMockGetModelByUIDResults contains results of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDResults struct {
	mp1 *datamodel.Model
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Optional() *mRepositoryMockGetModelByUID {
	mmGetModelByUID.optional = true
	return mmGetModelByUID
}

// Expect sets up expected params for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by ExpectParams functions")
	}

	mmGetModelByUID.defaultExpectation.params = &RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}
	for _, e := range mmGetModelByUID.expectations {
		if minimock.Equal(e.params, mmGetModelByUID.defaultExpectation.params) {
			mmGetModelByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelByUID.defaultExpectation.params)
		}
	}

	return mmGetModelByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetModelByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmGetModelByUID
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetModelByUID
}

// ExpectIncludeAvatarParam4 sets up expected param includeAvatar for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectIncludeAvatarParam4(includeAvatar bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar

	return mmGetModelByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.inspectFuncGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelByUID")
	}

	mmGetModelByUID.mock.inspectFuncGetModelByUID = f

	return mmGetModelByUID
}

// Return sets up results that will be returned by Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{mock: mmGetModelByUID.mock}
	}
	mmGetModelByUID.defaultExpectation.results = &RepositoryMockGetModelByUIDResults{mp1, err}
	return mmGetModelByUID.mock
}

// Set uses given function f to mock the Repository.GetModelByUID method
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetModelByUID.defaultExpectation != nil {
		mmGetModelByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelByUID method")
	}

	if len(mmGetModelByUID.expectations) > 0 {
		mmGetModelByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelByUID method")
	}

	mmGetModelByUID.mock.funcGetModelByUID = f
	return mmGetModelByUID.mock
}

// When sets expectation for the Repository.GetModelByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelByUID *mRepositoryMockGetModelByUID) When(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *RepositoryMockGetModelByUIDExpectation {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelByUIDExpectation{
		mock:   mmGetModelByUID.mock,
		params: &RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar},
	}
	mmGetModelByUID.expectations = append(mmGetModelByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelByUIDExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelByUIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelByUID should be invoked
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Times(n uint64) *mRepositoryMockGetModelByUID {
	if n == 0 {
		mmGetModelByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelByUID.expectedInvocations, n)
	return mmGetModelByUID
}

func (mmGetModelByUID *mRepositoryMockGetModelByUID) invocationsDone() bool {
	if len(mmGetModelByUID.expectations) == 0 && mmGetModelByUID.defaultExpectation == nil && mmGetModelByUID.mock.funcGetModelByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelByUID.mock.afterGetModelByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelByUID implements repository.Repository
func (mmGetModelByUID *RepositoryMock) GetModelByUID(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetModelByUID.beforeGetModelByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelByUID.afterGetModelByUIDCounter, 1)

	if mmGetModelByUID.inspectFuncGetModelByUID != nil {
		mmGetModelByUID.inspectFuncGetModelByUID(ctx, uid, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}

	// Record call args
	mmGetModelByUID.GetModelByUIDMock.mutex.Lock()
	mmGetModelByUID.GetModelByUIDMock.callArgs = append(mmGetModelByUID.GetModelByUIDMock.callArgs, &mm_params)
	mmGetModelByUID.GetModelByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelByUID.GetModelByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelByUID.GetModelByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelByUID.GetModelByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter includeAvatar, want: %#v, got: %#v%s\n", *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelByUID.t.Fatal("No results are set for the RepositoryMock.GetModelByUID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelByUID.funcGetModelByUID != nil {
		return mmGetModelByUID.funcGetModelByUID(ctx, uid, isBasicView, includeAvatar)
	}
	mmGetModelByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelByUID. %v %v %v %v", ctx, uid, isBasicView, includeAvatar)
	return
}

// GetModelByUIDAfterCounter returns a count of finished RepositoryMock.GetModelByUID invocations
func (mmGetModelByUID *RepositoryMock) GetModelByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUID.afterGetModelByUIDCounter)
}

// GetModelByUIDBeforeCounter returns a count of RepositoryMock.GetModelByUID invocations
func (mmGetModelByUID *RepositoryMock) GetModelByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUID.beforeGetModelByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Calls() []*RepositoryMockGetModelByUIDParams {
	mmGetModelByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelByUIDParams, len(mmGetModelByUID.callArgs))
	copy(argCopy, mmGetModelByUID.callArgs)

	mmGetModelByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelByUIDDone returns true if the count of the GetModelByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelByUIDDone() bool {
	if m.GetModelByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelByUIDMock.invocationsDone()
}

// MinimockGetModelByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelByUIDInspect() {
	for _, e := range m.GetModelByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUID with params: %#v", *e.params)
		}
	}

	afterGetModelByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelByUIDMock.defaultExpectation != nil && afterGetModelByUIDCounter < 1 {
		if m.GetModelByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUID with params: %#v", *m.GetModelByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelByUID != nil && afterGetModelByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelByUID")
	}

	if !m.GetModelByUIDMock.invocationsDone() && afterGetModelByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelByUIDMock.expectedInvocations), afterGetModelByUIDCounter)
	}
}

type mRepositoryMockGetModelByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelByUIDAdminExpectation
	expectations       []*RepositoryMockGetModelByUIDAdminExpectation

	callArgs []*RepositoryMockGetModelByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelByUIDAdminExpectation specifies expectation struct of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelByUIDAdminParams
	paramPtrs *RepositoryMockGetModelByUIDAdminParamPtrs
	results   *RepositoryMockGetModelByUIDAdminResults
	Counter   uint64
}

// RepositoryMockGetModelByUIDAdminParams contains parameters of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	includeAvatar bool
}

// RepositoryMockGetModelByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	includeAvatar *bool
}

// RepositoryMockGetModelByUIDAdminResults contains results of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminResults struct {
	mp1 *datamodel.Model
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Optional() *mRepositoryMockGetModelByUIDAdmin {
	mmGetModelByUIDAdmin.optional = true
	return mmGetModelByUIDAdmin
}

// Expect sets up expected params for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetModelByUIDAdmin.defaultExpectation.params = &RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}
	for _, e := range mmGetModelByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetModelByUIDAdmin.defaultExpectation.params) {
			mmGetModelByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetModelByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetModelByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid

	return mmGetModelByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetModelByUIDAdmin
}

// ExpectIncludeAvatarParam4 sets up expected param includeAvatar for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectIncludeAvatarParam4(includeAvatar bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar

	return mmGetModelByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.inspectFuncGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelByUIDAdmin")
	}

	mmGetModelByUIDAdmin.mock.inspectFuncGetModelByUIDAdmin = f

	return mmGetModelByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{mock: mmGetModelByUIDAdmin.mock}
	}
	mmGetModelByUIDAdmin.defaultExpectation.results = &RepositoryMockGetModelByUIDAdminResults{mp1, err}
	return mmGetModelByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetModelByUIDAdmin method
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetModelByUIDAdmin.defaultExpectation != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelByUIDAdmin method")
	}

	if len(mmGetModelByUIDAdmin.expectations) > 0 {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelByUIDAdmin method")
	}

	mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin = f
	return mmGetModelByUIDAdmin.mock
}

// When sets expectation for the Repository.GetModelByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *RepositoryMockGetModelByUIDAdminExpectation {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelByUIDAdminExpectation{
		mock:   mmGetModelByUIDAdmin.mock,
		params: &RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar},
	}
	mmGetModelByUIDAdmin.expectations = append(mmGetModelByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelByUIDAdminExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelByUIDAdminResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelByUIDAdmin should be invoked
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Times(n uint64) *mRepositoryMockGetModelByUIDAdmin {
	if n == 0 {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetModelByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelByUIDAdmin.expectedInvocations, n)
	return mmGetModelByUIDAdmin
}

func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) invocationsDone() bool {
	if len(mmGetModelByUIDAdmin.expectations) == 0 && mmGetModelByUIDAdmin.defaultExpectation == nil && mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.mock.afterGetModelByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelByUIDAdmin implements repository.Repository
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetModelByUIDAdmin.beforeGetModelByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelByUIDAdmin.afterGetModelByUIDAdminCounter, 1)

	if mmGetModelByUIDAdmin.inspectFuncGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.inspectFuncGetModelByUIDAdmin(ctx, uid, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}

	// Record call args
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.mutex.Lock()
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.callArgs = append(mmGetModelByUIDAdmin.GetModelByUIDAdminMock.callArgs, &mm_params)
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetModelByUIDAdmin.GetModelByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter includeAvatar, want: %#v, got: %#v%s\n", *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetModelByUIDAdmin")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelByUIDAdmin.funcGetModelByUIDAdmin != nil {
		return mmGetModelByUIDAdmin.funcGetModelByUIDAdmin(ctx, uid, isBasicView, includeAvatar)
	}
	mmGetModelByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetModelByUIDAdmin. %v %v %v %v", ctx, uid, isBasicView, includeAvatar)
	return
}

// GetModelByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetModelByUIDAdmin invocations
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.afterGetModelByUIDAdminCounter)
}

// GetModelByUIDAdminBeforeCounter returns a count of RepositoryMock.GetModelByUIDAdmin invocations
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.beforeGetModelByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Calls() []*RepositoryMockGetModelByUIDAdminParams {
	mmGetModelByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelByUIDAdminParams, len(mmGetModelByUIDAdmin.callArgs))
	copy(argCopy, mmGetModelByUIDAdmin.callArgs)

	mmGetModelByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelByUIDAdminDone returns true if the count of the GetModelByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelByUIDAdminDone() bool {
	if m.GetModelByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelByUIDAdminMock.invocationsDone()
}

// MinimockGetModelByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelByUIDAdminInspect() {
	for _, e := range m.GetModelByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin with params: %#v", *e.params)
		}
	}

	afterGetModelByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetModelByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelByUIDAdminMock.defaultExpectation != nil && afterGetModelByUIDAdminCounter < 1 {
		if m.GetModelByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelByUIDAdmin")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin with params: %#v", *m.GetModelByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelByUIDAdmin != nil && afterGetModelByUIDAdminCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelByUIDAdmin")
	}

	if !m.GetModelByUIDAdminMock.invocationsDone() && afterGetModelByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelByUIDAdmin but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelByUIDAdminMock.expectedInvocations), afterGetModelByUIDAdminCounter)
	}
}

type mRepositoryMockGetModelDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelDefinitionExpectation
	expectations       []*RepositoryMockGetModelDefinitionExpectation

	callArgs []*RepositoryMockGetModelDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelDefinitionExpectation specifies expectation struct of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelDefinitionParams
	paramPtrs *RepositoryMockGetModelDefinitionParamPtrs
	results   *RepositoryMockGetModelDefinitionResults
	Counter   uint64
}

// RepositoryMockGetModelDefinitionParams contains parameters of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionParams struct {
	id string
}

// RepositoryMockGetModelDefinitionParamPtrs contains pointers to parameters of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionParamPtrs struct {
	id *string
}

// RepositoryMockGetModelDefinitionResults contains results of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionResults struct {
	mp1 *datamodel.ModelDefinition
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Optional() *mRepositoryMockGetModelDefinition {
	mmGetModelDefinition.optional = true
	return mmGetModelDefinition
}

// Expect sets up expected params for Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Expect(id string) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by ExpectParams functions")
	}

	mmGetModelDefinition.defaultExpectation.params = &RepositoryMockGetModelDefinitionParams{id}
	for _, e := range mmGetModelDefinition.expectations {
		if minimock.Equal(e.params, mmGetModelDefinition.defaultExpectation.params) {
			mmGetModelDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelDefinition.defaultExpectation.params)
		}
	}

	return mmGetModelDefinition
}

// ExpectIdParam1 sets up expected param id for Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) ExpectIdParam1(id string) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.params != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Expect")
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinition.defaultExpectation.paramPtrs = &RepositoryMockGetModelDefinitionParamPtrs{}
	}
	mmGetModelDefinition.defaultExpectation.paramPtrs.id = &id

	return mmGetModelDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Inspect(f func(id string)) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelDefinition")
	}

	mmGetModelDefinition.mock.inspectFuncGetModelDefinition = f

	return mmGetModelDefinition
}

// Return sets up results that will be returned by Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Return(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{mock: mmGetModelDefinition.mock}
	}
	mmGetModelDefinition.defaultExpectation.results = &RepositoryMockGetModelDefinitionResults{mp1, err}
	return mmGetModelDefinition.mock
}

// Set uses given function f to mock the Repository.GetModelDefinition method
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Set(f func(id string) (mp1 *datamodel.ModelDefinition, err error)) *RepositoryMock {
	if mmGetModelDefinition.defaultExpectation != nil {
		mmGetModelDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelDefinition method")
	}

	if len(mmGetModelDefinition.expectations) > 0 {
		mmGetModelDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelDefinition method")
	}

	mmGetModelDefinition.mock.funcGetModelDefinition = f
	return mmGetModelDefinition.mock
}

// When sets expectation for the Repository.GetModelDefinition which will trigger the result defined by the following
// Then helper
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) When(id string) *RepositoryMockGetModelDefinitionExpectation {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelDefinitionExpectation{
		mock:   mmGetModelDefinition.mock,
		params: &RepositoryMockGetModelDefinitionParams{id},
	}
	mmGetModelDefinition.expectations = append(mmGetModelDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelDefinitionExpectation) Then(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelDefinitionResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelDefinition should be invoked
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Times(n uint64) *mRepositoryMockGetModelDefinition {
	if n == 0 {
		mmGetModelDefinition.mock.t.Fatalf("Times of RepositoryMock.GetModelDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelDefinition.expectedInvocations, n)
	return mmGetModelDefinition
}

func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) invocationsDone() bool {
	if len(mmGetModelDefinition.expectations) == 0 && mmGetModelDefinition.defaultExpectation == nil && mmGetModelDefinition.mock.funcGetModelDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.mock.afterGetModelDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelDefinition implements repository.Repository
func (mmGetModelDefinition *RepositoryMock) GetModelDefinition(id string) (mp1 *datamodel.ModelDefinition, err error) {
	mm_atomic.AddUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter, 1)

	if mmGetModelDefinition.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.inspectFuncGetModelDefinition(id)
	}

	mm_params := RepositoryMockGetModelDefinitionParams{id}

	// Record call args
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Lock()
	mmGetModelDefinition.GetModelDefinitionMock.callArgs = append(mmGetModelDefinition.GetModelDefinitionMock.callArgs, &mm_params)
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Unlock()

	for _, e := range mmGetModelDefinition.GetModelDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelDefinitionParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetModelDefinition.t.Errorf("RepositoryMock.GetModelDefinition got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelDefinition.t.Errorf("RepositoryMock.GetModelDefinition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelDefinition.t.Fatal("No results are set for the RepositoryMock.GetModelDefinition")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelDefinition.funcGetModelDefinition != nil {
		return mmGetModelDefinition.funcGetModelDefinition(id)
	}
	mmGetModelDefinition.t.Fatalf("Unexpected call to RepositoryMock.GetModelDefinition. %v", id)
	return
}

// GetModelDefinitionAfterCounter returns a count of finished RepositoryMock.GetModelDefinition invocations
func (mmGetModelDefinition *RepositoryMock) GetModelDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter)
}

// GetModelDefinitionBeforeCounter returns a count of RepositoryMock.GetModelDefinition invocations
func (mmGetModelDefinition *RepositoryMock) GetModelDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Calls() []*RepositoryMockGetModelDefinitionParams {
	mmGetModelDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelDefinitionParams, len(mmGetModelDefinition.callArgs))
	copy(argCopy, mmGetModelDefinition.callArgs)

	mmGetModelDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelDefinitionDone returns true if the count of the GetModelDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelDefinitionDone() bool {
	if m.GetModelDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelDefinitionMock.invocationsDone()
}

// MinimockGetModelDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelDefinitionInspect() {
	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition with params: %#v", *e.params)
		}
	}

	afterGetModelDefinitionCounter := mm_atomic.LoadUint64(&m.afterGetModelDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelDefinitionMock.defaultExpectation != nil && afterGetModelDefinitionCounter < 1 {
		if m.GetModelDefinitionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelDefinition")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition with params: %#v", *m.GetModelDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelDefinition != nil && afterGetModelDefinitionCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelDefinition")
	}

	if !m.GetModelDefinitionMock.invocationsDone() && afterGetModelDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelDefinition but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelDefinitionMock.expectedInvocations), afterGetModelDefinitionCounter)
	}
}

type mRepositoryMockGetModelDefinitionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelDefinitionByUIDExpectation
	expectations       []*RepositoryMockGetModelDefinitionByUIDExpectation

	callArgs []*RepositoryMockGetModelDefinitionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelDefinitionByUIDExpectation specifies expectation struct of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelDefinitionByUIDParams
	paramPtrs *RepositoryMockGetModelDefinitionByUIDParamPtrs
	results   *RepositoryMockGetModelDefinitionByUIDResults
	Counter   uint64
}

// RepositoryMockGetModelDefinitionByUIDParams contains parameters of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDParams struct {
	uid uuid.UUID
}

// RepositoryMockGetModelDefinitionByUIDParamPtrs contains pointers to parameters of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDParamPtrs struct {
	uid *uuid.UUID
}

// RepositoryMockGetModelDefinitionByUIDResults contains results of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDResults struct {
	mp1 *datamodel.ModelDefinition
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Optional() *mRepositoryMockGetModelDefinitionByUID {
	mmGetModelDefinitionByUID.optional = true
	return mmGetModelDefinitionByUID
}

// Expect sets up expected params for Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Expect(uid uuid.UUID) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{}
	}

	if mmGetModelDefinitionByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by ExpectParams functions")
	}

	mmGetModelDefinitionByUID.defaultExpectation.params = &RepositoryMockGetModelDefinitionByUIDParams{uid}
	for _, e := range mmGetModelDefinitionByUID.expectations {
		if minimock.Equal(e.params, mmGetModelDefinitionByUID.defaultExpectation.params) {
			mmGetModelDefinitionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelDefinitionByUID.defaultExpectation.params)
		}
	}

	return mmGetModelDefinitionByUID
}

// ExpectUidParam1 sets up expected param uid for Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) ExpectUidParam1(uid uuid.UUID) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{}
	}

	if mmGetModelDefinitionByUID.defaultExpectation.params != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Expect")
	}

	if mmGetModelDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelDefinitionByUIDParamPtrs{}
	}
	mmGetModelDefinitionByUID.defaultExpectation.paramPtrs.uid = &uid

	return mmGetModelDefinitionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Inspect(f func(uid uuid.UUID)) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.inspectFuncGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelDefinitionByUID")
	}

	mmGetModelDefinitionByUID.mock.inspectFuncGetModelDefinitionByUID = f

	return mmGetModelDefinitionByUID
}

// Return sets up results that will be returned by Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Return(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{mock: mmGetModelDefinitionByUID.mock}
	}
	mmGetModelDefinitionByUID.defaultExpectation.results = &RepositoryMockGetModelDefinitionByUIDResults{mp1, err}
	return mmGetModelDefinitionByUID.mock
}

// Set uses given function f to mock the Repository.GetModelDefinitionByUID method
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Set(f func(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error)) *RepositoryMock {
	if mmGetModelDefinitionByUID.defaultExpectation != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelDefinitionByUID method")
	}

	if len(mmGetModelDefinitionByUID.expectations) > 0 {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelDefinitionByUID method")
	}

	mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID = f
	return mmGetModelDefinitionByUID.mock
}

// When sets expectation for the Repository.GetModelDefinitionByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) When(uid uuid.UUID) *RepositoryMockGetModelDefinitionByUIDExpectation {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelDefinitionByUIDExpectation{
		mock:   mmGetModelDefinitionByUID.mock,
		params: &RepositoryMockGetModelDefinitionByUIDParams{uid},
	}
	mmGetModelDefinitionByUID.expectations = append(mmGetModelDefinitionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelDefinitionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelDefinitionByUIDExpectation) Then(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelDefinitionByUIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelDefinitionByUID should be invoked
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Times(n uint64) *mRepositoryMockGetModelDefinitionByUID {
	if n == 0 {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelDefinitionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelDefinitionByUID.expectedInvocations, n)
	return mmGetModelDefinitionByUID
}

func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) invocationsDone() bool {
	if len(mmGetModelDefinitionByUID.expectations) == 0 && mmGetModelDefinitionByUID.defaultExpectation == nil && mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.mock.afterGetModelDefinitionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelDefinitionByUID implements repository.Repository
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUID(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error) {
	mm_atomic.AddUint64(&mmGetModelDefinitionByUID.beforeGetModelDefinitionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelDefinitionByUID.afterGetModelDefinitionByUIDCounter, 1)

	if mmGetModelDefinitionByUID.inspectFuncGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.inspectFuncGetModelDefinitionByUID(uid)
	}

	mm_params := RepositoryMockGetModelDefinitionByUIDParams{uid}

	// Record call args
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.mutex.Lock()
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.callArgs = append(mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.callArgs, &mm_params)
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelDefinitionByUIDParams{uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelDefinitionByUID.t.Errorf("RepositoryMock.GetModelDefinitionByUID got unexpected parameter uid, want: %#v, got: %#v%s\n", *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelDefinitionByUID.t.Errorf("RepositoryMock.GetModelDefinitionByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelDefinitionByUID.t.Fatal("No results are set for the RepositoryMock.GetModelDefinitionByUID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelDefinitionByUID.funcGetModelDefinitionByUID != nil {
		return mmGetModelDefinitionByUID.funcGetModelDefinitionByUID(uid)
	}
	mmGetModelDefinitionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelDefinitionByUID. %v", uid)
	return
}

// GetModelDefinitionByUIDAfterCounter returns a count of finished RepositoryMock.GetModelDefinitionByUID invocations
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.afterGetModelDefinitionByUIDCounter)
}

// GetModelDefinitionByUIDBeforeCounter returns a count of RepositoryMock.GetModelDefinitionByUID invocations
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.beforeGetModelDefinitionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelDefinitionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Calls() []*RepositoryMockGetModelDefinitionByUIDParams {
	mmGetModelDefinitionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelDefinitionByUIDParams, len(mmGetModelDefinitionByUID.callArgs))
	copy(argCopy, mmGetModelDefinitionByUID.callArgs)

	mmGetModelDefinitionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelDefinitionByUIDDone returns true if the count of the GetModelDefinitionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelDefinitionByUIDDone() bool {
	if m.GetModelDefinitionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelDefinitionByUIDMock.invocationsDone()
}

// MinimockGetModelDefinitionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelDefinitionByUIDInspect() {
	for _, e := range m.GetModelDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID with params: %#v", *e.params)
		}
	}

	afterGetModelDefinitionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelDefinitionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelDefinitionByUIDMock.defaultExpectation != nil && afterGetModelDefinitionByUIDCounter < 1 {
		if m.GetModelDefinitionByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelDefinitionByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID with params: %#v", *m.GetModelDefinitionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelDefinitionByUID != nil && afterGetModelDefinitionByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelDefinitionByUID")
	}

	if !m.GetModelDefinitionByUIDMock.invocationsDone() && afterGetModelDefinitionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelDefinitionByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelDefinitionByUIDMock.expectedInvocations), afterGetModelDefinitionByUIDCounter)
	}
}

type mRepositoryMockGetModelRunByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelRunByUIDExpectation
	expectations       []*RepositoryMockGetModelRunByUIDExpectation

	callArgs []*RepositoryMockGetModelRunByUIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelRunByUIDExpectation specifies expectation struct of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelRunByUIDParams
	paramPtrs *RepositoryMockGetModelRunByUIDParamPtrs
	results   *RepositoryMockGetModelRunByUIDResults
	Counter   uint64
}

// RepositoryMockGetModelRunByUIDParams contains parameters of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDParams struct {
	ctx        context.Context
	triggerUID string
}

// RepositoryMockGetModelRunByUIDParamPtrs contains pointers to parameters of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDParamPtrs struct {
	ctx        *context.Context
	triggerUID *string
}

// RepositoryMockGetModelRunByUIDResults contains results of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Optional() *mRepositoryMockGetModelRunByUID {
	mmGetModelRunByUID.optional = true
	return mmGetModelRunByUID
}

// Expect sets up expected params for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Expect(ctx context.Context, triggerUID string) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by ExpectParams functions")
	}

	mmGetModelRunByUID.defaultExpectation.params = &RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}
	for _, e := range mmGetModelRunByUID.expectations {
		if minimock.Equal(e.params, mmGetModelRunByUID.defaultExpectation.params) {
			mmGetModelRunByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelRunByUID.defaultExpectation.params)
		}
	}

	return mmGetModelRunByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.params != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Expect")
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelRunByUIDParamPtrs{}
	}
	mmGetModelRunByUID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetModelRunByUID
}

// ExpectTriggerUIDParam2 sets up expected param triggerUID for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) ExpectTriggerUIDParam2(triggerUID string) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.params != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Expect")
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelRunByUIDParamPtrs{}
	}
	mmGetModelRunByUID.defaultExpectation.paramPtrs.triggerUID = &triggerUID

	return mmGetModelRunByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Inspect(f func(ctx context.Context, triggerUID string)) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.inspectFuncGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelRunByUID")
	}

	mmGetModelRunByUID.mock.inspectFuncGetModelRunByUID = f

	return mmGetModelRunByUID
}

// Return sets up results that will be returned by Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{mock: mmGetModelRunByUID.mock}
	}
	mmGetModelRunByUID.defaultExpectation.results = &RepositoryMockGetModelRunByUIDResults{modelRun, err}
	return mmGetModelRunByUID.mock
}

// Set uses given function f to mock the Repository.GetModelRunByUID method
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Set(f func(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetModelRunByUID.defaultExpectation != nil {
		mmGetModelRunByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelRunByUID method")
	}

	if len(mmGetModelRunByUID.expectations) > 0 {
		mmGetModelRunByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelRunByUID method")
	}

	mmGetModelRunByUID.mock.funcGetModelRunByUID = f
	return mmGetModelRunByUID.mock
}

// When sets expectation for the Repository.GetModelRunByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) When(ctx context.Context, triggerUID string) *RepositoryMockGetModelRunByUIDExpectation {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelRunByUIDExpectation{
		mock:   mmGetModelRunByUID.mock,
		params: &RepositoryMockGetModelRunByUIDParams{ctx, triggerUID},
	}
	mmGetModelRunByUID.expectations = append(mmGetModelRunByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelRunByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelRunByUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelRunByUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetModelRunByUID should be invoked
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Times(n uint64) *mRepositoryMockGetModelRunByUID {
	if n == 0 {
		mmGetModelRunByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelRunByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelRunByUID.expectedInvocations, n)
	return mmGetModelRunByUID
}

func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) invocationsDone() bool {
	if len(mmGetModelRunByUID.expectations) == 0 && mmGetModelRunByUID.defaultExpectation == nil && mmGetModelRunByUID.mock.funcGetModelRunByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelRunByUID.mock.afterGetModelRunByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelRunByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelRunByUID implements repository.Repository
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUID(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetModelRunByUID.beforeGetModelRunByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelRunByUID.afterGetModelRunByUIDCounter, 1)

	if mmGetModelRunByUID.inspectFuncGetModelRunByUID != nil {
		mmGetModelRunByUID.inspectFuncGetModelRunByUID(ctx, triggerUID)
	}

	mm_params := RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}

	// Record call args
	mmGetModelRunByUID.GetModelRunByUIDMock.mutex.Lock()
	mmGetModelRunByUID.GetModelRunByUIDMock.callArgs = append(mmGetModelRunByUID.GetModelRunByUIDMock.callArgs, &mm_params)
	mmGetModelRunByUID.GetModelRunByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelRunByUID.GetModelRunByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.triggerUID != nil && !minimock.Equal(*mm_want_ptrs.triggerUID, mm_got.triggerUID) {
				mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameter triggerUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.triggerUID, mm_got.triggerUID, minimock.Diff(*mm_want_ptrs.triggerUID, mm_got.triggerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelRunByUID.t.Fatal("No results are set for the RepositoryMock.GetModelRunByUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetModelRunByUID.funcGetModelRunByUID != nil {
		return mmGetModelRunByUID.funcGetModelRunByUID(ctx, triggerUID)
	}
	mmGetModelRunByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelRunByUID. %v %v", ctx, triggerUID)
	return
}

// GetModelRunByUIDAfterCounter returns a count of finished RepositoryMock.GetModelRunByUID invocations
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelRunByUID.afterGetModelRunByUIDCounter)
}

// GetModelRunByUIDBeforeCounter returns a count of RepositoryMock.GetModelRunByUID invocations
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelRunByUID.beforeGetModelRunByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelRunByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Calls() []*RepositoryMockGetModelRunByUIDParams {
	mmGetModelRunByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelRunByUIDParams, len(mmGetModelRunByUID.callArgs))
	copy(argCopy, mmGetModelRunByUID.callArgs)

	mmGetModelRunByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelRunByUIDDone returns true if the count of the GetModelRunByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelRunByUIDDone() bool {
	if m.GetModelRunByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelRunByUIDMock.invocationsDone()
}

// MinimockGetModelRunByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelRunByUIDInspect() {
	for _, e := range m.GetModelRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID with params: %#v", *e.params)
		}
	}

	afterGetModelRunByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelRunByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelRunByUIDMock.defaultExpectation != nil && afterGetModelRunByUIDCounter < 1 {
		if m.GetModelRunByUIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelRunByUID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID with params: %#v", *m.GetModelRunByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelRunByUID != nil && afterGetModelRunByUIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelRunByUID")
	}

	if !m.GetModelRunByUIDMock.invocationsDone() && afterGetModelRunByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelRunByUID but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelRunByUIDMock.expectedInvocations), afterGetModelRunByUIDCounter)
	}
}

type mRepositoryMockGetModelVersionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelVersionByIDExpectation
	expectations       []*RepositoryMockGetModelVersionByIDExpectation

	callArgs []*RepositoryMockGetModelVersionByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetModelVersionByIDExpectation specifies expectation struct of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetModelVersionByIDParams
	paramPtrs *RepositoryMockGetModelVersionByIDParamPtrs
	results   *RepositoryMockGetModelVersionByIDResults
	Counter   uint64
}

// RepositoryMockGetModelVersionByIDParams contains parameters of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
}

// RepositoryMockGetModelVersionByIDParamPtrs contains pointers to parameters of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
}

// RepositoryMockGetModelVersionByIDResults contains results of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDResults struct {
	version *datamodel.ModelVersion
	err     error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Optional() *mRepositoryMockGetModelVersionByID {
	mmGetModelVersionByID.optional = true
	return mmGetModelVersionByID
}

// Expect sets up expected params for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by ExpectParams functions")
	}

	mmGetModelVersionByID.defaultExpectation.params = &RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}
	for _, e := range mmGetModelVersionByID.expectations {
		if minimock.Equal(e.params, mmGetModelVersionByID.defaultExpectation.params) {
			mmGetModelVersionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelVersionByID.defaultExpectation.params)
		}
	}

	return mmGetModelVersionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetModelVersionByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmGetModelVersionByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.versionID = &versionID

	return mmGetModelVersionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string)) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.inspectFuncGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelVersionByID")
	}

	mmGetModelVersionByID.mock.inspectFuncGetModelVersionByID = f

	return mmGetModelVersionByID
}

// Return sets up results that will be returned by Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Return(version *datamodel.ModelVersion, err error) *RepositoryMock {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{mock: mmGetModelVersionByID.mock}
	}
	mmGetModelVersionByID.defaultExpectation.results = &RepositoryMockGetModelVersionByIDResults{version, err}
	return mmGetModelVersionByID.mock
}

// Set uses given function f to mock the Repository.GetModelVersionByID method
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmGetModelVersionByID.defaultExpectation != nil {
		mmGetModelVersionByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelVersionByID method")
	}

	if len(mmGetModelVersionByID.expectations) > 0 {
		mmGetModelVersionByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelVersionByID method")
	}

	mmGetModelVersionByID.mock.funcGetModelVersionByID = f
	return mmGetModelVersionByID.mock
}

// When sets expectation for the Repository.GetModelVersionByID which will trigger the result defined by the following
// Then helper
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) When(ctx context.Context, modelUID uuid.UUID, versionID string) *RepositoryMockGetModelVersionByIDExpectation {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelVersionByIDExpectation{
		mock:   mmGetModelVersionByID.mock,
		params: &RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID},
	}
	mmGetModelVersionByID.expectations = append(mmGetModelVersionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelVersionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelVersionByIDExpectation) Then(version *datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelVersionByIDResults{version, err}
	return e.mock
}

// Times sets number of times Repository.GetModelVersionByID should be invoked
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Times(n uint64) *mRepositoryMockGetModelVersionByID {
	if n == 0 {
		mmGetModelVersionByID.mock.t.Fatalf("Times of RepositoryMock.GetModelVersionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelVersionByID.expectedInvocations, n)
	return mmGetModelVersionByID
}

func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) invocationsDone() bool {
	if len(mmGetModelVersionByID.expectations) == 0 && mmGetModelVersionByID.defaultExpectation == nil && mmGetModelVersionByID.mock.funcGetModelVersionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelVersionByID.mock.afterGetModelVersionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelVersionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelVersionByID implements repository.Repository
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByID(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmGetModelVersionByID.beforeGetModelVersionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelVersionByID.afterGetModelVersionByIDCounter, 1)

	if mmGetModelVersionByID.inspectFuncGetModelVersionByID != nil {
		mmGetModelVersionByID.inspectFuncGetModelVersionByID(ctx, modelUID, versionID)
	}

	mm_params := RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}

	// Record call args
	mmGetModelVersionByID.GetModelVersionByIDMock.mutex.Lock()
	mmGetModelVersionByID.GetModelVersionByIDMock.callArgs = append(mmGetModelVersionByID.GetModelVersionByIDMock.callArgs, &mm_params)
	mmGetModelVersionByID.GetModelVersionByIDMock.mutex.Unlock()

	for _, e := range mmGetModelVersionByID.GetModelVersionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.version, e.results.err
		}
	}

	if mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter versionID, want: %#v, got: %#v%s\n", *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelVersionByID.t.Fatal("No results are set for the RepositoryMock.GetModelVersionByID")
		}
		return (*mm_results).version, (*mm_results).err
	}
	if mmGetModelVersionByID.funcGetModelVersionByID != nil {
		return mmGetModelVersionByID.funcGetModelVersionByID(ctx, modelUID, versionID)
	}
	mmGetModelVersionByID.t.Fatalf("Unexpected call to RepositoryMock.GetModelVersionByID. %v %v %v", ctx, modelUID, versionID)
	return
}

// GetModelVersionByIDAfterCounter returns a count of finished RepositoryMock.GetModelVersionByID invocations
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelVersionByID.afterGetModelVersionByIDCounter)
}

// GetModelVersionByIDBeforeCounter returns a count of RepositoryMock.GetModelVersionByID invocations
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelVersionByID.beforeGetModelVersionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelVersionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Calls() []*RepositoryMockGetModelVersionByIDParams {
	mmGetModelVersionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelVersionByIDParams, len(mmGetModelVersionByID.callArgs))
	copy(argCopy, mmGetModelVersionByID.callArgs)

	mmGetModelVersionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelVersionByIDDone returns true if the count of the GetModelVersionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelVersionByIDDone() bool {
	if m.GetModelVersionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelVersionByIDMock.invocationsDone()
}

// MinimockGetModelVersionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelVersionByIDInspect() {
	for _, e := range m.GetModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID with params: %#v", *e.params)
		}
	}

	afterGetModelVersionByIDCounter := mm_atomic.LoadUint64(&m.afterGetModelVersionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelVersionByIDMock.defaultExpectation != nil && afterGetModelVersionByIDCounter < 1 {
		if m.GetModelVersionByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetModelVersionByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID with params: %#v", *m.GetModelVersionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelVersionByID != nil && afterGetModelVersionByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetModelVersionByID")
	}

	if !m.GetModelVersionByIDMock.invocationsDone() && afterGetModelVersionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelVersionByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelVersionByIDMock.expectedInvocations), afterGetModelVersionByIDCounter)
	}
}

type mRepositoryMockGetNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceModelByIDExpectation
	expectations       []*RepositoryMockGetNamespaceModelByIDExpectation

	callArgs []*RepositoryMockGetNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetNamespaceModelByIDExpectation specifies expectation struct of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetNamespaceModelByIDParams
	paramPtrs *RepositoryMockGetNamespaceModelByIDParamPtrs
	results   *RepositoryMockGetNamespaceModelByIDResults
	Counter   uint64
}

// RepositoryMockGetNamespaceModelByIDParams contains parameters of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	isBasicView    bool
	includeAvatar  bool
}

// RepositoryMockGetNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	isBasicView    *bool
	includeAvatar  *bool
}

// RepositoryMockGetNamespaceModelByIDResults contains results of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDResults struct {
	mp1 *datamodel.Model
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Optional() *mRepositoryMockGetNamespaceModelByID {
	mmGetNamespaceModelByID.optional = true
	return mmGetNamespaceModelByID
}

// Expect sets up expected params for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceModelByID.defaultExpectation.params = &RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}
	for _, e := range mmGetNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceModelByID.defaultExpectation.params) {
			mmGetNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmGetNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.id = &id

	return mmGetNamespaceModelByID
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmGetNamespaceModelByID
}

// ExpectIncludeAvatarParam5 sets up expected param includeAvatar for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIncludeAvatarParam5(includeAvatar bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar

	return mmGetNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.inspectFuncGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceModelByID")
	}

	mmGetNamespaceModelByID.mock.inspectFuncGetNamespaceModelByID = f

	return mmGetNamespaceModelByID
}

// Return sets up results that will be returned by Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{mock: mmGetNamespaceModelByID.mock}
	}
	mmGetNamespaceModelByID.defaultExpectation.results = &RepositoryMockGetNamespaceModelByIDResults{mp1, err}
	return mmGetNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceModelByID method
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetNamespaceModelByID.defaultExpectation != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceModelByID method")
	}

	if len(mmGetNamespaceModelByID.expectations) > 0 {
		mmGetNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceModelByID method")
	}

	mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID = f
	return mmGetNamespaceModelByID.mock
}

// When sets expectation for the Repository.GetNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) *RepositoryMockGetNamespaceModelByIDExpectation {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceModelByIDExpectation{
		mock:   mmGetNamespaceModelByID.mock,
		params: &RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar},
	}
	mmGetNamespaceModelByID.expectations = append(mmGetNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceModelByIDExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceModelByIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceModelByID should be invoked
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Times(n uint64) *mRepositoryMockGetNamespaceModelByID {
	if n == 0 {
		mmGetNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceModelByID.expectedInvocations, n)
	return mmGetNamespaceModelByID
}

func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) invocationsDone() bool {
	if len(mmGetNamespaceModelByID.expectations) == 0 && mmGetNamespaceModelByID.defaultExpectation == nil && mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelByID.mock.afterGetNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceModelByID implements repository.Repository
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByID(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceModelByID.beforeGetNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceModelByID.afterGetNamespaceModelByIDCounter, 1)

	if mmGetNamespaceModelByID.inspectFuncGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.inspectFuncGetNamespaceModelByID(ctx, ownerPermalink, id, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}

	// Record call args
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.mutex.Lock()
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.callArgs = append(mmGetNamespaceModelByID.GetNamespaceModelByIDMock.callArgs, &mm_params)
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceModelByID.GetNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter includeAvatar, want: %#v, got: %#v%s\n", *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceModelByID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetNamespaceModelByID.funcGetNamespaceModelByID != nil {
		return mmGetNamespaceModelByID.funcGetNamespaceModelByID(ctx, ownerPermalink, id, isBasicView, includeAvatar)
	}
	mmGetNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceModelByID. %v %v %v %v %v", ctx, ownerPermalink, id, isBasicView, includeAvatar)
	return
}

// GetNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceModelByID invocations
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelByID.afterGetNamespaceModelByIDCounter)
}

// GetNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceModelByID invocations
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelByID.beforeGetNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Calls() []*RepositoryMockGetNamespaceModelByIDParams {
	mmGetNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceModelByIDParams, len(mmGetNamespaceModelByID.callArgs))
	copy(argCopy, mmGetNamespaceModelByID.callArgs)

	mmGetNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceModelByIDDone returns true if the count of the GetNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceModelByIDDone() bool {
	if m.GetNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceModelByIDMock.invocationsDone()
}

// MinimockGetNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceModelByIDInspect() {
	for _, e := range m.GetNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID with params: %#v", *e.params)
		}
	}

	afterGetNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceModelByIDMock.defaultExpectation != nil && afterGetNamespaceModelByIDCounter < 1 {
		if m.GetNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetNamespaceModelByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID with params: %#v", *m.GetNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceModelByID != nil && afterGetNamespaceModelByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetNamespaceModelByID")
	}

	if !m.GetNamespaceModelByIDMock.invocationsDone() && afterGetNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceModelByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceModelByIDMock.expectedInvocations), afterGetNamespaceModelByIDCounter)
	}
}

type mRepositoryMockListModelDefinitions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelDefinitionsExpectation
	expectations       []*RepositoryMockListModelDefinitionsExpectation

	callArgs []*RepositoryMockListModelDefinitionsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelDefinitionsExpectation specifies expectation struct of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelDefinitionsParams
	paramPtrs *RepositoryMockListModelDefinitionsParamPtrs
	results   *RepositoryMockListModelDefinitionsResults
	Counter   uint64
}

// RepositoryMockListModelDefinitionsParams contains parameters of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsParams struct {
	view      modelpb.View
	pageSize  int64
	pageToken string
}

// RepositoryMockListModelDefinitionsParamPtrs contains pointers to parameters of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsParamPtrs struct {
	view      *modelpb.View
	pageSize  *int64
	pageToken *string
}

// RepositoryMockListModelDefinitionsResults contains results of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsResults struct {
	definitions   []*datamodel.ModelDefinition
	nextPageToken string
	totalSize     int64
	err           error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Optional() *mRepositoryMockListModelDefinitions {
	mmListModelDefinitions.optional = true
	return mmListModelDefinitions
}

// Expect sets up expected params for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Expect(view modelpb.View, pageSize int64, pageToken string) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by ExpectParams functions")
	}

	mmListModelDefinitions.defaultExpectation.params = &RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}
	for _, e := range mmListModelDefinitions.expectations {
		if minimock.Equal(e.params, mmListModelDefinitions.defaultExpectation.params) {
			mmListModelDefinitions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelDefinitions.defaultExpectation.params)
		}
	}

	return mmListModelDefinitions
}

// ExpectViewParam1 sets up expected param view for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectViewParam1(view modelpb.View) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.view = &view

	return mmListModelDefinitions
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListModelDefinitions
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListModelDefinitions
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Inspect(f func(view modelpb.View, pageSize int64, pageToken string)) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelDefinitions")
	}

	mmListModelDefinitions.mock.inspectFuncListModelDefinitions = f

	return mmListModelDefinitions
}

// Return sets up results that will be returned by Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Return(definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) *RepositoryMock {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{mock: mmListModelDefinitions.mock}
	}
	mmListModelDefinitions.defaultExpectation.results = &RepositoryMockListModelDefinitionsResults{definitions, nextPageToken, totalSize, err}
	return mmListModelDefinitions.mock
}

// Set uses given function f to mock the Repository.ListModelDefinitions method
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Set(f func(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error)) *RepositoryMock {
	if mmListModelDefinitions.defaultExpectation != nil {
		mmListModelDefinitions.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelDefinitions method")
	}

	if len(mmListModelDefinitions.expectations) > 0 {
		mmListModelDefinitions.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelDefinitions method")
	}

	mmListModelDefinitions.mock.funcListModelDefinitions = f
	return mmListModelDefinitions.mock
}

// When sets expectation for the Repository.ListModelDefinitions which will trigger the result defined by the following
// Then helper
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) When(view modelpb.View, pageSize int64, pageToken string) *RepositoryMockListModelDefinitionsExpectation {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	expectation := &RepositoryMockListModelDefinitionsExpectation{
		mock:   mmListModelDefinitions.mock,
		params: &RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken},
	}
	mmListModelDefinitions.expectations = append(mmListModelDefinitions.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelDefinitions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelDefinitionsExpectation) Then(definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelDefinitionsResults{definitions, nextPageToken, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListModelDefinitions should be invoked
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Times(n uint64) *mRepositoryMockListModelDefinitions {
	if n == 0 {
		mmListModelDefinitions.mock.t.Fatalf("Times of RepositoryMock.ListModelDefinitions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelDefinitions.expectedInvocations, n)
	return mmListModelDefinitions
}

func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) invocationsDone() bool {
	if len(mmListModelDefinitions.expectations) == 0 && mmListModelDefinitions.defaultExpectation == nil && mmListModelDefinitions.mock.funcListModelDefinitions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.mock.afterListModelDefinitionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelDefinitions implements repository.Repository
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitions(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter, 1)

	if mmListModelDefinitions.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.inspectFuncListModelDefinitions(view, pageSize, pageToken)
	}

	mm_params := RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}

	// Record call args
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Lock()
	mmListModelDefinitions.ListModelDefinitionsMock.callArgs = append(mmListModelDefinitions.ListModelDefinitionsMock.callArgs, &mm_params)
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Unlock()

	for _, e := range mmListModelDefinitions.ListModelDefinitionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.definitions, e.results.nextPageToken, e.results.totalSize, e.results.err
		}
	}

	if mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter view, want: %#v, got: %#v%s\n", *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelDefinitions.t.Fatal("No results are set for the RepositoryMock.ListModelDefinitions")
		}
		return (*mm_results).definitions, (*mm_results).nextPageToken, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListModelDefinitions.funcListModelDefinitions != nil {
		return mmListModelDefinitions.funcListModelDefinitions(view, pageSize, pageToken)
	}
	mmListModelDefinitions.t.Fatalf("Unexpected call to RepositoryMock.ListModelDefinitions. %v %v %v", view, pageSize, pageToken)
	return
}

// ListModelDefinitionsAfterCounter returns a count of finished RepositoryMock.ListModelDefinitions invocations
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter)
}

// ListModelDefinitionsBeforeCounter returns a count of RepositoryMock.ListModelDefinitions invocations
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelDefinitions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Calls() []*RepositoryMockListModelDefinitionsParams {
	mmListModelDefinitions.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelDefinitionsParams, len(mmListModelDefinitions.callArgs))
	copy(argCopy, mmListModelDefinitions.callArgs)

	mmListModelDefinitions.mutex.RUnlock()

	return argCopy
}

// MinimockListModelDefinitionsDone returns true if the count of the ListModelDefinitions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelDefinitionsDone() bool {
	if m.ListModelDefinitionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelDefinitionsMock.invocationsDone()
}

// MinimockListModelDefinitionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelDefinitionsInspect() {
	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions with params: %#v", *e.params)
		}
	}

	afterListModelDefinitionsCounter := mm_atomic.LoadUint64(&m.afterListModelDefinitionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelDefinitionsMock.defaultExpectation != nil && afterListModelDefinitionsCounter < 1 {
		if m.ListModelDefinitionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelDefinitions")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions with params: %#v", *m.ListModelDefinitionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelDefinitions != nil && afterListModelDefinitionsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelDefinitions")
	}

	if !m.ListModelDefinitionsMock.invocationsDone() && afterListModelDefinitionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelDefinitions but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelDefinitionsMock.expectedInvocations), afterListModelDefinitionsCounter)
	}
}

type mRepositoryMockListModelRuns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelRunsExpectation
	expectations       []*RepositoryMockListModelRunsExpectation

	callArgs []*RepositoryMockListModelRunsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelRunsExpectation specifies expectation struct of the Repository.ListModelRuns
type RepositoryMockListModelRunsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelRunsParams
	paramPtrs *RepositoryMockListModelRunsParamPtrs
	results   *RepositoryMockListModelRunsResults
	Counter   uint64
}

// RepositoryMockListModelRunsParams contains parameters of the Repository.ListModelRuns
type RepositoryMockListModelRunsParams struct {
	ctx          context.Context
	pageSize     int64
	page         int64
	filter       filtering.Filter
	order        ordering.OrderBy
	requesterUID string
	isOwner      bool
	modelUID     string
}

// RepositoryMockListModelRunsParamPtrs contains pointers to parameters of the Repository.ListModelRuns
type RepositoryMockListModelRunsParamPtrs struct {
	ctx          *context.Context
	pageSize     *int64
	page         *int64
	filter       *filtering.Filter
	order        *ordering.OrderBy
	requesterUID *string
	isOwner      *bool
	modelUID     *string
}

// RepositoryMockListModelRunsResults contains results of the Repository.ListModelRuns
type RepositoryMockListModelRunsResults struct {
	modelTriggers []*datamodel.ModelRun
	totalSize     int64
	err           error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelRuns *mRepositoryMockListModelRuns) Optional() *mRepositoryMockListModelRuns {
	mmListModelRuns.optional = true
	return mmListModelRuns
}

// Expect sets up expected params for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Expect(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.paramPtrs != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by ExpectParams functions")
	}

	mmListModelRuns.defaultExpectation.params = &RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}
	for _, e := range mmListModelRuns.expectations {
		if minimock.Equal(e.params, mmListModelRuns.defaultExpectation.params) {
			mmListModelRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelRuns.defaultExpectation.params)
		}
	}

	return mmListModelRuns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModelRuns
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListModelRuns
}

// ExpectPageParam3 sets up expected param page for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectPageParam3(page int64) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.page = &page

	return mmListModelRuns
}

// ExpectFilterParam4 sets up expected param filter for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectFilterParam4(filter filtering.Filter) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.filter = &filter

	return mmListModelRuns
}

// ExpectOrderParam5 sets up expected param order for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectOrderParam5(order ordering.OrderBy) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.order = &order

	return mmListModelRuns
}

// ExpectRequesterUIDParam6 sets up expected param requesterUID for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectRequesterUIDParam6(requesterUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.requesterUID = &requesterUID

	return mmListModelRuns
}

// ExpectIsOwnerParam7 sets up expected param isOwner for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectIsOwnerParam7(isOwner bool) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.isOwner = &isOwner

	return mmListModelRuns
}

// ExpectModelUIDParam8 sets up expected param modelUID for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectModelUIDParam8(modelUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmListModelRuns
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Inspect(f func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string)) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.inspectFuncListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelRuns")
	}

	mmListModelRuns.mock.inspectFuncListModelRuns = f

	return mmListModelRuns
}

// Return sets up results that will be returned by Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Return(modelTriggers []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{mock: mmListModelRuns.mock}
	}
	mmListModelRuns.defaultExpectation.results = &RepositoryMockListModelRunsResults{modelTriggers, totalSize, err}
	return mmListModelRuns.mock
}

// Set uses given function f to mock the Repository.ListModelRuns method
func (mmListModelRuns *mRepositoryMockListModelRuns) Set(f func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error)) *RepositoryMock {
	if mmListModelRuns.defaultExpectation != nil {
		mmListModelRuns.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelRuns method")
	}

	if len(mmListModelRuns.expectations) > 0 {
		mmListModelRuns.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelRuns method")
	}

	mmListModelRuns.mock.funcListModelRuns = f
	return mmListModelRuns.mock
}

// When sets expectation for the Repository.ListModelRuns which will trigger the result defined by the following
// Then helper
func (mmListModelRuns *mRepositoryMockListModelRuns) When(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) *RepositoryMockListModelRunsExpectation {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	expectation := &RepositoryMockListModelRunsExpectation{
		mock:   mmListModelRuns.mock,
		params: &RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID},
	}
	mmListModelRuns.expectations = append(mmListModelRuns.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelRuns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelRunsExpectation) Then(modelTriggers []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelRunsResults{modelTriggers, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListModelRuns should be invoked
func (mmListModelRuns *mRepositoryMockListModelRuns) Times(n uint64) *mRepositoryMockListModelRuns {
	if n == 0 {
		mmListModelRuns.mock.t.Fatalf("Times of RepositoryMock.ListModelRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelRuns.expectedInvocations, n)
	return mmListModelRuns
}

func (mmListModelRuns *mRepositoryMockListModelRuns) invocationsDone() bool {
	if len(mmListModelRuns.expectations) == 0 && mmListModelRuns.defaultExpectation == nil && mmListModelRuns.mock.funcListModelRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelRuns.mock.afterListModelRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelRuns implements repository.Repository
func (mmListModelRuns *RepositoryMock) ListModelRuns(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListModelRuns.beforeListModelRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelRuns.afterListModelRunsCounter, 1)

	if mmListModelRuns.inspectFuncListModelRuns != nil {
		mmListModelRuns.inspectFuncListModelRuns(ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	}

	mm_params := RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}

	// Record call args
	mmListModelRuns.ListModelRunsMock.mutex.Lock()
	mmListModelRuns.ListModelRunsMock.callArgs = append(mmListModelRuns.ListModelRunsMock.callArgs, &mm_params)
	mmListModelRuns.ListModelRunsMock.mutex.Unlock()

	for _, e := range mmListModelRuns.ListModelRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelTriggers, e.results.totalSize, e.results.err
		}
	}

	if mmListModelRuns.ListModelRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelRuns.ListModelRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelRuns.ListModelRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelRuns.ListModelRunsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter page, want: %#v, got: %#v%s\n", *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.requesterUID != nil && !minimock.Equal(*mm_want_ptrs.requesterUID, mm_got.requesterUID) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter requesterUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.requesterUID, mm_got.requesterUID, minimock.Diff(*mm_want_ptrs.requesterUID, mm_got.requesterUID))
			}

			if mm_want_ptrs.isOwner != nil && !minimock.Equal(*mm_want_ptrs.isOwner, mm_got.isOwner) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter isOwner, want: %#v, got: %#v%s\n", *mm_want_ptrs.isOwner, mm_got.isOwner, minimock.Diff(*mm_want_ptrs.isOwner, mm_got.isOwner))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelRuns.ListModelRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelRuns.t.Fatal("No results are set for the RepositoryMock.ListModelRuns")
		}
		return (*mm_results).modelTriggers, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListModelRuns.funcListModelRuns != nil {
		return mmListModelRuns.funcListModelRuns(ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	}
	mmListModelRuns.t.Fatalf("Unexpected call to RepositoryMock.ListModelRuns. %v %v %v %v %v %v %v %v", ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	return
}

// ListModelRunsAfterCounter returns a count of finished RepositoryMock.ListModelRuns invocations
func (mmListModelRuns *RepositoryMock) ListModelRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.afterListModelRunsCounter)
}

// ListModelRunsBeforeCounter returns a count of RepositoryMock.ListModelRuns invocations
func (mmListModelRuns *RepositoryMock) ListModelRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.beforeListModelRunsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelRuns *mRepositoryMockListModelRuns) Calls() []*RepositoryMockListModelRunsParams {
	mmListModelRuns.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelRunsParams, len(mmListModelRuns.callArgs))
	copy(argCopy, mmListModelRuns.callArgs)

	mmListModelRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListModelRunsDone returns true if the count of the ListModelRuns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelRunsDone() bool {
	if m.ListModelRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelRunsMock.invocationsDone()
}

// MinimockListModelRunsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelRunsInspect() {
	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRuns with params: %#v", *e.params)
		}
	}

	afterListModelRunsCounter := mm_atomic.LoadUint64(&m.afterListModelRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelRunsMock.defaultExpectation != nil && afterListModelRunsCounter < 1 {
		if m.ListModelRunsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelRuns")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRuns with params: %#v", *m.ListModelRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelRuns != nil && afterListModelRunsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelRuns")
	}

	if !m.ListModelRunsMock.invocationsDone() && afterListModelRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelRuns but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelRunsMock.expectedInvocations), afterListModelRunsCounter)
	}
}

type mRepositoryMockListModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelTagsExpectation
	expectations       []*RepositoryMockListModelTagsExpectation

	callArgs []*RepositoryMockListModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelTagsExpectation specifies expectation struct of the Repository.ListModelTags
type RepositoryMockListModelTagsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelTagsParams
	paramPtrs *RepositoryMockListModelTagsParamPtrs
	results   *RepositoryMockListModelTagsResults
	Counter   uint64
}

// RepositoryMockListModelTagsParams contains parameters of the Repository.ListModelTags
type RepositoryMockListModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// RepositoryMockListModelTagsParamPtrs contains pointers to parameters of the Repository.ListModelTags
type RepositoryMockListModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// RepositoryMockListModelTagsResults contains results of the Repository.ListModelTags
type RepositoryMockListModelTagsResults struct {
	ma1 []datamodel.ModelTag
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelTags *mRepositoryMockListModelTags) Optional() *mRepositoryMockListModelTags {
	mmListModelTags.optional = true
	return mmListModelTags
}

// Expect sets up expected params for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Expect(ctx context.Context, modelUID uuid.UUID) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.paramPtrs != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by ExpectParams functions")
	}

	mmListModelTags.defaultExpectation.params = &RepositoryMockListModelTagsParams{ctx, modelUID}
	for _, e := range mmListModelTags.expectations {
		if minimock.Equal(e.params, mmListModelTags.defaultExpectation.params) {
			mmListModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelTags.defaultExpectation.params)
		}
	}

	return mmListModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.params != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Expect")
	}

	if mmListModelTags.defaultExpectation.paramPtrs == nil {
		mmListModelTags.defaultExpectation.paramPtrs = &RepositoryMockListModelTagsParamPtrs{}
	}
	mmListModelTags.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.params != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Expect")
	}

	if mmListModelTags.defaultExpectation.paramPtrs == nil {
		mmListModelTags.defaultExpectation.paramPtrs = &RepositoryMockListModelTagsParamPtrs{}
	}
	mmListModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmListModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.inspectFuncListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelTags")
	}

	mmListModelTags.mock.inspectFuncListModelTags = f

	return mmListModelTags
}

// Return sets up results that will be returned by Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Return(ma1 []datamodel.ModelTag, err error) *RepositoryMock {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{mock: mmListModelTags.mock}
	}
	mmListModelTags.defaultExpectation.results = &RepositoryMockListModelTagsResults{ma1, err}
	return mmListModelTags.mock
}

// Set uses given function f to mock the Repository.ListModelTags method
func (mmListModelTags *mRepositoryMockListModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error)) *RepositoryMock {
	if mmListModelTags.defaultExpectation != nil {
		mmListModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelTags method")
	}

	if len(mmListModelTags.expectations) > 0 {
		mmListModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelTags method")
	}

	mmListModelTags.mock.funcListModelTags = f
	return mmListModelTags.mock
}

// When sets expectation for the Repository.ListModelTags which will trigger the result defined by the following
// Then helper
func (mmListModelTags *mRepositoryMockListModelTags) When(ctx context.Context, modelUID uuid.UUID) *RepositoryMockListModelTagsExpectation {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockListModelTagsExpectation{
		mock:   mmListModelTags.mock,
		params: &RepositoryMockListModelTagsParams{ctx, modelUID},
	}
	mmListModelTags.expectations = append(mmListModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelTagsExpectation) Then(ma1 []datamodel.ModelTag, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelTagsResults{ma1, err}
	return e.mock
}

// Times sets number of times Repository.ListModelTags should be invoked
func (mmListModelTags *mRepositoryMockListModelTags) Times(n uint64) *mRepositoryMockListModelTags {
	if n == 0 {
		mmListModelTags.mock.t.Fatalf("Times of RepositoryMock.ListModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelTags.expectedInvocations, n)
	return mmListModelTags
}

func (mmListModelTags *mRepositoryMockListModelTags) invocationsDone() bool {
	if len(mmListModelTags.expectations) == 0 && mmListModelTags.defaultExpectation == nil && mmListModelTags.mock.funcListModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelTags.mock.afterListModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelTags implements repository.Repository
func (mmListModelTags *RepositoryMock) ListModelTags(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error) {
	mm_atomic.AddUint64(&mmListModelTags.beforeListModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelTags.afterListModelTagsCounter, 1)

	if mmListModelTags.inspectFuncListModelTags != nil {
		mmListModelTags.inspectFuncListModelTags(ctx, modelUID)
	}

	mm_params := RepositoryMockListModelTagsParams{ctx, modelUID}

	// Record call args
	mmListModelTags.ListModelTagsMock.mutex.Lock()
	mmListModelTags.ListModelTagsMock.callArgs = append(mmListModelTags.ListModelTagsMock.callArgs, &mm_params)
	mmListModelTags.ListModelTagsMock.mutex.Unlock()

	for _, e := range mmListModelTags.ListModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmListModelTags.ListModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelTags.ListModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelTags.ListModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelTags.ListModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelTagsParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelTags.ListModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelTags.t.Fatal("No results are set for the RepositoryMock.ListModelTags")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmListModelTags.funcListModelTags != nil {
		return mmListModelTags.funcListModelTags(ctx, modelUID)
	}
	mmListModelTags.t.Fatalf("Unexpected call to RepositoryMock.ListModelTags. %v %v", ctx, modelUID)
	return
}

// ListModelTagsAfterCounter returns a count of finished RepositoryMock.ListModelTags invocations
func (mmListModelTags *RepositoryMock) ListModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelTags.afterListModelTagsCounter)
}

// ListModelTagsBeforeCounter returns a count of RepositoryMock.ListModelTags invocations
func (mmListModelTags *RepositoryMock) ListModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelTags.beforeListModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelTags *mRepositoryMockListModelTags) Calls() []*RepositoryMockListModelTagsParams {
	mmListModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelTagsParams, len(mmListModelTags.callArgs))
	copy(argCopy, mmListModelTags.callArgs)

	mmListModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockListModelTagsDone returns true if the count of the ListModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelTagsDone() bool {
	if m.ListModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelTagsMock.invocationsDone()
}

// MinimockListModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelTagsInspect() {
	for _, e := range m.ListModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelTags with params: %#v", *e.params)
		}
	}

	afterListModelTagsCounter := mm_atomic.LoadUint64(&m.afterListModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelTagsMock.defaultExpectation != nil && afterListModelTagsCounter < 1 {
		if m.ListModelTagsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelTags")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelTags with params: %#v", *m.ListModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelTags != nil && afterListModelTagsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelTags")
	}

	if !m.ListModelTagsMock.invocationsDone() && afterListModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelTags but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelTagsMock.expectedInvocations), afterListModelTagsCounter)
	}
}

type mRepositoryMockListModelVersions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelVersionsExpectation
	expectations       []*RepositoryMockListModelVersionsExpectation

	callArgs []*RepositoryMockListModelVersionsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelVersionsExpectation specifies expectation struct of the Repository.ListModelVersions
type RepositoryMockListModelVersionsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelVersionsParams
	paramPtrs *RepositoryMockListModelVersionsParamPtrs
	results   *RepositoryMockListModelVersionsResults
	Counter   uint64
}

// RepositoryMockListModelVersionsParams contains parameters of the Repository.ListModelVersions
type RepositoryMockListModelVersionsParams struct {
	ctx         context.Context
	modelUID    uuid.UUID
	groupDigest bool
}

// RepositoryMockListModelVersionsParamPtrs contains pointers to parameters of the Repository.ListModelVersions
type RepositoryMockListModelVersionsParamPtrs struct {
	ctx         *context.Context
	modelUID    *uuid.UUID
	groupDigest *bool
}

// RepositoryMockListModelVersionsResults contains results of the Repository.ListModelVersions
type RepositoryMockListModelVersionsResults struct {
	versions []*datamodel.ModelVersion
	err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelVersions *mRepositoryMockListModelVersions) Optional() *mRepositoryMockListModelVersions {
	mmListModelVersions.optional = true
	return mmListModelVersions
}

// Expect sets up expected params for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Expect(ctx context.Context, modelUID uuid.UUID, groupDigest bool) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.paramPtrs != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by ExpectParams functions")
	}

	mmListModelVersions.defaultExpectation.params = &RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}
	for _, e := range mmListModelVersions.expectations {
		if minimock.Equal(e.params, mmListModelVersions.defaultExpectation.params) {
			mmListModelVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelVersions.defaultExpectation.params)
		}
	}

	return mmListModelVersions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModelVersions
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmListModelVersions
}

// ExpectGroupDigestParam3 sets up expected param groupDigest for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectGroupDigestParam3(groupDigest bool) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.groupDigest = &groupDigest

	return mmListModelVersions
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Inspect(f func(ctx context.Context, modelUID uuid.UUID, groupDigest bool)) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.inspectFuncListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelVersions")
	}

	mmListModelVersions.mock.inspectFuncListModelVersions = f

	return mmListModelVersions
}

// Return sets up results that will be returned by Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Return(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{mock: mmListModelVersions.mock}
	}
	mmListModelVersions.defaultExpectation.results = &RepositoryMockListModelVersionsResults{versions, err}
	return mmListModelVersions.mock
}

// Set uses given function f to mock the Repository.ListModelVersions method
func (mmListModelVersions *mRepositoryMockListModelVersions) Set(f func(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmListModelVersions.defaultExpectation != nil {
		mmListModelVersions.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelVersions method")
	}

	if len(mmListModelVersions.expectations) > 0 {
		mmListModelVersions.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelVersions method")
	}

	mmListModelVersions.mock.funcListModelVersions = f
	return mmListModelVersions.mock
}

// When sets expectation for the Repository.ListModelVersions which will trigger the result defined by the following
// Then helper
func (mmListModelVersions *mRepositoryMockListModelVersions) When(ctx context.Context, modelUID uuid.UUID, groupDigest bool) *RepositoryMockListModelVersionsExpectation {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	expectation := &RepositoryMockListModelVersionsExpectation{
		mock:   mmListModelVersions.mock,
		params: &RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest},
	}
	mmListModelVersions.expectations = append(mmListModelVersions.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelVersions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelVersionsExpectation) Then(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelVersionsResults{versions, err}
	return e.mock
}

// Times sets number of times Repository.ListModelVersions should be invoked
func (mmListModelVersions *mRepositoryMockListModelVersions) Times(n uint64) *mRepositoryMockListModelVersions {
	if n == 0 {
		mmListModelVersions.mock.t.Fatalf("Times of RepositoryMock.ListModelVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelVersions.expectedInvocations, n)
	return mmListModelVersions
}

func (mmListModelVersions *mRepositoryMockListModelVersions) invocationsDone() bool {
	if len(mmListModelVersions.expectations) == 0 && mmListModelVersions.defaultExpectation == nil && mmListModelVersions.mock.funcListModelVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelVersions.mock.afterListModelVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelVersions implements repository.Repository
func (mmListModelVersions *RepositoryMock) ListModelVersions(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmListModelVersions.beforeListModelVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelVersions.afterListModelVersionsCounter, 1)

	if mmListModelVersions.inspectFuncListModelVersions != nil {
		mmListModelVersions.inspectFuncListModelVersions(ctx, modelUID, groupDigest)
	}

	mm_params := RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}

	// Record call args
	mmListModelVersions.ListModelVersionsMock.mutex.Lock()
	mmListModelVersions.ListModelVersionsMock.callArgs = append(mmListModelVersions.ListModelVersionsMock.callArgs, &mm_params)
	mmListModelVersions.ListModelVersionsMock.mutex.Unlock()

	for _, e := range mmListModelVersions.ListModelVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.versions, e.results.err
		}
	}

	if mmListModelVersions.ListModelVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelVersions.ListModelVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelVersions.ListModelVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelVersions.ListModelVersionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.groupDigest != nil && !minimock.Equal(*mm_want_ptrs.groupDigest, mm_got.groupDigest) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter groupDigest, want: %#v, got: %#v%s\n", *mm_want_ptrs.groupDigest, mm_got.groupDigest, minimock.Diff(*mm_want_ptrs.groupDigest, mm_got.groupDigest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelVersions.ListModelVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelVersions.t.Fatal("No results are set for the RepositoryMock.ListModelVersions")
		}
		return (*mm_results).versions, (*mm_results).err
	}
	if mmListModelVersions.funcListModelVersions != nil {
		return mmListModelVersions.funcListModelVersions(ctx, modelUID, groupDigest)
	}
	mmListModelVersions.t.Fatalf("Unexpected call to RepositoryMock.ListModelVersions. %v %v %v", ctx, modelUID, groupDigest)
	return
}

// ListModelVersionsAfterCounter returns a count of finished RepositoryMock.ListModelVersions invocations
func (mmListModelVersions *RepositoryMock) ListModelVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersions.afterListModelVersionsCounter)
}

// ListModelVersionsBeforeCounter returns a count of RepositoryMock.ListModelVersions invocations
func (mmListModelVersions *RepositoryMock) ListModelVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersions.beforeListModelVersionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelVersions *mRepositoryMockListModelVersions) Calls() []*RepositoryMockListModelVersionsParams {
	mmListModelVersions.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelVersionsParams, len(mmListModelVersions.callArgs))
	copy(argCopy, mmListModelVersions.callArgs)

	mmListModelVersions.mutex.RUnlock()

	return argCopy
}

// MinimockListModelVersionsDone returns true if the count of the ListModelVersions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelVersionsDone() bool {
	if m.ListModelVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelVersionsMock.invocationsDone()
}

// MinimockListModelVersionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelVersionsInspect() {
	for _, e := range m.ListModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersions with params: %#v", *e.params)
		}
	}

	afterListModelVersionsCounter := mm_atomic.LoadUint64(&m.afterListModelVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelVersionsMock.defaultExpectation != nil && afterListModelVersionsCounter < 1 {
		if m.ListModelVersionsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelVersions")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersions with params: %#v", *m.ListModelVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelVersions != nil && afterListModelVersionsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelVersions")
	}

	if !m.ListModelVersionsMock.invocationsDone() && afterListModelVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelVersions but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelVersionsMock.expectedInvocations), afterListModelVersionsCounter)
	}
}

type mRepositoryMockListModelVersionsByDigest struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelVersionsByDigestExpectation
	expectations       []*RepositoryMockListModelVersionsByDigestExpectation

	callArgs []*RepositoryMockListModelVersionsByDigestParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelVersionsByDigestExpectation specifies expectation struct of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelVersionsByDigestParams
	paramPtrs *RepositoryMockListModelVersionsByDigestParamPtrs
	results   *RepositoryMockListModelVersionsByDigestResults
	Counter   uint64
}

// RepositoryMockListModelVersionsByDigestParams contains parameters of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	digest   string
}

// RepositoryMockListModelVersionsByDigestParamPtrs contains pointers to parameters of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	digest   *string
}

// RepositoryMockListModelVersionsByDigestResults contains results of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestResults struct {
	versions []*datamodel.ModelVersion
	err      error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Optional() *mRepositoryMockListModelVersionsByDigest {
	mmListModelVersionsByDigest.optional = true
	return mmListModelVersionsByDigest
}

// Expect sets up expected params for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Expect(ctx context.Context, modelUID uuid.UUID, digest string) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by ExpectParams functions")
	}

	mmListModelVersionsByDigest.defaultExpectation.params = &RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}
	for _, e := range mmListModelVersionsByDigest.expectations {
		if minimock.Equal(e.params, mmListModelVersionsByDigest.defaultExpectation.params) {
			mmListModelVersionsByDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelVersionsByDigest.defaultExpectation.params)
		}
	}

	return mmListModelVersionsByDigest
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModelVersionsByDigest
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmListModelVersionsByDigest
}

// ExpectDigestParam3 sets up expected param digest for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectDigestParam3(digest string) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.digest = &digest

	return mmListModelVersionsByDigest
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Inspect(f func(ctx context.Context, modelUID uuid.UUID, digest string)) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.inspectFuncListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelVersionsByDigest")
	}

	mmListModelVersionsByDigest.mock.inspectFuncListModelVersionsByDigest = f

	return mmListModelVersionsByDigest
}

// Return sets up results that will be returned by Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Return(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{mock: mmListModelVersionsByDigest.mock}
	}
	mmListModelVersionsByDigest.defaultExpectation.results = &RepositoryMockListModelVersionsByDigestResults{versions, err}
	return mmListModelVersionsByDigest.mock
}

// Set uses given function f to mock the Repository.ListModelVersionsByDigest method
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Set(f func(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmListModelVersionsByDigest.defaultExpectation != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelVersionsByDigest method")
	}

	if len(mmListModelVersionsByDigest.expectations) > 0 {
		mmListModelVersionsByDigest.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelVersionsByDigest method")
	}

	mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest = f
	return mmListModelVersionsByDigest.mock
}

// When sets expectation for the Repository.ListModelVersionsByDigest which will trigger the result defined by the following
// Then helper
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) When(ctx context.Context, modelUID uuid.UUID, digest string) *RepositoryMockListModelVersionsByDigestExpectation {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	expectation := &RepositoryMockListModelVersionsByDigestExpectation{
		mock:   mmListModelVersionsByDigest.mock,
		params: &RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest},
	}
	mmListModelVersionsByDigest.expectations = append(mmListModelVersionsByDigest.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelVersionsByDigest return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelVersionsByDigestExpectation) Then(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelVersionsByDigestResults{versions, err}
	return e.mock
}

// Times sets number of times Repository.ListModelVersionsByDigest should be invoked
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Times(n uint64) *mRepositoryMockListModelVersionsByDigest {
	if n == 0 {
		mmListModelVersionsByDigest.mock.t.Fatalf("Times of RepositoryMock.ListModelVersionsByDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelVersionsByDigest.expectedInvocations, n)
	return mmListModelVersionsByDigest
}

func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) invocationsDone() bool {
	if len(mmListModelVersionsByDigest.expectations) == 0 && mmListModelVersionsByDigest.defaultExpectation == nil && mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelVersionsByDigest.mock.afterListModelVersionsByDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelVersionsByDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelVersionsByDigest implements repository.Repository
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigest(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmListModelVersionsByDigest.beforeListModelVersionsByDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelVersionsByDigest.afterListModelVersionsByDigestCounter, 1)

	if mmListModelVersionsByDigest.inspectFuncListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.inspectFuncListModelVersionsByDigest(ctx, modelUID, digest)
	}

	mm_params := RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}

	// Record call args
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.mutex.Lock()
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.callArgs = append(mmListModelVersionsByDigest.ListModelVersionsByDigestMock.callArgs, &mm_params)
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.mutex.Unlock()

	for _, e := range mmListModelVersionsByDigest.ListModelVersionsByDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.versions, e.results.err
		}
	}

	if mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.params
		mm_want_ptrs := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter digest, want: %#v, got: %#v%s\n", *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelVersionsByDigest.t.Fatal("No results are set for the RepositoryMock.ListModelVersionsByDigest")
		}
		return (*mm_results).versions, (*mm_results).err
	}
	if mmListModelVersionsByDigest.funcListModelVersionsByDigest != nil {
		return mmListModelVersionsByDigest.funcListModelVersionsByDigest(ctx, modelUID, digest)
	}
	mmListModelVersionsByDigest.t.Fatalf("Unexpected call to RepositoryMock.ListModelVersionsByDigest. %v %v %v", ctx, modelUID, digest)
	return
}

// ListModelVersionsByDigestAfterCounter returns a count of finished RepositoryMock.ListModelVersionsByDigest invocations
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersionsByDigest.afterListModelVersionsByDigestCounter)
}

// ListModelVersionsByDigestBeforeCounter returns a count of RepositoryMock.ListModelVersionsByDigest invocations
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersionsByDigest.beforeListModelVersionsByDigestCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelVersionsByDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Calls() []*RepositoryMockListModelVersionsByDigestParams {
	mmListModelVersionsByDigest.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelVersionsByDigestParams, len(mmListModelVersionsByDigest.callArgs))
	copy(argCopy, mmListModelVersionsByDigest.callArgs)

	mmListModelVersionsByDigest.mutex.RUnlock()

	return argCopy
}

// MinimockListModelVersionsByDigestDone returns true if the count of the ListModelVersionsByDigest invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelVersionsByDigestDone() bool {
	if m.ListModelVersionsByDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelVersionsByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelVersionsByDigestMock.invocationsDone()
}

// MinimockListModelVersionsByDigestInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelVersionsByDigestInspect() {
	for _, e := range m.ListModelVersionsByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest with params: %#v", *e.params)
		}
	}

	afterListModelVersionsByDigestCounter := mm_atomic.LoadUint64(&m.afterListModelVersionsByDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelVersionsByDigestMock.defaultExpectation != nil && afterListModelVersionsByDigestCounter < 1 {
		if m.ListModelVersionsByDigestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelVersionsByDigest")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest with params: %#v", *m.ListModelVersionsByDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelVersionsByDigest != nil && afterListModelVersionsByDigestCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelVersionsByDigest")
	}

	if !m.ListModelVersionsByDigestMock.invocationsDone() && afterListModelVersionsByDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelVersionsByDigest but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelVersionsByDigestMock.expectedInvocations), afterListModelVersionsByDigestCounter)
	}
}

type mRepositoryMockListModels struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelsExpectation
	expectations       []*RepositoryMockListModelsExpectation

	callArgs []*RepositoryMockListModelsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelsExpectation specifies expectation struct of the Repository.ListModels
type RepositoryMockListModelsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelsParams
	paramPtrs *RepositoryMockListModelsParamPtrs
	results   *RepositoryMockListModelsResults
	Counter   uint64
}

// RepositoryMockListModelsParams contains parameters of the Repository.ListModels
type RepositoryMockListModelsParams struct {
	ctx          context.Context
	pageSize     int64
	pageToken    string
	isBasicView  bool
	filter       filtering.Filter
	uidAllowList []uuid.UUID
	showDeleted  bool
	order        ordering.OrderBy
	visibility   *modelpb.Model_Visibility
}

// RepositoryMockListModelsParamPtrs contains pointers to parameters of the Repository.ListModels
type RepositoryMockListModelsParamPtrs struct {
	ctx          *context.Context
	pageSize     *int64
	pageToken    *string
	isBasicView  *bool
	filter       *filtering.Filter
	uidAllowList *[]uuid.UUID
	showDeleted  *bool
	order        *ordering.OrderBy
	visibility   **modelpb.Model_Visibility
}

// RepositoryMockListModelsResults contains results of the Repository.ListModels
type RepositoryMockListModelsResults struct {
	models        []*datamodel.Model
	totalSize     int64
	nextPageToken string
	err           error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModels *mRepositoryMockListModels) Optional() *mRepositoryMockListModels {
	mmListModels.optional = true
	return mmListModels
}

// Expect sets up expected params for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.paramPtrs != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by ExpectParams functions")
	}

	mmListModels.defaultExpectation.params = &RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}
	for _, e := range mmListModels.expectations {
		if minimock.Equal(e.params, mmListModels.defaultExpectation.params) {
			mmListModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModels.defaultExpectation.params)
		}
	}

	return mmListModels
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModels
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListModels
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListModels
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListModels
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.filter = &filter

	return mmListModels
}

// ExpectUidAllowListParam6 sets up expected param uidAllowList for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectUidAllowListParam6(uidAllowList []uuid.UUID) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList

	return mmListModels
}

// ExpectShowDeletedParam7 sets up expected param showDeleted for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectShowDeletedParam7(showDeleted bool) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListModels
}

// ExpectOrderParam8 sets up expected param order for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectOrderParam8(order ordering.OrderBy) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.order = &order

	return mmListModels
}

// ExpectVisibilityParam9 sets up expected param visibility for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectVisibilityParam9(visibility *modelpb.Model_Visibility) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.visibility = &visibility

	return mmListModels
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)) *mRepositoryMockListModels {
	if mmListModels.mock.inspectFuncListModels != nil {
		mmListModels.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModels")
	}

	mmListModels.mock.inspectFuncListModels = f

	return mmListModels
}

// Return sets up results that will be returned by Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Return(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{mock: mmListModels.mock}
	}
	mmListModels.defaultExpectation.results = &RepositoryMockListModelsResults{models, totalSize, nextPageToken, err}
	return mmListModels.mock
}

// Set uses given function f to mock the Repository.ListModels method
func (mmListModels *mRepositoryMockListModels) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)) *RepositoryMock {
	if mmListModels.defaultExpectation != nil {
		mmListModels.mock.t.Fatalf("Default expectation is already set for the Repository.ListModels method")
	}

	if len(mmListModels.expectations) > 0 {
		mmListModels.mock.t.Fatalf("Some expectations are already set for the Repository.ListModels method")
	}

	mmListModels.mock.funcListModels = f
	return mmListModels.mock
}

// When sets expectation for the Repository.ListModels which will trigger the result defined by the following
// Then helper
func (mmListModels *mRepositoryMockListModels) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *RepositoryMockListModelsExpectation {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	expectation := &RepositoryMockListModelsExpectation{
		mock:   mmListModels.mock,
		params: &RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility},
	}
	mmListModels.expectations = append(mmListModels.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModels return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelsExpectation) Then(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelsResults{models, totalSize, nextPageToken, err}
	return e.mock
}

// Times sets number of times Repository.ListModels should be invoked
func (mmListModels *mRepositoryMockListModels) Times(n uint64) *mRepositoryMockListModels {
	if n == 0 {
		mmListModels.mock.t.Fatalf("Times of RepositoryMock.ListModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModels.expectedInvocations, n)
	return mmListModels
}

func (mmListModels *mRepositoryMockListModels) invocationsDone() bool {
	if len(mmListModels.expectations) == 0 && mmListModels.defaultExpectation == nil && mmListModels.mock.funcListModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModels.mock.afterListModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModels implements repository.Repository
func (mmListModels *RepositoryMock) ListModels(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error) {
	mm_atomic.AddUint64(&mmListModels.beforeListModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModels.afterListModelsCounter, 1)

	if mmListModels.inspectFuncListModels != nil {
		mmListModels.inspectFuncListModels(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}

	mm_params := RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

	// Record call args
	mmListModels.ListModelsMock.mutex.Lock()
	mmListModels.ListModelsMock.callArgs = append(mmListModels.ListModelsMock.callArgs, &mm_params)
	mmListModels.ListModelsMock.mutex.Unlock()

	for _, e := range mmListModels.ListModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.models, e.results.totalSize, e.results.nextPageToken, e.results.err
		}
	}

	if mmListModels.ListModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModels.ListModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModels.ListModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListModels.ListModelsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter uidAllowList, want: %#v, got: %#v%s\n", *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.visibility != nil && !minimock.Equal(*mm_want_ptrs.visibility, mm_got.visibility) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter visibility, want: %#v, got: %#v%s\n", *mm_want_ptrs.visibility, mm_got.visibility, minimock.Diff(*mm_want_ptrs.visibility, mm_got.visibility))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModels.ListModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModels.t.Fatal("No results are set for the RepositoryMock.ListModels")
		}
		return (*mm_results).models, (*mm_results).totalSize, (*mm_results).nextPageToken, (*mm_results).err
	}
	if mmListModels.funcListModels != nil {
		return mmListModels.funcListModels(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}
	mmListModels.t.Fatalf("Unexpected call to RepositoryMock.ListModels. %v %v %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	return
}

// ListModelsAfterCounter returns a count of finished RepositoryMock.ListModels invocations
func (mmListModels *RepositoryMock) ListModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.afterListModelsCounter)
}

// ListModelsBeforeCounter returns a count of RepositoryMock.ListModels invocations
func (mmListModels *RepositoryMock) ListModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.beforeListModelsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModels *mRepositoryMockListModels) Calls() []*RepositoryMockListModelsParams {
	mmListModels.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelsParams, len(mmListModels.callArgs))
	copy(argCopy, mmListModels.callArgs)

	mmListModels.mutex.RUnlock()

	return argCopy
}

// MinimockListModelsDone returns true if the count of the ListModels invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelsDone() bool {
	if m.ListModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelsMock.invocationsDone()
}

// MinimockListModelsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelsInspect() {
	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModels with params: %#v", *e.params)
		}
	}

	afterListModelsCounter := mm_atomic.LoadUint64(&m.afterListModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelsMock.defaultExpectation != nil && afterListModelsCounter < 1 {
		if m.ListModelsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModels")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModels with params: %#v", *m.ListModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModels != nil && afterListModelsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModels")
	}

	if !m.ListModelsMock.invocationsDone() && afterListModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModels but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelsMock.expectedInvocations), afterListModelsCounter)
	}
}

type mRepositoryMockListModelsAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelsAdminExpectation
	expectations       []*RepositoryMockListModelsAdminExpectation

	callArgs []*RepositoryMockListModelsAdminParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListModelsAdminExpectation specifies expectation struct of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListModelsAdminParams
	paramPtrs *RepositoryMockListModelsAdminParamPtrs
	results   *RepositoryMockListModelsAdminResults
	Counter   uint64
}

// RepositoryMockListModelsAdminParams contains parameters of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminParams struct {
	ctx         context.Context
	pageSize    int64
	pageToken   string
	isBasicView bool
	filter      filtering.Filter
	showDeleted bool
}

// RepositoryMockListModelsAdminParamPtrs contains pointers to parameters of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminParamPtrs struct {
	ctx         *context.Context
	pageSize    *int64
	pageToken   *string
	isBasicView *bool
	filter      *filtering.Filter
	showDeleted *bool
}

// RepositoryMockListModelsAdminResults contains results of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminResults struct {
	mpa1 []*datamodel.Model
	i1   int64
	s1   string
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Optional() *mRepositoryMockListModelsAdmin {
	mmListModelsAdmin.optional = true
	return mmListModelsAdmin
}

// Expect sets up expected params for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by ExpectParams functions")
	}

	mmListModelsAdmin.defaultExpectation.params = &RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}
	for _, e := range mmListModelsAdmin.expectations {
		if minimock.Equal(e.params, mmListModelsAdmin.defaultExpectation.params) {
			mmListModelsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelsAdmin.defaultExpectation.params)
		}
	}

	return mmListModelsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListModelsAdmin
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListModelsAdmin
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListModelsAdmin
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListModelsAdmin
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.filter = &filter

	return mmListModelsAdmin
}

// ExpectShowDeletedParam6 sets up expected param showDeleted for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectShowDeletedParam6(showDeleted bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListModelsAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool)) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.inspectFuncListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelsAdmin")
	}

	mmListModelsAdmin.mock.inspectFuncListModelsAdmin = f

	return mmListModelsAdmin
}

// Return sets up results that will be returned by Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Return(mpa1 []*datamodel.Model, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{mock: mmListModelsAdmin.mock}
	}
	mmListModelsAdmin.defaultExpectation.results = &RepositoryMockListModelsAdminResults{mpa1, i1, s1, err}
	return mmListModelsAdmin.mock
}

// Set uses given function f to mock the Repository.ListModelsAdmin method
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListModelsAdmin.defaultExpectation != nil {
		mmListModelsAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelsAdmin method")
	}

	if len(mmListModelsAdmin.expectations) > 0 {
		mmListModelsAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelsAdmin method")
	}

	mmListModelsAdmin.mock.funcListModelsAdmin = f
	return mmListModelsAdmin.mock
}

// When sets expectation for the Repository.ListModelsAdmin which will trigger the result defined by the following
// Then helper
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) *RepositoryMockListModelsAdminExpectation {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListModelsAdminExpectation{
		mock:   mmListModelsAdmin.mock,
		params: &RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted},
	}
	mmListModelsAdmin.expectations = append(mmListModelsAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelsAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelsAdminExpectation) Then(mpa1 []*datamodel.Model, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelsAdminResults{mpa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListModelsAdmin should be invoked
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Times(n uint64) *mRepositoryMockListModelsAdmin {
	if n == 0 {
		mmListModelsAdmin.mock.t.Fatalf("Times of RepositoryMock.ListModelsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelsAdmin.expectedInvocations, n)
	return mmListModelsAdmin
}

func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) invocationsDone() bool {
	if len(mmListModelsAdmin.expectations) == 0 && mmListModelsAdmin.defaultExpectation == nil && mmListModelsAdmin.mock.funcListModelsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelsAdmin.mock.afterListModelsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelsAdmin implements repository.Repository
func (mmListModelsAdmin *RepositoryMock) ListModelsAdmin(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListModelsAdmin.beforeListModelsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelsAdmin.afterListModelsAdminCounter, 1)

	if mmListModelsAdmin.inspectFuncListModelsAdmin != nil {
		mmListModelsAdmin.inspectFuncListModelsAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	}

	mm_params := RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}

	// Record call args
	mmListModelsAdmin.ListModelsAdminMock.mutex.Lock()
	mmListModelsAdmin.ListModelsAdminMock.callArgs = append(mmListModelsAdmin.ListModelsAdminMock.callArgs, &mm_params)
	mmListModelsAdmin.ListModelsAdminMock.mutex.Unlock()

	for _, e := range mmListModelsAdmin.ListModelsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListModelsAdmin.ListModelsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelsAdmin.t.Fatal("No results are set for the RepositoryMock.ListModelsAdmin")
		}
		return (*mm_results).mpa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListModelsAdmin.funcListModelsAdmin != nil {
		return mmListModelsAdmin.funcListModelsAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	}
	mmListModelsAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListModelsAdmin. %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	return
}

// ListModelsAdminAfterCounter returns a count of finished RepositoryMock.ListModelsAdmin invocations
func (mmListModelsAdmin *RepositoryMock) ListModelsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelsAdmin.afterListModelsAdminCounter)
}

// ListModelsAdminBeforeCounter returns a count of RepositoryMock.ListModelsAdmin invocations
func (mmListModelsAdmin *RepositoryMock) ListModelsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelsAdmin.beforeListModelsAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Calls() []*RepositoryMockListModelsAdminParams {
	mmListModelsAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelsAdminParams, len(mmListModelsAdmin.callArgs))
	copy(argCopy, mmListModelsAdmin.callArgs)

	mmListModelsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListModelsAdminDone returns true if the count of the ListModelsAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelsAdminDone() bool {
	if m.ListModelsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelsAdminMock.invocationsDone()
}

// MinimockListModelsAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelsAdminInspect() {
	for _, e := range m.ListModelsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin with params: %#v", *e.params)
		}
	}

	afterListModelsAdminCounter := mm_atomic.LoadUint64(&m.afterListModelsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelsAdminMock.defaultExpectation != nil && afterListModelsAdminCounter < 1 {
		if m.ListModelsAdminMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListModelsAdmin")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin with params: %#v", *m.ListModelsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelsAdmin != nil && afterListModelsAdminCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListModelsAdmin")
	}

	if !m.ListModelsAdminMock.invocationsDone() && afterListModelsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelsAdmin but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelsAdminMock.expectedInvocations), afterListModelsAdminCounter)
	}
}

type mRepositoryMockListNamespaceModels struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceModelsExpectation
	expectations       []*RepositoryMockListNamespaceModelsExpectation

	callArgs []*RepositoryMockListNamespaceModelsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockListNamespaceModelsExpectation specifies expectation struct of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockListNamespaceModelsParams
	paramPtrs *RepositoryMockListNamespaceModelsParamPtrs
	results   *RepositoryMockListNamespaceModelsResults
	Counter   uint64
}

// RepositoryMockListNamespaceModelsParams contains parameters of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	uidAllowList   []uuid.UUID
	showDeleted    bool
	order          ordering.OrderBy
	visibility     *modelpb.Model_Visibility
}

// RepositoryMockListNamespaceModelsParamPtrs contains pointers to parameters of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	uidAllowList   *[]uuid.UUID
	showDeleted    *bool
	order          *ordering.OrderBy
	visibility     **modelpb.Model_Visibility
}

// RepositoryMockListNamespaceModelsResults contains results of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsResults struct {
	models        []*datamodel.Model
	totalSize     int64
	nextPageToken string
	err           error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Optional() *mRepositoryMockListNamespaceModels {
	mmListNamespaceModels.optional = true
	return mmListNamespaceModels
}

// Expect sets up expected params for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by ExpectParams functions")
	}

	mmListNamespaceModels.defaultExpectation.params = &RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}
	for _, e := range mmListNamespaceModels.expectations {
		if minimock.Equal(e.params, mmListNamespaceModels.defaultExpectation.params) {
			mmListNamespaceModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceModels.defaultExpectation.params)
		}
	}

	return mmListNamespaceModels
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.ctx = &ctx

	return mmListNamespaceModels
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmListNamespaceModels
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.pageSize = &pageSize

	return mmListNamespaceModels
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.pageToken = &pageToken

	return mmListNamespaceModels
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.isBasicView = &isBasicView

	return mmListNamespaceModels
}

// ExpectFilterParam6 sets up expected param filter for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.filter = &filter

	return mmListNamespaceModels
}

// ExpectUidAllowListParam7 sets up expected param uidAllowList for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectUidAllowListParam7(uidAllowList []uuid.UUID) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList

	return mmListNamespaceModels
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.showDeleted = &showDeleted

	return mmListNamespaceModels
}

// ExpectOrderParam9 sets up expected param order for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectOrderParam9(order ordering.OrderBy) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.order = &order

	return mmListNamespaceModels
}

// ExpectVisibilityParam10 sets up expected param visibility for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectVisibilityParam10(visibility *modelpb.Model_Visibility) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.visibility = &visibility

	return mmListNamespaceModels
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceModels")
	}

	mmListNamespaceModels.mock.inspectFuncListNamespaceModels = f

	return mmListNamespaceModels
}

// Return sets up results that will be returned by Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Return(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{mock: mmListNamespaceModels.mock}
	}
	mmListNamespaceModels.defaultExpectation.results = &RepositoryMockListNamespaceModelsResults{models, totalSize, nextPageToken, err}
	return mmListNamespaceModels.mock
}

// Set uses given function f to mock the Repository.ListNamespaceModels method
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)) *RepositoryMock {
	if mmListNamespaceModels.defaultExpectation != nil {
		mmListNamespaceModels.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceModels method")
	}

	if len(mmListNamespaceModels.expectations) > 0 {
		mmListNamespaceModels.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceModels method")
	}

	mmListNamespaceModels.mock.funcListNamespaceModels = f
	return mmListNamespaceModels.mock
}

// When sets expectation for the Repository.ListNamespaceModels which will trigger the result defined by the following
// Then helper
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *RepositoryMockListNamespaceModelsExpectation {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceModelsExpectation{
		mock:   mmListNamespaceModels.mock,
		params: &RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility},
	}
	mmListNamespaceModels.expectations = append(mmListNamespaceModels.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceModels return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceModelsExpectation) Then(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceModelsResults{models, totalSize, nextPageToken, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceModels should be invoked
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Times(n uint64) *mRepositoryMockListNamespaceModels {
	if n == 0 {
		mmListNamespaceModels.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceModels.expectedInvocations, n)
	return mmListNamespaceModels
}

func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) invocationsDone() bool {
	if len(mmListNamespaceModels.expectations) == 0 && mmListNamespaceModels.defaultExpectation == nil && mmListNamespaceModels.mock.funcListNamespaceModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.mock.afterListNamespaceModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceModels implements repository.Repository
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModels(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error) {
	mm_atomic.AddUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter, 1)

	if mmListNamespaceModels.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.inspectFuncListNamespaceModels(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}

	mm_params := RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

	// Record call args
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Lock()
	mmListNamespaceModels.ListNamespaceModelsMock.callArgs = append(mmListNamespaceModels.ListNamespaceModelsMock.callArgs, &mm_params)
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Unlock()

	for _, e := range mmListNamespaceModels.ListNamespaceModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.models, e.results.totalSize, e.results.nextPageToken, e.results.err
		}
	}

	if mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter pageSize, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter pageToken, want: %#v, got: %#v%s\n", *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter isBasicView, want: %#v, got: %#v%s\n", *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter filter, want: %#v, got: %#v%s\n", *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter uidAllowList, want: %#v, got: %#v%s\n", *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter showDeleted, want: %#v, got: %#v%s\n", *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter order, want: %#v, got: %#v%s\n", *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.visibility != nil && !minimock.Equal(*mm_want_ptrs.visibility, mm_got.visibility) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter visibility, want: %#v, got: %#v%s\n", *mm_want_ptrs.visibility, mm_got.visibility, minimock.Diff(*mm_want_ptrs.visibility, mm_got.visibility))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceModels.t.Fatal("No results are set for the RepositoryMock.ListNamespaceModels")
		}
		return (*mm_results).models, (*mm_results).totalSize, (*mm_results).nextPageToken, (*mm_results).err
	}
	if mmListNamespaceModels.funcListNamespaceModels != nil {
		return mmListNamespaceModels.funcListNamespaceModels(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}
	mmListNamespaceModels.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceModels. %v %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	return
}

// ListNamespaceModelsAfterCounter returns a count of finished RepositoryMock.ListNamespaceModels invocations
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter)
}

// ListNamespaceModelsBeforeCounter returns a count of RepositoryMock.ListNamespaceModels invocations
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Calls() []*RepositoryMockListNamespaceModelsParams {
	mmListNamespaceModels.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceModelsParams, len(mmListNamespaceModels.callArgs))
	copy(argCopy, mmListNamespaceModels.callArgs)

	mmListNamespaceModels.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceModelsDone returns true if the count of the ListNamespaceModels invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceModelsDone() bool {
	if m.ListNamespaceModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceModelsMock.invocationsDone()
}

// MinimockListNamespaceModelsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceModelsInspect() {
	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels with params: %#v", *e.params)
		}
	}

	afterListNamespaceModelsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceModelsMock.defaultExpectation != nil && afterListNamespaceModelsCounter < 1 {
		if m.ListNamespaceModelsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListNamespaceModels")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels with params: %#v", *m.ListNamespaceModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceModels != nil && afterListNamespaceModelsCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.ListNamespaceModels")
	}

	if !m.ListNamespaceModelsMock.invocationsDone() && afterListNamespaceModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceModels but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceModelsMock.expectedInvocations), afterListNamespaceModelsCounter)
	}
}

type mRepositoryMockPinUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPinUserExpectation
	expectations       []*RepositoryMockPinUserExpectation

	callArgs []*RepositoryMockPinUserParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockPinUserExpectation specifies expectation struct of the Repository.PinUser
type RepositoryMockPinUserExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockPinUserParams
	paramPtrs *RepositoryMockPinUserParamPtrs

	Counter uint64
}

// RepositoryMockPinUserParams contains parameters of the Repository.PinUser
type RepositoryMockPinUserParams struct {
	ctx   context.Context
	table string
}

// RepositoryMockPinUserParamPtrs contains pointers to parameters of the Repository.PinUser
type RepositoryMockPinUserParamPtrs struct {
	ctx   *context.Context
	table *string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPinUser *mRepositoryMockPinUser) Optional() *mRepositoryMockPinUser {
	mmPinUser.optional = true
	return mmPinUser
}

// Expect sets up expected params for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Expect(ctx context.Context, table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.paramPtrs != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by ExpectParams functions")
	}

	mmPinUser.defaultExpectation.params = &RepositoryMockPinUserParams{ctx, table}
	for _, e := range mmPinUser.expectations {
		if minimock.Equal(e.params, mmPinUser.defaultExpectation.params) {
			mmPinUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPinUser.defaultExpectation.params)
		}
	}

	return mmPinUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPinUser
}

// ExpectTableParam2 sets up expected param table for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectTableParam2(table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.table = &table

	return mmPinUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Inspect(f func(ctx context.Context, table string)) *mRepositoryMockPinUser {
	if mmPinUser.mock.inspectFuncPinUser != nil {
		mmPinUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.PinUser")
	}

	mmPinUser.mock.inspectFuncPinUser = f

	return mmPinUser
}

// Return sets up results that will be returned by Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Return() *RepositoryMock {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{mock: mmPinUser.mock}
	}

	return mmPinUser.mock
}

// Set uses given function f to mock the Repository.PinUser method
func (mmPinUser *mRepositoryMockPinUser) Set(f func(ctx context.Context, table string)) *RepositoryMock {
	if mmPinUser.defaultExpectation != nil {
		mmPinUser.mock.t.Fatalf("Default expectation is already set for the Repository.PinUser method")
	}

	if len(mmPinUser.expectations) > 0 {
		mmPinUser.mock.t.Fatalf("Some expectations are already set for the Repository.PinUser method")
	}

	mmPinUser.mock.funcPinUser = f
	return mmPinUser.mock
}

// Times sets number of times Repository.PinUser should be invoked
func (mmPinUser *mRepositoryMockPinUser) Times(n uint64) *mRepositoryMockPinUser {
	if n == 0 {
		mmPinUser.mock.t.Fatalf("Times of RepositoryMock.PinUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPinUser.expectedInvocations, n)
	return mmPinUser
}

func (mmPinUser *mRepositoryMockPinUser) invocationsDone() bool {
	if len(mmPinUser.expectations) == 0 && mmPinUser.defaultExpectation == nil && mmPinUser.mock.funcPinUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPinUser.mock.afterPinUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPinUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PinUser implements repository.Repository
func (mmPinUser *RepositoryMock) PinUser(ctx context.Context, table string) {
	mm_atomic.AddUint64(&mmPinUser.beforePinUserCounter, 1)
	defer mm_atomic.AddUint64(&mmPinUser.afterPinUserCounter, 1)

	if mmPinUser.inspectFuncPinUser != nil {
		mmPinUser.inspectFuncPinUser(ctx, table)
	}

	mm_params := RepositoryMockPinUserParams{ctx, table}

	// Record call args
	mmPinUser.PinUserMock.mutex.Lock()
	mmPinUser.PinUserMock.callArgs = append(mmPinUser.PinUserMock.callArgs, &mm_params)
	mmPinUser.PinUserMock.mutex.Unlock()

	for _, e := range mmPinUser.PinUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPinUser.PinUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPinUser.PinUserMock.defaultExpectation.Counter, 1)
		mm_want := mmPinUser.PinUserMock.defaultExpectation.params
		mm_want_ptrs := mmPinUser.PinUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockPinUserParams{ctx, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter table, want: %#v, got: %#v%s\n", *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPinUser.funcPinUser != nil {
		mmPinUser.funcPinUser(ctx, table)
		return
	}
	mmPinUser.t.Fatalf("Unexpected call to RepositoryMock.PinUser. %v %v", ctx, table)

}

// PinUserAfterCounter returns a count of finished RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.afterPinUserCounter)
}

// PinUserBeforeCounter returns a count of RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.beforePinUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.PinUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPinUser *mRepositoryMockPinUser) Calls() []*RepositoryMockPinUserParams {
	mmPinUser.mutex.RLock()

	argCopy := make([]*RepositoryMockPinUserParams, len(mmPinUser.callArgs))
	copy(argCopy, mmPinUser.callArgs)

	mmPinUser.mutex.RUnlock()

	return argCopy
}

// MinimockPinUserDone returns true if the count of the PinUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPinUserDone() bool {
	if m.PinUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PinUserMock.invocationsDone()
}

// MinimockPinUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPinUserInspect() {
	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.PinUser with params: %#v", *e.params)
		}
	}

	afterPinUserCounter := mm_atomic.LoadUint64(&m.afterPinUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PinUserMock.defaultExpectation != nil && afterPinUserCounter < 1 {
		if m.PinUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.PinUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.PinUser with params: %#v", *m.PinUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinUser != nil && afterPinUserCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.PinUser")
	}

	if !m.PinUserMock.invocationsDone() && afterPinUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.PinUser but found %d calls",
			mm_atomic.LoadUint64(&m.PinUserMock.expectedInvocations), afterPinUserCounter)
	}
}

type mRepositoryMockUpdateModelRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateModelRunExpectation
	expectations       []*RepositoryMockUpdateModelRunExpectation

	callArgs []*RepositoryMockUpdateModelRunParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateModelRunExpectation specifies expectation struct of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateModelRunParams
	paramPtrs *RepositoryMockUpdateModelRunParamPtrs
	results   *RepositoryMockUpdateModelRunResults
	Counter   uint64
}

// RepositoryMockUpdateModelRunParams contains parameters of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunParams struct {
	ctx      context.Context
	modelRun *datamodel.ModelRun
}

// RepositoryMockUpdateModelRunParamPtrs contains pointers to parameters of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunParamPtrs struct {
	ctx      *context.Context
	modelRun **datamodel.ModelRun
}

// RepositoryMockUpdateModelRunResults contains results of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Optional() *mRepositoryMockUpdateModelRun {
	mmUpdateModelRun.optional = true
	return mmUpdateModelRun
}

// Expect sets up expected params for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Expect(ctx context.Context, modelRun *datamodel.ModelRun) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by ExpectParams functions")
	}

	mmUpdateModelRun.defaultExpectation.params = &RepositoryMockUpdateModelRunParams{ctx, modelRun}
	for _, e := range mmUpdateModelRun.expectations {
		if minimock.Equal(e.params, mmUpdateModelRun.defaultExpectation.params) {
			mmUpdateModelRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateModelRun.defaultExpectation.params)
		}
	}

	return mmUpdateModelRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.params != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Expect")
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs == nil {
		mmUpdateModelRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelRunParamPtrs{}
	}
	mmUpdateModelRun.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateModelRun
}

// ExpectModelRunParam2 sets up expected param modelRun for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) ExpectModelRunParam2(modelRun *datamodel.ModelRun) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.params != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Expect")
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs == nil {
		mmUpdateModelRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelRunParamPtrs{}
	}
	mmUpdateModelRun.defaultExpectation.paramPtrs.modelRun = &modelRun

	return mmUpdateModelRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Inspect(f func(ctx context.Context, modelRun *datamodel.ModelRun)) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.inspectFuncUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateModelRun")
	}

	mmUpdateModelRun.mock.inspectFuncUpdateModelRun = f

	return mmUpdateModelRun
}

// Return sets up results that will be returned by Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Return(err error) *RepositoryMock {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{mock: mmUpdateModelRun.mock}
	}
	mmUpdateModelRun.defaultExpectation.results = &RepositoryMockUpdateModelRunResults{err}
	return mmUpdateModelRun.mock
}

// Set uses given function f to mock the Repository.UpdateModelRun method
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Set(f func(ctx context.Context, modelRun *datamodel.ModelRun) (err error)) *RepositoryMock {
	if mmUpdateModelRun.defaultExpectation != nil {
		mmUpdateModelRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateModelRun method")
	}

	if len(mmUpdateModelRun.expectations) > 0 {
		mmUpdateModelRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateModelRun method")
	}

	mmUpdateModelRun.mock.funcUpdateModelRun = f
	return mmUpdateModelRun.mock
}

// When sets expectation for the Repository.UpdateModelRun which will trigger the result defined by the following
// Then helper
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) When(ctx context.Context, modelRun *datamodel.ModelRun) *RepositoryMockUpdateModelRunExpectation {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateModelRunExpectation{
		mock:   mmUpdateModelRun.mock,
		params: &RepositoryMockUpdateModelRunParams{ctx, modelRun},
	}
	mmUpdateModelRun.expectations = append(mmUpdateModelRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateModelRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateModelRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateModelRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateModelRun should be invoked
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Times(n uint64) *mRepositoryMockUpdateModelRun {
	if n == 0 {
		mmUpdateModelRun.mock.t.Fatalf("Times of RepositoryMock.UpdateModelRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateModelRun.expectedInvocations, n)
	return mmUpdateModelRun
}

func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) invocationsDone() bool {
	if len(mmUpdateModelRun.expectations) == 0 && mmUpdateModelRun.defaultExpectation == nil && mmUpdateModelRun.mock.funcUpdateModelRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateModelRun.mock.afterUpdateModelRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateModelRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateModelRun implements repository.Repository
func (mmUpdateModelRun *RepositoryMock) UpdateModelRun(ctx context.Context, modelRun *datamodel.ModelRun) (err error) {
	mm_atomic.AddUint64(&mmUpdateModelRun.beforeUpdateModelRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateModelRun.afterUpdateModelRunCounter, 1)

	if mmUpdateModelRun.inspectFuncUpdateModelRun != nil {
		mmUpdateModelRun.inspectFuncUpdateModelRun(ctx, modelRun)
	}

	mm_params := RepositoryMockUpdateModelRunParams{ctx, modelRun}

	// Record call args
	mmUpdateModelRun.UpdateModelRunMock.mutex.Lock()
	mmUpdateModelRun.UpdateModelRunMock.callArgs = append(mmUpdateModelRun.UpdateModelRunMock.callArgs, &mm_params)
	mmUpdateModelRun.UpdateModelRunMock.mutex.Unlock()

	for _, e := range mmUpdateModelRun.UpdateModelRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateModelRun.UpdateModelRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateModelRunParams{ctx, modelRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelRun != nil && !minimock.Equal(*mm_want_ptrs.modelRun, mm_got.modelRun) {
				mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameter modelRun, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelRun, mm_got.modelRun, minimock.Diff(*mm_want_ptrs.modelRun, mm_got.modelRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateModelRun.t.Fatal("No results are set for the RepositoryMock.UpdateModelRun")
		}
		return (*mm_results).err
	}
	if mmUpdateModelRun.funcUpdateModelRun != nil {
		return mmUpdateModelRun.funcUpdateModelRun(ctx, modelRun)
	}
	mmUpdateModelRun.t.Fatalf("Unexpected call to RepositoryMock.UpdateModelRun. %v %v", ctx, modelRun)
	return
}

// UpdateModelRunAfterCounter returns a count of finished RepositoryMock.UpdateModelRun invocations
func (mmUpdateModelRun *RepositoryMock) UpdateModelRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelRun.afterUpdateModelRunCounter)
}

// UpdateModelRunBeforeCounter returns a count of RepositoryMock.UpdateModelRun invocations
func (mmUpdateModelRun *RepositoryMock) UpdateModelRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelRun.beforeUpdateModelRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateModelRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Calls() []*RepositoryMockUpdateModelRunParams {
	mmUpdateModelRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateModelRunParams, len(mmUpdateModelRun.callArgs))
	copy(argCopy, mmUpdateModelRun.callArgs)

	mmUpdateModelRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateModelRunDone returns true if the count of the UpdateModelRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateModelRunDone() bool {
	if m.UpdateModelRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateModelRunMock.invocationsDone()
}

// MinimockUpdateModelRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateModelRunInspect() {
	for _, e := range m.UpdateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun with params: %#v", *e.params)
		}
	}

	afterUpdateModelRunCounter := mm_atomic.LoadUint64(&m.afterUpdateModelRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateModelRunMock.defaultExpectation != nil && afterUpdateModelRunCounter < 1 {
		if m.UpdateModelRunMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateModelRun")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun with params: %#v", *m.UpdateModelRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateModelRun != nil && afterUpdateModelRunCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateModelRun")
	}

	if !m.UpdateModelRunMock.invocationsDone() && afterUpdateModelRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateModelRun but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateModelRunMock.expectedInvocations), afterUpdateModelRunCounter)
	}
}

type mRepositoryMockUpdateModelVersionDigestByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateModelVersionDigestByIDExpectation
	expectations       []*RepositoryMockUpdateModelVersionDigestByIDExpectation

	callArgs []*RepositoryMockUpdateModelVersionDigestByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateModelVersionDigestByIDExpectation specifies expectation struct of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateModelVersionDigestByIDParams
	paramPtrs *RepositoryMockUpdateModelVersionDigestByIDParamPtrs
	results   *RepositoryMockUpdateModelVersionDigestByIDResults
	Counter   uint64
}

// RepositoryMockUpdateModelVersionDigestByIDParams contains parameters of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
	digest    string
}

// RepositoryMockUpdateModelVersionDigestByIDParamPtrs contains pointers to parameters of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
	digest    *string
}

// RepositoryMockUpdateModelVersionDigestByIDResults contains results of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Optional() *mRepositoryMockUpdateModelVersionDigestByID {
	mmUpdateModelVersionDigestByID.optional = true
	return mmUpdateModelVersionDigestByID
}

// Expect sets up expected params for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by ExpectParams functions")
	}

	mmUpdateModelVersionDigestByID.defaultExpectation.params = &RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}
	for _, e := range mmUpdateModelVersionDigestByID.expectations {
		if minimock.Equal(e.params, mmUpdateModelVersionDigestByID.defaultExpectation.params) {
			mmUpdateModelVersionDigestByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateModelVersionDigestByID.defaultExpectation.params)
		}
	}

	return mmUpdateModelVersionDigestByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateModelVersionDigestByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.modelUID = &modelUID

	return mmUpdateModelVersionDigestByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.versionID = &versionID

	return mmUpdateModelVersionDigestByID
}

// ExpectDigestParam4 sets up expected param digest for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectDigestParam4(digest string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.digest = &digest

	return mmUpdateModelVersionDigestByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string)) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.inspectFuncUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateModelVersionDigestByID")
	}

	mmUpdateModelVersionDigestByID.mock.inspectFuncUpdateModelVersionDigestByID = f

	return mmUpdateModelVersionDigestByID
}

// Return sets up results that will be returned by Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Return(err error) *RepositoryMock {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{mock: mmUpdateModelVersionDigestByID.mock}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.results = &RepositoryMockUpdateModelVersionDigestByIDResults{err}
	return mmUpdateModelVersionDigestByID.mock
}

// Set uses given function f to mock the Repository.UpdateModelVersionDigestByID method
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error)) *RepositoryMock {
	if mmUpdateModelVersionDigestByID.defaultExpectation != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateModelVersionDigestByID method")
	}

	if len(mmUpdateModelVersionDigestByID.expectations) > 0 {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateModelVersionDigestByID method")
	}

	mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID = f
	return mmUpdateModelVersionDigestByID.mock
}

// When sets expectation for the Repository.UpdateModelVersionDigestByID which will trigger the result defined by the following
// Then helper
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) When(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) *RepositoryMockUpdateModelVersionDigestByIDExpectation {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateModelVersionDigestByIDExpectation{
		mock:   mmUpdateModelVersionDigestByID.mock,
		params: &RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest},
	}
	mmUpdateModelVersionDigestByID.expectations = append(mmUpdateModelVersionDigestByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateModelVersionDigestByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateModelVersionDigestByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateModelVersionDigestByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateModelVersionDigestByID should be invoked
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Times(n uint64) *mRepositoryMockUpdateModelVersionDigestByID {
	if n == 0 {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Times of RepositoryMock.UpdateModelVersionDigestByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateModelVersionDigestByID.expectedInvocations, n)
	return mmUpdateModelVersionDigestByID
}

func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) invocationsDone() bool {
	if len(mmUpdateModelVersionDigestByID.expectations) == 0 && mmUpdateModelVersionDigestByID.defaultExpectation == nil && mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.mock.afterUpdateModelVersionDigestByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateModelVersionDigestByID implements repository.Repository
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByID(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error) {
	mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.beforeUpdateModelVersionDigestByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.afterUpdateModelVersionDigestByIDCounter, 1)

	if mmUpdateModelVersionDigestByID.inspectFuncUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.inspectFuncUpdateModelVersionDigestByID(ctx, modelUID, versionID, digest)
	}

	mm_params := RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}

	// Record call args
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.mutex.Lock()
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.callArgs = append(mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.callArgs, &mm_params)
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.mutex.Unlock()

	for _, e := range mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter modelUID, want: %#v, got: %#v%s\n", *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter versionID, want: %#v, got: %#v%s\n", *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter digest, want: %#v, got: %#v%s\n", *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateModelVersionDigestByID.t.Fatal("No results are set for the RepositoryMock.UpdateModelVersionDigestByID")
		}
		return (*mm_results).err
	}
	if mmUpdateModelVersionDigestByID.funcUpdateModelVersionDigestByID != nil {
		return mmUpdateModelVersionDigestByID.funcUpdateModelVersionDigestByID(ctx, modelUID, versionID, digest)
	}
	mmUpdateModelVersionDigestByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateModelVersionDigestByID. %v %v %v %v", ctx, modelUID, versionID, digest)
	return
}

// UpdateModelVersionDigestByIDAfterCounter returns a count of finished RepositoryMock.UpdateModelVersionDigestByID invocations
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.afterUpdateModelVersionDigestByIDCounter)
}

// UpdateModelVersionDigestByIDBeforeCounter returns a count of RepositoryMock.UpdateModelVersionDigestByID invocations
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.beforeUpdateModelVersionDigestByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateModelVersionDigestByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Calls() []*RepositoryMockUpdateModelVersionDigestByIDParams {
	mmUpdateModelVersionDigestByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateModelVersionDigestByIDParams, len(mmUpdateModelVersionDigestByID.callArgs))
	copy(argCopy, mmUpdateModelVersionDigestByID.callArgs)

	mmUpdateModelVersionDigestByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateModelVersionDigestByIDDone returns true if the count of the UpdateModelVersionDigestByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateModelVersionDigestByIDDone() bool {
	if m.UpdateModelVersionDigestByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateModelVersionDigestByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateModelVersionDigestByIDMock.invocationsDone()
}

// MinimockUpdateModelVersionDigestByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateModelVersionDigestByIDInspect() {
	for _, e := range m.UpdateModelVersionDigestByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID with params: %#v", *e.params)
		}
	}

	afterUpdateModelVersionDigestByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateModelVersionDigestByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateModelVersionDigestByIDMock.defaultExpectation != nil && afterUpdateModelVersionDigestByIDCounter < 1 {
		if m.UpdateModelVersionDigestByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateModelVersionDigestByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID with params: %#v", *m.UpdateModelVersionDigestByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateModelVersionDigestByID != nil && afterUpdateModelVersionDigestByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateModelVersionDigestByID")
	}

	if !m.UpdateModelVersionDigestByIDMock.invocationsDone() && afterUpdateModelVersionDigestByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateModelVersionDigestByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateModelVersionDigestByIDMock.expectedInvocations), afterUpdateModelVersionDigestByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceModelByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceModelByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespaceModelByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespaceModelByIDParams
	paramPtrs *RepositoryMockUpdateNamespaceModelByIDParamPtrs
	results   *RepositoryMockUpdateNamespaceModelByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespaceModelByIDParams contains parameters of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	model          *datamodel.Model
}

// RepositoryMockUpdateNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	model          **datamodel.Model
}

// RepositoryMockUpdateNamespaceModelByIDResults contains results of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Optional() *mRepositoryMockUpdateNamespaceModelByID {
	mmUpdateNamespaceModelByID.optional = true
	return mmUpdateNamespaceModelByID
}

// Expect sets up expected params for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceModelByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}
	for _, e := range mmUpdateNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceModelByID.defaultExpectation.params) {
			mmUpdateNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespaceModelByID
}

// ExpectModelParam4 sets up expected param model for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectModelParam4(model *datamodel.Model) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.model = &model

	return mmUpdateNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model)) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.inspectFuncUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceModelByID")
	}

	mmUpdateNamespaceModelByID.mock.inspectFuncUpdateNamespaceModelByID = f

	return mmUpdateNamespaceModelByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{mock: mmUpdateNamespaceModelByID.mock}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceModelByIDResults{err}
	return mmUpdateNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceModelByID method
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error)) *RepositoryMock {
	if mmUpdateNamespaceModelByID.defaultExpectation != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceModelByID method")
	}

	if len(mmUpdateNamespaceModelByID.expectations) > 0 {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceModelByID method")
	}

	mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID = f
	return mmUpdateNamespaceModelByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) *RepositoryMockUpdateNamespaceModelByIDExpectation {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceModelByIDExpectation{
		mock:   mmUpdateNamespaceModelByID.mock,
		params: &RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model},
	}
	mmUpdateNamespaceModelByID.expectations = append(mmUpdateNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceModelByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceModelByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceModelByID should be invoked
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Times(n uint64) *mRepositoryMockUpdateNamespaceModelByID {
	if n == 0 {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceModelByID.expectedInvocations, n)
	return mmUpdateNamespaceModelByID
}

func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) invocationsDone() bool {
	if len(mmUpdateNamespaceModelByID.expectations) == 0 && mmUpdateNamespaceModelByID.defaultExpectation == nil && mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.mock.afterUpdateNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceModelByID implements repository.Repository
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByID(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.beforeUpdateNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.afterUpdateNamespaceModelByIDCounter, 1)

	if mmUpdateNamespaceModelByID.inspectFuncUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.inspectFuncUpdateNamespaceModelByID(ctx, ownerPermalink, id, model)
	}

	mm_params := RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}

	// Record call args
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.mutex.Lock()
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.callArgs = append(mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter model, want: %#v, got: %#v%s\n", *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceModelByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceModelByID.funcUpdateNamespaceModelByID != nil {
		return mmUpdateNamespaceModelByID.funcUpdateNamespaceModelByID(ctx, ownerPermalink, id, model)
	}
	mmUpdateNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceModelByID. %v %v %v %v", ctx, ownerPermalink, id, model)
	return
}

// UpdateNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceModelByID invocations
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.afterUpdateNamespaceModelByIDCounter)
}

// UpdateNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceModelByID invocations
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.beforeUpdateNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Calls() []*RepositoryMockUpdateNamespaceModelByIDParams {
	mmUpdateNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceModelByIDParams, len(mmUpdateNamespaceModelByID.callArgs))
	copy(argCopy, mmUpdateNamespaceModelByID.callArgs)

	mmUpdateNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceModelByIDDone returns true if the count of the UpdateNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceModelByIDDone() bool {
	if m.UpdateNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceModelByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceModelByIDInspect() {
	for _, e := range m.UpdateNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceModelByIDMock.defaultExpectation != nil && afterUpdateNamespaceModelByIDCounter < 1 {
		if m.UpdateNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespaceModelByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID with params: %#v", *m.UpdateNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceModelByID != nil && afterUpdateNamespaceModelByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespaceModelByID")
	}

	if !m.UpdateNamespaceModelByIDMock.invocationsDone() && afterUpdateNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceModelByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceModelByIDMock.expectedInvocations), afterUpdateNamespaceModelByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceModelIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceModelIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceModelIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceModelIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockUpdateNamespaceModelIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockUpdateNamespaceModelIDByIDParams
	paramPtrs *RepositoryMockUpdateNamespaceModelIDByIDParamPtrs
	results   *RepositoryMockUpdateNamespaceModelIDByIDResults
	Counter   uint64
}

// RepositoryMockUpdateNamespaceModelIDByIDParams contains parameters of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	newID          string
}

// RepositoryMockUpdateNamespaceModelIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespaceModelIDByIDResults contains results of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Optional() *mRepositoryMockUpdateNamespaceModelIDByID {
	mmUpdateNamespaceModelIDByID.optional = true
	return mmUpdateNamespaceModelIDByID
}

// Expect sets up expected params for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Expect(ctx context.Context, ownerPermalink string, id string, newID string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceModelIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}
	for _, e := range mmUpdateNamespaceModelIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceModelIDByID.defaultExpectation.params) {
			mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceModelIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceModelIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateNamespaceModelIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink

	return mmUpdateNamespaceModelIDByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.id = &id

	return mmUpdateNamespaceModelIDByID
}

// ExpectNewIDParam4 sets up expected param newID for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectNewIDParam4(newID string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.newID = &newID

	return mmUpdateNamespaceModelIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, newID string)) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.inspectFuncUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceModelIDByID")
	}

	mmUpdateNamespaceModelIDByID.mock.inspectFuncUpdateNamespaceModelIDByID = f

	return mmUpdateNamespaceModelIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{mock: mmUpdateNamespaceModelIDByID.mock}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceModelIDByIDResults{err}
	return mmUpdateNamespaceModelIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceModelIDByID method
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Set(f func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespaceModelIDByID.defaultExpectation != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceModelIDByID method")
	}

	if len(mmUpdateNamespaceModelIDByID.expectations) > 0 {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceModelIDByID method")
	}

	mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID = f
	return mmUpdateNamespaceModelIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceModelIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) When(ctx context.Context, ownerPermalink string, id string, newID string) *RepositoryMockUpdateNamespaceModelIDByIDExpectation {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceModelIDByIDExpectation{
		mock:   mmUpdateNamespaceModelIDByID.mock,
		params: &RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID},
	}
	mmUpdateNamespaceModelIDByID.expectations = append(mmUpdateNamespaceModelIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceModelIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceModelIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceModelIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceModelIDByID should be invoked
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Times(n uint64) *mRepositoryMockUpdateNamespaceModelIDByID {
	if n == 0 {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceModelIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceModelIDByID.expectedInvocations, n)
	return mmUpdateNamespaceModelIDByID
}

func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) invocationsDone() bool {
	if len(mmUpdateNamespaceModelIDByID.expectations) == 0 && mmUpdateNamespaceModelIDByID.defaultExpectation == nil && mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.mock.afterUpdateNamespaceModelIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceModelIDByID implements repository.Repository
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByID(ctx context.Context, ownerPermalink string, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.beforeUpdateNamespaceModelIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.afterUpdateNamespaceModelIDByIDCounter, 1)

	if mmUpdateNamespaceModelIDByID.inspectFuncUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.inspectFuncUpdateNamespaceModelIDByID(ctx, ownerPermalink, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}

	// Record call args
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.mutex.Lock()
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.callArgs = append(mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter ownerPermalink, want: %#v, got: %#v%s\n", *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter newID, want: %#v, got: %#v%s\n", *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceModelIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceModelIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceModelIDByID.funcUpdateNamespaceModelIDByID != nil {
		return mmUpdateNamespaceModelIDByID.funcUpdateNamespaceModelIDByID(ctx, ownerPermalink, id, newID)
	}
	mmUpdateNamespaceModelIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceModelIDByID. %v %v %v %v", ctx, ownerPermalink, id, newID)
	return
}

// UpdateNamespaceModelIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceModelIDByID invocations
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.afterUpdateNamespaceModelIDByIDCounter)
}

// UpdateNamespaceModelIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceModelIDByID invocations
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.beforeUpdateNamespaceModelIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceModelIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Calls() []*RepositoryMockUpdateNamespaceModelIDByIDParams {
	mmUpdateNamespaceModelIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceModelIDByIDParams, len(mmUpdateNamespaceModelIDByID.callArgs))
	copy(argCopy, mmUpdateNamespaceModelIDByID.callArgs)

	mmUpdateNamespaceModelIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceModelIDByIDDone returns true if the count of the UpdateNamespaceModelIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceModelIDByIDDone() bool {
	if m.UpdateNamespaceModelIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceModelIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceModelIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceModelIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceModelIDByIDInspect() {
	for _, e := range m.UpdateNamespaceModelIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID with params: %#v", *e.params)
		}
	}

	afterUpdateNamespaceModelIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceModelIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceModelIDByIDMock.defaultExpectation != nil && afterUpdateNamespaceModelIDByIDCounter < 1 {
		if m.UpdateNamespaceModelIDByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.UpdateNamespaceModelIDByID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID with params: %#v", *m.UpdateNamespaceModelIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceModelIDByID != nil && afterUpdateNamespaceModelIDByIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.UpdateNamespaceModelIDByID")
	}

	if !m.UpdateNamespaceModelIDByIDMock.invocationsDone() && afterUpdateNamespaceModelIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceModelIDByID but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceModelIDByIDMock.expectedInvocations), afterUpdateNamespaceModelIDByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPinnedUserInspect()

			m.MinimockCreateModelRunInspect()

			m.MinimockCreateModelTagsInspect()

			m.MinimockCreateModelVersionInspect()

			m.MinimockCreateNamespaceModelInspect()

			m.MinimockDeleteModelTagsInspect()

			m.MinimockDeleteModelVersionByDigestInspect()

			m.MinimockDeleteModelVersionByIDInspect()

			m.MinimockDeleteNamespaceModelByIDInspect()

			m.MinimockGetLatestModelRunByModelUIDInspect()

			m.MinimockGetLatestModelVersionByModelUIDInspect()

			m.MinimockGetLatestModelVersionRunByModelUIDInspect()

			m.MinimockGetModelByUIDInspect()

			m.MinimockGetModelByUIDAdminInspect()

			m.MinimockGetModelDefinitionInspect()

			m.MinimockGetModelDefinitionByUIDInspect()

			m.MinimockGetModelRunByUIDInspect()

			m.MinimockGetModelVersionByIDInspect()

			m.MinimockGetNamespaceModelByIDInspect()

			m.MinimockListModelDefinitionsInspect()

			m.MinimockListModelRunsInspect()

			m.MinimockListModelTagsInspect()

			m.MinimockListModelVersionsInspect()

			m.MinimockListModelVersionsByDigestInspect()

			m.MinimockListModelsInspect()

			m.MinimockListModelsAdminInspect()

			m.MinimockListNamespaceModelsInspect()

			m.MinimockPinUserInspect()

			m.MinimockUpdateModelRunInspect()

			m.MinimockUpdateModelVersionDigestByIDInspect()

			m.MinimockUpdateNamespaceModelByIDInspect()

			m.MinimockUpdateNamespaceModelIDByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPinnedUserDone() &&
		m.MinimockCreateModelRunDone() &&
		m.MinimockCreateModelTagsDone() &&
		m.MinimockCreateModelVersionDone() &&
		m.MinimockCreateNamespaceModelDone() &&
		m.MinimockDeleteModelTagsDone() &&
		m.MinimockDeleteModelVersionByDigestDone() &&
		m.MinimockDeleteModelVersionByIDDone() &&
		m.MinimockDeleteNamespaceModelByIDDone() &&
		m.MinimockGetLatestModelRunByModelUIDDone() &&
		m.MinimockGetLatestModelVersionByModelUIDDone() &&
		m.MinimockGetLatestModelVersionRunByModelUIDDone() &&
		m.MinimockGetModelByUIDDone() &&
		m.MinimockGetModelByUIDAdminDone() &&
		m.MinimockGetModelDefinitionDone() &&
		m.MinimockGetModelDefinitionByUIDDone() &&
		m.MinimockGetModelRunByUIDDone() &&
		m.MinimockGetModelVersionByIDDone() &&
		m.MinimockGetNamespaceModelByIDDone() &&
		m.MinimockListModelDefinitionsDone() &&
		m.MinimockListModelRunsDone() &&
		m.MinimockListModelTagsDone() &&
		m.MinimockListModelVersionsDone() &&
		m.MinimockListModelVersionsByDigestDone() &&
		m.MinimockListModelsDone() &&
		m.MinimockListModelsAdminDone() &&
		m.MinimockListNamespaceModelsDone() &&
		m.MinimockPinUserDone() &&
		m.MinimockUpdateModelRunDone() &&
		m.MinimockUpdateModelVersionDigestByIDDone() &&
		m.MinimockUpdateNamespaceModelByIDDone() &&
		m.MinimockUpdateNamespaceModelIDByIDDone()
}
