// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/model-backend/pkg/datamodel"
	mm_repository "github.com/instill-ai/model-backend/pkg/repository"
	"github.com/instill-ai/model-backend/pkg/utils"
	modelpb "github.com/instill-ai/protogen-go/model/v1alpha"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"gorm.io/gorm"
)

// RepositoryMock implements mm_repository.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPinnedUser          func(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB)
	funcCheckPinnedUserOrigin    string
	inspectFuncCheckPinnedUser   func(ctx context.Context, db *gorm.DB, table string)
	afterCheckPinnedUserCounter  uint64
	beforeCheckPinnedUserCounter uint64
	CheckPinnedUserMock          mRepositoryMockCheckPinnedUser

	funcCreateModelRun          func(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error)
	funcCreateModelRunOrigin    string
	inspectFuncCreateModelRun   func(ctx context.Context, modelRun *datamodel.ModelRun)
	afterCreateModelRunCounter  uint64
	beforeCreateModelRunCounter uint64
	CreateModelRunMock          mRepositoryMockCreateModelRun

	funcCreateModelTags          func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)
	funcCreateModelTagsOrigin    string
	inspectFuncCreateModelTags   func(ctx context.Context, modelUID uuid.UUID, tagNames []string)
	afterCreateModelTagsCounter  uint64
	beforeCreateModelTagsCounter uint64
	CreateModelTagsMock          mRepositoryMockCreateModelTags

	funcCreateModelVersion          func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error)
	funcCreateModelVersionOrigin    string
	inspectFuncCreateModelVersion   func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion)
	afterCreateModelVersionCounter  uint64
	beforeCreateModelVersionCounter uint64
	CreateModelVersionMock          mRepositoryMockCreateModelVersion

	funcCreateNamespaceModel          func(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error)
	funcCreateNamespaceModelOrigin    string
	inspectFuncCreateNamespaceModel   func(ctx context.Context, ownerPermalink string, model *datamodel.Model)
	afterCreateNamespaceModelCounter  uint64
	beforeCreateNamespaceModelCounter uint64
	CreateNamespaceModelMock          mRepositoryMockCreateNamespaceModel

	funcDeleteModelTags          func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)
	funcDeleteModelTagsOrigin    string
	inspectFuncDeleteModelTags   func(ctx context.Context, modelUID uuid.UUID, tagNames []string)
	afterDeleteModelTagsCounter  uint64
	beforeDeleteModelTagsCounter uint64
	DeleteModelTagsMock          mRepositoryMockDeleteModelTags

	funcDeleteModelVersionByDigest          func(ctx context.Context, modelUID uuid.UUID, digest string) (err error)
	funcDeleteModelVersionByDigestOrigin    string
	inspectFuncDeleteModelVersionByDigest   func(ctx context.Context, modelUID uuid.UUID, digest string)
	afterDeleteModelVersionByDigestCounter  uint64
	beforeDeleteModelVersionByDigestCounter uint64
	DeleteModelVersionByDigestMock          mRepositoryMockDeleteModelVersionByDigest

	funcDeleteModelVersionByID          func(ctx context.Context, modelUID uuid.UUID, versionID string) (err error)
	funcDeleteModelVersionByIDOrigin    string
	inspectFuncDeleteModelVersionByID   func(ctx context.Context, modelUID uuid.UUID, versionID string)
	afterDeleteModelVersionByIDCounter  uint64
	beforeDeleteModelVersionByIDCounter uint64
	DeleteModelVersionByIDMock          mRepositoryMockDeleteModelVersionByID

	funcDeleteNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string) (err error)
	funcDeleteNamespaceModelByIDOrigin    string
	inspectFuncDeleteNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string)
	afterDeleteNamespaceModelByIDCounter  uint64
	beforeDeleteNamespaceModelByIDCounter uint64
	DeleteNamespaceModelByIDMock          mRepositoryMockDeleteNamespaceModelByID

	funcDeleteRepositoryTag          func(ctx context.Context, digest string) (err error)
	funcDeleteRepositoryTagOrigin    string
	inspectFuncDeleteRepositoryTag   func(ctx context.Context, digest string)
	afterDeleteRepositoryTagCounter  uint64
	beforeDeleteRepositoryTagCounter uint64
	DeleteRepositoryTagMock          mRepositoryMockDeleteRepositoryTag

	funcGetLatestModelRunByModelUID          func(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error)
	funcGetLatestModelRunByModelUIDOrigin    string
	inspectFuncGetLatestModelRunByModelUID   func(ctx context.Context, userUID string, modelUID string)
	afterGetLatestModelRunByModelUIDCounter  uint64
	beforeGetLatestModelRunByModelUIDCounter uint64
	GetLatestModelRunByModelUIDMock          mRepositoryMockGetLatestModelRunByModelUID

	funcGetLatestModelVersionByModelUID          func(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error)
	funcGetLatestModelVersionByModelUIDOrigin    string
	inspectFuncGetLatestModelVersionByModelUID   func(ctx context.Context, modelUID uuid.UUID)
	afterGetLatestModelVersionByModelUIDCounter  uint64
	beforeGetLatestModelVersionByModelUIDCounter uint64
	GetLatestModelVersionByModelUIDMock          mRepositoryMockGetLatestModelVersionByModelUID

	funcGetLatestModelVersionRunByModelUID          func(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error)
	funcGetLatestModelVersionRunByModelUIDOrigin    string
	inspectFuncGetLatestModelVersionRunByModelUID   func(ctx context.Context, userUID string, modelUID string, version string)
	afterGetLatestModelVersionRunByModelUIDCounter  uint64
	beforeGetLatestModelVersionRunByModelUIDCounter uint64
	GetLatestModelVersionRunByModelUIDMock          mRepositoryMockGetLatestModelVersionRunByModelUID

	funcGetModelByUID          func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	funcGetModelByUIDOrigin    string
	inspectFuncGetModelByUID   func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)
	afterGetModelByUIDCounter  uint64
	beforeGetModelByUIDCounter uint64
	GetModelByUIDMock          mRepositoryMockGetModelByUID

	funcGetModelByUIDAdmin          func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	funcGetModelByUIDAdminOrigin    string
	inspectFuncGetModelByUIDAdmin   func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)
	afterGetModelByUIDAdminCounter  uint64
	beforeGetModelByUIDAdminCounter uint64
	GetModelByUIDAdminMock          mRepositoryMockGetModelByUIDAdmin

	funcGetModelDefinition          func(id string) (mp1 *datamodel.ModelDefinition, err error)
	funcGetModelDefinitionOrigin    string
	inspectFuncGetModelDefinition   func(id string)
	afterGetModelDefinitionCounter  uint64
	beforeGetModelDefinitionCounter uint64
	GetModelDefinitionMock          mRepositoryMockGetModelDefinition

	funcGetModelDefinitionByUID          func(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error)
	funcGetModelDefinitionByUIDOrigin    string
	inspectFuncGetModelDefinitionByUID   func(uid uuid.UUID)
	afterGetModelDefinitionByUIDCounter  uint64
	beforeGetModelDefinitionByUIDCounter uint64
	GetModelDefinitionByUIDMock          mRepositoryMockGetModelDefinitionByUID

	funcGetModelRunByUID          func(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error)
	funcGetModelRunByUIDOrigin    string
	inspectFuncGetModelRunByUID   func(ctx context.Context, triggerUID string)
	afterGetModelRunByUIDCounter  uint64
	beforeGetModelRunByUIDCounter uint64
	GetModelRunByUIDMock          mRepositoryMockGetModelRunByUID

	funcGetModelVersionByID          func(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error)
	funcGetModelVersionByIDOrigin    string
	inspectFuncGetModelVersionByID   func(ctx context.Context, modelUID uuid.UUID, versionID string)
	afterGetModelVersionByIDCounter  uint64
	beforeGetModelVersionByIDCounter uint64
	GetModelVersionByIDMock          mRepositoryMockGetModelVersionByID

	funcGetNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)
	funcGetNamespaceModelByIDOrigin    string
	inspectFuncGetNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool)
	afterGetNamespaceModelByIDCounter  uint64
	beforeGetNamespaceModelByIDCounter uint64
	GetNamespaceModelByIDMock          mRepositoryMockGetNamespaceModelByID

	funcGetRepositoryTag          func(ctx context.Context, name utils.RepositoryTagName) (tp1 *datamodel.Tag, err error)
	funcGetRepositoryTagOrigin    string
	inspectFuncGetRepositoryTag   func(ctx context.Context, name utils.RepositoryTagName)
	afterGetRepositoryTagCounter  uint64
	beforeGetRepositoryTagCounter uint64
	GetRepositoryTagMock          mRepositoryMockGetRepositoryTag

	funcListModelDefinitions          func(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error)
	funcListModelDefinitionsOrigin    string
	inspectFuncListModelDefinitions   func(view modelpb.View, pageSize int64, pageToken string)
	afterListModelDefinitionsCounter  uint64
	beforeListModelDefinitionsCounter uint64
	ListModelDefinitionsMock          mRepositoryMockListModelDefinitions

	funcListModelRuns          func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelRuns []*datamodel.ModelRun, totalSize int64, err error)
	funcListModelRunsOrigin    string
	inspectFuncListModelRuns   func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string)
	afterListModelRunsCounter  uint64
	beforeListModelRunsCounter uint64
	ListModelRunsMock          mRepositoryMockListModelRuns

	funcListModelRunsByRequester          func(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error)
	funcListModelRunsByRequesterOrigin    string
	inspectFuncListModelRunsByRequester   func(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams)
	afterListModelRunsByRequesterCounter  uint64
	beforeListModelRunsByRequesterCounter uint64
	ListModelRunsByRequesterMock          mRepositoryMockListModelRunsByRequester

	funcListModelTags          func(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error)
	funcListModelTagsOrigin    string
	inspectFuncListModelTags   func(ctx context.Context, modelUID uuid.UUID)
	afterListModelTagsCounter  uint64
	beforeListModelTagsCounter uint64
	ListModelTagsMock          mRepositoryMockListModelTags

	funcListModelVersions          func(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error)
	funcListModelVersionsOrigin    string
	inspectFuncListModelVersions   func(ctx context.Context, modelUID uuid.UUID, groupDigest bool)
	afterListModelVersionsCounter  uint64
	beforeListModelVersionsCounter uint64
	ListModelVersionsMock          mRepositoryMockListModelVersions

	funcListModelVersionsByDigest          func(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error)
	funcListModelVersionsByDigestOrigin    string
	inspectFuncListModelVersionsByDigest   func(ctx context.Context, modelUID uuid.UUID, digest string)
	afterListModelVersionsByDigestCounter  uint64
	beforeListModelVersionsByDigestCounter uint64
	ListModelVersionsByDigestMock          mRepositoryMockListModelVersionsByDigest

	funcListModels          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)
	funcListModelsOrigin    string
	inspectFuncListModels   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)
	afterListModelsCounter  uint64
	beforeListModelsCounter uint64
	ListModelsMock          mRepositoryMockListModels

	funcListModelsAdmin          func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error)
	funcListModelsAdminOrigin    string
	inspectFuncListModelsAdmin   func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool)
	afterListModelsAdminCounter  uint64
	beforeListModelsAdminCounter uint64
	ListModelsAdminMock          mRepositoryMockListModelsAdmin

	funcListNamespaceModels          func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)
	funcListNamespaceModelsOrigin    string
	inspectFuncListNamespaceModels   func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)
	afterListNamespaceModelsCounter  uint64
	beforeListNamespaceModelsCounter uint64
	ListNamespaceModelsMock          mRepositoryMockListNamespaceModels

	funcPinUser          func(ctx context.Context, table string)
	funcPinUserOrigin    string
	inspectFuncPinUser   func(ctx context.Context, table string)
	afterPinUserCounter  uint64
	beforePinUserCounter uint64
	PinUserMock          mRepositoryMockPinUser

	funcUpdateModelRun          func(ctx context.Context, modelRun *datamodel.ModelRun) (err error)
	funcUpdateModelRunOrigin    string
	inspectFuncUpdateModelRun   func(ctx context.Context, modelRun *datamodel.ModelRun)
	afterUpdateModelRunCounter  uint64
	beforeUpdateModelRunCounter uint64
	UpdateModelRunMock          mRepositoryMockUpdateModelRun

	funcUpdateModelVersionDigestByID          func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error)
	funcUpdateModelVersionDigestByIDOrigin    string
	inspectFuncUpdateModelVersionDigestByID   func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string)
	afterUpdateModelVersionDigestByIDCounter  uint64
	beforeUpdateModelVersionDigestByIDCounter uint64
	UpdateModelVersionDigestByIDMock          mRepositoryMockUpdateModelVersionDigestByID

	funcUpdateNamespaceModelByID          func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error)
	funcUpdateNamespaceModelByIDOrigin    string
	inspectFuncUpdateNamespaceModelByID   func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model)
	afterUpdateNamespaceModelByIDCounter  uint64
	beforeUpdateNamespaceModelByIDCounter uint64
	UpdateNamespaceModelByIDMock          mRepositoryMockUpdateNamespaceModelByID

	funcUpdateNamespaceModelIDByID          func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)
	funcUpdateNamespaceModelIDByIDOrigin    string
	inspectFuncUpdateNamespaceModelIDByID   func(ctx context.Context, ownerPermalink string, id string, newID string)
	afterUpdateNamespaceModelIDByIDCounter  uint64
	beforeUpdateNamespaceModelIDByIDCounter uint64
	UpdateNamespaceModelIDByIDMock          mRepositoryMockUpdateNamespaceModelIDByID

	funcUpsertRepositoryTag          func(ctx context.Context, tag *datamodel.Tag) (tp1 *datamodel.Tag, err error)
	funcUpsertRepositoryTagOrigin    string
	inspectFuncUpsertRepositoryTag   func(ctx context.Context, tag *datamodel.Tag)
	afterUpsertRepositoryTagCounter  uint64
	beforeUpsertRepositoryTagCounter uint64
	UpsertRepositoryTagMock          mRepositoryMockUpsertRepositoryTag
}

// NewRepositoryMock returns a mock for mm_repository.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPinnedUserMock = mRepositoryMockCheckPinnedUser{mock: m}
	m.CheckPinnedUserMock.callArgs = []*RepositoryMockCheckPinnedUserParams{}

	m.CreateModelRunMock = mRepositoryMockCreateModelRun{mock: m}
	m.CreateModelRunMock.callArgs = []*RepositoryMockCreateModelRunParams{}

	m.CreateModelTagsMock = mRepositoryMockCreateModelTags{mock: m}
	m.CreateModelTagsMock.callArgs = []*RepositoryMockCreateModelTagsParams{}

	m.CreateModelVersionMock = mRepositoryMockCreateModelVersion{mock: m}
	m.CreateModelVersionMock.callArgs = []*RepositoryMockCreateModelVersionParams{}

	m.CreateNamespaceModelMock = mRepositoryMockCreateNamespaceModel{mock: m}
	m.CreateNamespaceModelMock.callArgs = []*RepositoryMockCreateNamespaceModelParams{}

	m.DeleteModelTagsMock = mRepositoryMockDeleteModelTags{mock: m}
	m.DeleteModelTagsMock.callArgs = []*RepositoryMockDeleteModelTagsParams{}

	m.DeleteModelVersionByDigestMock = mRepositoryMockDeleteModelVersionByDigest{mock: m}
	m.DeleteModelVersionByDigestMock.callArgs = []*RepositoryMockDeleteModelVersionByDigestParams{}

	m.DeleteModelVersionByIDMock = mRepositoryMockDeleteModelVersionByID{mock: m}
	m.DeleteModelVersionByIDMock.callArgs = []*RepositoryMockDeleteModelVersionByIDParams{}

	m.DeleteNamespaceModelByIDMock = mRepositoryMockDeleteNamespaceModelByID{mock: m}
	m.DeleteNamespaceModelByIDMock.callArgs = []*RepositoryMockDeleteNamespaceModelByIDParams{}

	m.DeleteRepositoryTagMock = mRepositoryMockDeleteRepositoryTag{mock: m}
	m.DeleteRepositoryTagMock.callArgs = []*RepositoryMockDeleteRepositoryTagParams{}

	m.GetLatestModelRunByModelUIDMock = mRepositoryMockGetLatestModelRunByModelUID{mock: m}
	m.GetLatestModelRunByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelRunByModelUIDParams{}

	m.GetLatestModelVersionByModelUIDMock = mRepositoryMockGetLatestModelVersionByModelUID{mock: m}
	m.GetLatestModelVersionByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelVersionByModelUIDParams{}

	m.GetLatestModelVersionRunByModelUIDMock = mRepositoryMockGetLatestModelVersionRunByModelUID{mock: m}
	m.GetLatestModelVersionRunByModelUIDMock.callArgs = []*RepositoryMockGetLatestModelVersionRunByModelUIDParams{}

	m.GetModelByUIDMock = mRepositoryMockGetModelByUID{mock: m}
	m.GetModelByUIDMock.callArgs = []*RepositoryMockGetModelByUIDParams{}

	m.GetModelByUIDAdminMock = mRepositoryMockGetModelByUIDAdmin{mock: m}
	m.GetModelByUIDAdminMock.callArgs = []*RepositoryMockGetModelByUIDAdminParams{}

	m.GetModelDefinitionMock = mRepositoryMockGetModelDefinition{mock: m}
	m.GetModelDefinitionMock.callArgs = []*RepositoryMockGetModelDefinitionParams{}

	m.GetModelDefinitionByUIDMock = mRepositoryMockGetModelDefinitionByUID{mock: m}
	m.GetModelDefinitionByUIDMock.callArgs = []*RepositoryMockGetModelDefinitionByUIDParams{}

	m.GetModelRunByUIDMock = mRepositoryMockGetModelRunByUID{mock: m}
	m.GetModelRunByUIDMock.callArgs = []*RepositoryMockGetModelRunByUIDParams{}

	m.GetModelVersionByIDMock = mRepositoryMockGetModelVersionByID{mock: m}
	m.GetModelVersionByIDMock.callArgs = []*RepositoryMockGetModelVersionByIDParams{}

	m.GetNamespaceModelByIDMock = mRepositoryMockGetNamespaceModelByID{mock: m}
	m.GetNamespaceModelByIDMock.callArgs = []*RepositoryMockGetNamespaceModelByIDParams{}

	m.GetRepositoryTagMock = mRepositoryMockGetRepositoryTag{mock: m}
	m.GetRepositoryTagMock.callArgs = []*RepositoryMockGetRepositoryTagParams{}

	m.ListModelDefinitionsMock = mRepositoryMockListModelDefinitions{mock: m}
	m.ListModelDefinitionsMock.callArgs = []*RepositoryMockListModelDefinitionsParams{}

	m.ListModelRunsMock = mRepositoryMockListModelRuns{mock: m}
	m.ListModelRunsMock.callArgs = []*RepositoryMockListModelRunsParams{}

	m.ListModelRunsByRequesterMock = mRepositoryMockListModelRunsByRequester{mock: m}
	m.ListModelRunsByRequesterMock.callArgs = []*RepositoryMockListModelRunsByRequesterParams{}

	m.ListModelTagsMock = mRepositoryMockListModelTags{mock: m}
	m.ListModelTagsMock.callArgs = []*RepositoryMockListModelTagsParams{}

	m.ListModelVersionsMock = mRepositoryMockListModelVersions{mock: m}
	m.ListModelVersionsMock.callArgs = []*RepositoryMockListModelVersionsParams{}

	m.ListModelVersionsByDigestMock = mRepositoryMockListModelVersionsByDigest{mock: m}
	m.ListModelVersionsByDigestMock.callArgs = []*RepositoryMockListModelVersionsByDigestParams{}

	m.ListModelsMock = mRepositoryMockListModels{mock: m}
	m.ListModelsMock.callArgs = []*RepositoryMockListModelsParams{}

	m.ListModelsAdminMock = mRepositoryMockListModelsAdmin{mock: m}
	m.ListModelsAdminMock.callArgs = []*RepositoryMockListModelsAdminParams{}

	m.ListNamespaceModelsMock = mRepositoryMockListNamespaceModels{mock: m}
	m.ListNamespaceModelsMock.callArgs = []*RepositoryMockListNamespaceModelsParams{}

	m.PinUserMock = mRepositoryMockPinUser{mock: m}
	m.PinUserMock.callArgs = []*RepositoryMockPinUserParams{}

	m.UpdateModelRunMock = mRepositoryMockUpdateModelRun{mock: m}
	m.UpdateModelRunMock.callArgs = []*RepositoryMockUpdateModelRunParams{}

	m.UpdateModelVersionDigestByIDMock = mRepositoryMockUpdateModelVersionDigestByID{mock: m}
	m.UpdateModelVersionDigestByIDMock.callArgs = []*RepositoryMockUpdateModelVersionDigestByIDParams{}

	m.UpdateNamespaceModelByIDMock = mRepositoryMockUpdateNamespaceModelByID{mock: m}
	m.UpdateNamespaceModelByIDMock.callArgs = []*RepositoryMockUpdateNamespaceModelByIDParams{}

	m.UpdateNamespaceModelIDByIDMock = mRepositoryMockUpdateNamespaceModelIDByID{mock: m}
	m.UpdateNamespaceModelIDByIDMock.callArgs = []*RepositoryMockUpdateNamespaceModelIDByIDParams{}

	m.UpsertRepositoryTagMock = mRepositoryMockUpsertRepositoryTag{mock: m}
	m.UpsertRepositoryTagMock.callArgs = []*RepositoryMockUpsertRepositoryTagParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCheckPinnedUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCheckPinnedUserExpectation
	expectations       []*RepositoryMockCheckPinnedUserExpectation

	callArgs []*RepositoryMockCheckPinnedUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCheckPinnedUserExpectation specifies expectation struct of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCheckPinnedUserParams
	paramPtrs          *RepositoryMockCheckPinnedUserParamPtrs
	expectationOrigins RepositoryMockCheckPinnedUserExpectationOrigins
	results            *RepositoryMockCheckPinnedUserResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCheckPinnedUserParams contains parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParams struct {
	ctx   context.Context
	db    *gorm.DB
	table string
}

// RepositoryMockCheckPinnedUserParamPtrs contains pointers to parameters of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserParamPtrs struct {
	ctx   *context.Context
	db    **gorm.DB
	table *string
}

// RepositoryMockCheckPinnedUserResults contains results of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserResults struct {
	dp1 *gorm.DB
}

// RepositoryMockCheckPinnedUserOrigins contains origins of expectations of the Repository.CheckPinnedUser
type RepositoryMockCheckPinnedUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originDb    string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Optional() *mRepositoryMockCheckPinnedUser {
	mmCheckPinnedUser.optional = true
	return mmCheckPinnedUser
}

// Expect sets up expected params for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Expect(ctx context.Context, db *gorm.DB, table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by ExpectParams functions")
	}

	mmCheckPinnedUser.defaultExpectation.params = &RepositoryMockCheckPinnedUserParams{ctx, db, table}
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPinnedUser.expectations {
		if minimock.Equal(e.params, mmCheckPinnedUser.defaultExpectation.params) {
			mmCheckPinnedUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPinnedUser.defaultExpectation.params)
		}
	}

	return mmCheckPinnedUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectDbParam2 sets up expected param db for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectDbParam2(db *gorm.DB) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.db = &db
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originDb = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// ExpectTableParam3 sets up expected param table for Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) ExpectTableParam3(table string) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{}
	}

	if mmCheckPinnedUser.defaultExpectation.params != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Expect")
	}

	if mmCheckPinnedUser.defaultExpectation.paramPtrs == nil {
		mmCheckPinnedUser.defaultExpectation.paramPtrs = &RepositoryMockCheckPinnedUserParamPtrs{}
	}
	mmCheckPinnedUser.defaultExpectation.paramPtrs.table = &table
	mmCheckPinnedUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmCheckPinnedUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Inspect(f func(ctx context.Context, db *gorm.DB, table string)) *mRepositoryMockCheckPinnedUser {
	if mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CheckPinnedUser")
	}

	mmCheckPinnedUser.mock.inspectFuncCheckPinnedUser = f

	return mmCheckPinnedUser
}

// Return sets up results that will be returned by Repository.CheckPinnedUser
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Return(dp1 *gorm.DB) *RepositoryMock {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	if mmCheckPinnedUser.defaultExpectation == nil {
		mmCheckPinnedUser.defaultExpectation = &RepositoryMockCheckPinnedUserExpectation{mock: mmCheckPinnedUser.mock}
	}
	mmCheckPinnedUser.defaultExpectation.results = &RepositoryMockCheckPinnedUserResults{dp1}
	mmCheckPinnedUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// Set uses given function f to mock the Repository.CheckPinnedUser method
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Set(f func(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB)) *RepositoryMock {
	if mmCheckPinnedUser.defaultExpectation != nil {
		mmCheckPinnedUser.mock.t.Fatalf("Default expectation is already set for the Repository.CheckPinnedUser method")
	}

	if len(mmCheckPinnedUser.expectations) > 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Some expectations are already set for the Repository.CheckPinnedUser method")
	}

	mmCheckPinnedUser.mock.funcCheckPinnedUser = f
	mmCheckPinnedUser.mock.funcCheckPinnedUserOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser.mock
}

// When sets expectation for the Repository.CheckPinnedUser which will trigger the result defined by the following
// Then helper
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) When(ctx context.Context, db *gorm.DB, table string) *RepositoryMockCheckPinnedUserExpectation {
	if mmCheckPinnedUser.mock.funcCheckPinnedUser != nil {
		mmCheckPinnedUser.mock.t.Fatalf("RepositoryMock.CheckPinnedUser mock is already set by Set")
	}

	expectation := &RepositoryMockCheckPinnedUserExpectation{
		mock:               mmCheckPinnedUser.mock,
		params:             &RepositoryMockCheckPinnedUserParams{ctx, db, table},
		expectationOrigins: RepositoryMockCheckPinnedUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPinnedUser.expectations = append(mmCheckPinnedUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckPinnedUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCheckPinnedUserExpectation) Then(dp1 *gorm.DB) *RepositoryMock {
	e.results = &RepositoryMockCheckPinnedUserResults{dp1}
	return e.mock
}

// Times sets number of times Repository.CheckPinnedUser should be invoked
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Times(n uint64) *mRepositoryMockCheckPinnedUser {
	if n == 0 {
		mmCheckPinnedUser.mock.t.Fatalf("Times of RepositoryMock.CheckPinnedUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPinnedUser.expectedInvocations, n)
	mmCheckPinnedUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPinnedUser
}

func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) invocationsDone() bool {
	if len(mmCheckPinnedUser.expectations) == 0 && mmCheckPinnedUser.defaultExpectation == nil && mmCheckPinnedUser.mock.funcCheckPinnedUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.mock.afterCheckPinnedUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPinnedUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPinnedUser implements mm_repository.Repository
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUser(ctx context.Context, db *gorm.DB, table string) (dp1 *gorm.DB) {
	mm_atomic.AddUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter, 1)

	mmCheckPinnedUser.t.Helper()

	if mmCheckPinnedUser.inspectFuncCheckPinnedUser != nil {
		mmCheckPinnedUser.inspectFuncCheckPinnedUser(ctx, db, table)
	}

	mm_params := RepositoryMockCheckPinnedUserParams{ctx, db, table}

	// Record call args
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Lock()
	mmCheckPinnedUser.CheckPinnedUserMock.callArgs = append(mmCheckPinnedUser.CheckPinnedUserMock.callArgs, &mm_params)
	mmCheckPinnedUser.CheckPinnedUserMock.mutex.Unlock()

	for _, e := range mmCheckPinnedUser.CheckPinnedUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1
		}
	}

	if mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCheckPinnedUserParams{ctx, db, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.db != nil && !minimock.Equal(*mm_want_ptrs.db, mm_got.db) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter db, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originDb, *mm_want_ptrs.db, mm_got.db, minimock.Diff(*mm_want_ptrs.db, mm_got.db))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPinnedUser.t.Errorf("RepositoryMock.CheckPinnedUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPinnedUser.CheckPinnedUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPinnedUser.t.Fatal("No results are set for the RepositoryMock.CheckPinnedUser")
		}
		return (*mm_results).dp1
	}
	if mmCheckPinnedUser.funcCheckPinnedUser != nil {
		return mmCheckPinnedUser.funcCheckPinnedUser(ctx, db, table)
	}
	mmCheckPinnedUser.t.Fatalf("Unexpected call to RepositoryMock.CheckPinnedUser. %v %v %v", ctx, db, table)
	return
}

// CheckPinnedUserAfterCounter returns a count of finished RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.afterCheckPinnedUserCounter)
}

// CheckPinnedUserBeforeCounter returns a count of RepositoryMock.CheckPinnedUser invocations
func (mmCheckPinnedUser *RepositoryMock) CheckPinnedUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPinnedUser.beforeCheckPinnedUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CheckPinnedUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPinnedUser *mRepositoryMockCheckPinnedUser) Calls() []*RepositoryMockCheckPinnedUserParams {
	mmCheckPinnedUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCheckPinnedUserParams, len(mmCheckPinnedUser.callArgs))
	copy(argCopy, mmCheckPinnedUser.callArgs)

	mmCheckPinnedUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPinnedUserDone returns true if the count of the CheckPinnedUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCheckPinnedUserDone() bool {
	if m.CheckPinnedUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPinnedUserMock.invocationsDone()
}

// MinimockCheckPinnedUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCheckPinnedUserInspect() {
	for _, e := range m.CheckPinnedUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPinnedUserCounter := mm_atomic.LoadUint64(&m.afterCheckPinnedUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPinnedUserMock.defaultExpectation != nil && afterCheckPinnedUserCounter < 1 {
		if m.CheckPinnedUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.CheckPinnedUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s with params: %#v", m.CheckPinnedUserMock.defaultExpectation.expectationOrigins.origin, *m.CheckPinnedUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPinnedUser != nil && afterCheckPinnedUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CheckPinnedUser at\n%s", m.funcCheckPinnedUserOrigin)
	}

	if !m.CheckPinnedUserMock.invocationsDone() && afterCheckPinnedUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CheckPinnedUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPinnedUserMock.expectedInvocations), m.CheckPinnedUserMock.expectedInvocationsOrigin, afterCheckPinnedUserCounter)
	}
}

type mRepositoryMockCreateModelRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelRunExpectation
	expectations       []*RepositoryMockCreateModelRunExpectation

	callArgs []*RepositoryMockCreateModelRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateModelRunExpectation specifies expectation struct of the Repository.CreateModelRun
type RepositoryMockCreateModelRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateModelRunParams
	paramPtrs          *RepositoryMockCreateModelRunParamPtrs
	expectationOrigins RepositoryMockCreateModelRunExpectationOrigins
	results            *RepositoryMockCreateModelRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateModelRunParams contains parameters of the Repository.CreateModelRun
type RepositoryMockCreateModelRunParams struct {
	ctx      context.Context
	modelRun *datamodel.ModelRun
}

// RepositoryMockCreateModelRunParamPtrs contains pointers to parameters of the Repository.CreateModelRun
type RepositoryMockCreateModelRunParamPtrs struct {
	ctx      *context.Context
	modelRun **datamodel.ModelRun
}

// RepositoryMockCreateModelRunResults contains results of the Repository.CreateModelRun
type RepositoryMockCreateModelRunResults struct {
	mp1 *datamodel.ModelRun
	err error
}

// RepositoryMockCreateModelRunOrigins contains origins of expectations of the Repository.CreateModelRun
type RepositoryMockCreateModelRunExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Optional() *mRepositoryMockCreateModelRun {
	mmCreateModelRun.optional = true
	return mmCreateModelRun
}

// Expect sets up expected params for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Expect(ctx context.Context, modelRun *datamodel.ModelRun) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by ExpectParams functions")
	}

	mmCreateModelRun.defaultExpectation.params = &RepositoryMockCreateModelRunParams{ctx, modelRun}
	mmCreateModelRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateModelRun.expectations {
		if minimock.Equal(e.params, mmCreateModelRun.defaultExpectation.params) {
			mmCreateModelRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelRun.defaultExpectation.params)
		}
	}

	return mmCreateModelRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.params != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Expect")
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs == nil {
		mmCreateModelRun.defaultExpectation.paramPtrs = &RepositoryMockCreateModelRunParamPtrs{}
	}
	mmCreateModelRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateModelRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateModelRun
}

// ExpectModelRunParam2 sets up expected param modelRun for Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) ExpectModelRunParam2(modelRun *datamodel.ModelRun) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{}
	}

	if mmCreateModelRun.defaultExpectation.params != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Expect")
	}

	if mmCreateModelRun.defaultExpectation.paramPtrs == nil {
		mmCreateModelRun.defaultExpectation.paramPtrs = &RepositoryMockCreateModelRunParamPtrs{}
	}
	mmCreateModelRun.defaultExpectation.paramPtrs.modelRun = &modelRun
	mmCreateModelRun.defaultExpectation.expectationOrigins.originModelRun = minimock.CallerInfo(1)

	return mmCreateModelRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Inspect(f func(ctx context.Context, modelRun *datamodel.ModelRun)) *mRepositoryMockCreateModelRun {
	if mmCreateModelRun.mock.inspectFuncCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelRun")
	}

	mmCreateModelRun.mock.inspectFuncCreateModelRun = f

	return mmCreateModelRun
}

// Return sets up results that will be returned by Repository.CreateModelRun
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Return(mp1 *datamodel.ModelRun, err error) *RepositoryMock {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	if mmCreateModelRun.defaultExpectation == nil {
		mmCreateModelRun.defaultExpectation = &RepositoryMockCreateModelRunExpectation{mock: mmCreateModelRun.mock}
	}
	mmCreateModelRun.defaultExpectation.results = &RepositoryMockCreateModelRunResults{mp1, err}
	mmCreateModelRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateModelRun.mock
}

// Set uses given function f to mock the Repository.CreateModelRun method
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Set(f func(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmCreateModelRun.defaultExpectation != nil {
		mmCreateModelRun.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelRun method")
	}

	if len(mmCreateModelRun.expectations) > 0 {
		mmCreateModelRun.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelRun method")
	}

	mmCreateModelRun.mock.funcCreateModelRun = f
	mmCreateModelRun.mock.funcCreateModelRunOrigin = minimock.CallerInfo(1)
	return mmCreateModelRun.mock
}

// When sets expectation for the Repository.CreateModelRun which will trigger the result defined by the following
// Then helper
func (mmCreateModelRun *mRepositoryMockCreateModelRun) When(ctx context.Context, modelRun *datamodel.ModelRun) *RepositoryMockCreateModelRunExpectation {
	if mmCreateModelRun.mock.funcCreateModelRun != nil {
		mmCreateModelRun.mock.t.Fatalf("RepositoryMock.CreateModelRun mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelRunExpectation{
		mock:               mmCreateModelRun.mock,
		params:             &RepositoryMockCreateModelRunParams{ctx, modelRun},
		expectationOrigins: RepositoryMockCreateModelRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateModelRun.expectations = append(mmCreateModelRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelRunExpectation) Then(mp1 *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelRunResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateModelRun should be invoked
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Times(n uint64) *mRepositoryMockCreateModelRun {
	if n == 0 {
		mmCreateModelRun.mock.t.Fatalf("Times of RepositoryMock.CreateModelRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelRun.expectedInvocations, n)
	mmCreateModelRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateModelRun
}

func (mmCreateModelRun *mRepositoryMockCreateModelRun) invocationsDone() bool {
	if len(mmCreateModelRun.expectations) == 0 && mmCreateModelRun.defaultExpectation == nil && mmCreateModelRun.mock.funcCreateModelRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelRun.mock.afterCreateModelRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelRun implements mm_repository.Repository
func (mmCreateModelRun *RepositoryMock) CreateModelRun(ctx context.Context, modelRun *datamodel.ModelRun) (mp1 *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmCreateModelRun.beforeCreateModelRunCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelRun.afterCreateModelRunCounter, 1)

	mmCreateModelRun.t.Helper()

	if mmCreateModelRun.inspectFuncCreateModelRun != nil {
		mmCreateModelRun.inspectFuncCreateModelRun(ctx, modelRun)
	}

	mm_params := RepositoryMockCreateModelRunParams{ctx, modelRun}

	// Record call args
	mmCreateModelRun.CreateModelRunMock.mutex.Lock()
	mmCreateModelRun.CreateModelRunMock.callArgs = append(mmCreateModelRun.CreateModelRunMock.callArgs, &mm_params)
	mmCreateModelRun.CreateModelRunMock.mutex.Unlock()

	for _, e := range mmCreateModelRun.CreateModelRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmCreateModelRun.CreateModelRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelRun.CreateModelRunMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelRun.CreateModelRunMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelRun.CreateModelRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelRunParams{ctx, modelRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelRun.CreateModelRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelRun != nil && !minimock.Equal(*mm_want_ptrs.modelRun, mm_got.modelRun) {
				mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameter modelRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelRun.CreateModelRunMock.defaultExpectation.expectationOrigins.originModelRun, *mm_want_ptrs.modelRun, mm_got.modelRun, minimock.Diff(*mm_want_ptrs.modelRun, mm_got.modelRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelRun.t.Errorf("RepositoryMock.CreateModelRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateModelRun.CreateModelRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelRun.CreateModelRunMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelRun.t.Fatal("No results are set for the RepositoryMock.CreateModelRun")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmCreateModelRun.funcCreateModelRun != nil {
		return mmCreateModelRun.funcCreateModelRun(ctx, modelRun)
	}
	mmCreateModelRun.t.Fatalf("Unexpected call to RepositoryMock.CreateModelRun. %v %v", ctx, modelRun)
	return
}

// CreateModelRunAfterCounter returns a count of finished RepositoryMock.CreateModelRun invocations
func (mmCreateModelRun *RepositoryMock) CreateModelRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelRun.afterCreateModelRunCounter)
}

// CreateModelRunBeforeCounter returns a count of RepositoryMock.CreateModelRun invocations
func (mmCreateModelRun *RepositoryMock) CreateModelRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelRun.beforeCreateModelRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelRun *mRepositoryMockCreateModelRun) Calls() []*RepositoryMockCreateModelRunParams {
	mmCreateModelRun.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelRunParams, len(mmCreateModelRun.callArgs))
	copy(argCopy, mmCreateModelRun.callArgs)

	mmCreateModelRun.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelRunDone returns true if the count of the CreateModelRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelRunDone() bool {
	if m.CreateModelRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelRunMock.invocationsDone()
}

// MinimockCreateModelRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelRunInspect() {
	for _, e := range m.CreateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateModelRunCounter := mm_atomic.LoadUint64(&m.afterCreateModelRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelRunMock.defaultExpectation != nil && afterCreateModelRunCounter < 1 {
		if m.CreateModelRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelRun at\n%s", m.CreateModelRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelRun at\n%s with params: %#v", m.CreateModelRunMock.defaultExpectation.expectationOrigins.origin, *m.CreateModelRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelRun != nil && afterCreateModelRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateModelRun at\n%s", m.funcCreateModelRunOrigin)
	}

	if !m.CreateModelRunMock.invocationsDone() && afterCreateModelRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelRunMock.expectedInvocations), m.CreateModelRunMock.expectedInvocationsOrigin, afterCreateModelRunCounter)
	}
}

type mRepositoryMockCreateModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelTagsExpectation
	expectations       []*RepositoryMockCreateModelTagsExpectation

	callArgs []*RepositoryMockCreateModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateModelTagsExpectation specifies expectation struct of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateModelTagsParams
	paramPtrs          *RepositoryMockCreateModelTagsParamPtrs
	expectationOrigins RepositoryMockCreateModelTagsExpectationOrigins
	results            *RepositoryMockCreateModelTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateModelTagsParams contains parameters of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	tagNames []string
}

// RepositoryMockCreateModelTagsParamPtrs contains pointers to parameters of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	tagNames *[]string
}

// RepositoryMockCreateModelTagsResults contains results of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsResults struct {
	err error
}

// RepositoryMockCreateModelTagsOrigins contains origins of expectations of the Repository.CreateModelTags
type RepositoryMockCreateModelTagsExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originTagNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Optional() *mRepositoryMockCreateModelTags {
	mmCreateModelTags.optional = true
	return mmCreateModelTags
}

// Expect sets up expected params for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Expect(ctx context.Context, modelUID uuid.UUID, tagNames []string) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by ExpectParams functions")
	}

	mmCreateModelTags.defaultExpectation.params = &RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}
	mmCreateModelTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateModelTags.expectations {
		if minimock.Equal(e.params, mmCreateModelTags.defaultExpectation.params) {
			mmCreateModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelTags.defaultExpectation.params)
		}
	}

	return mmCreateModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateModelTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmCreateModelTags.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmCreateModelTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{}
	}

	if mmCreateModelTags.defaultExpectation.params != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Expect")
	}

	if mmCreateModelTags.defaultExpectation.paramPtrs == nil {
		mmCreateModelTags.defaultExpectation.paramPtrs = &RepositoryMockCreateModelTagsParamPtrs{}
	}
	mmCreateModelTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmCreateModelTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmCreateModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string)) *mRepositoryMockCreateModelTags {
	if mmCreateModelTags.mock.inspectFuncCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelTags")
	}

	mmCreateModelTags.mock.inspectFuncCreateModelTags = f

	return mmCreateModelTags
}

// Return sets up results that will be returned by Repository.CreateModelTags
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Return(err error) *RepositoryMock {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	if mmCreateModelTags.defaultExpectation == nil {
		mmCreateModelTags.defaultExpectation = &RepositoryMockCreateModelTagsExpectation{mock: mmCreateModelTags.mock}
	}
	mmCreateModelTags.defaultExpectation.results = &RepositoryMockCreateModelTagsResults{err}
	mmCreateModelTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateModelTags.mock
}

// Set uses given function f to mock the Repository.CreateModelTags method
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmCreateModelTags.defaultExpectation != nil {
		mmCreateModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelTags method")
	}

	if len(mmCreateModelTags.expectations) > 0 {
		mmCreateModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelTags method")
	}

	mmCreateModelTags.mock.funcCreateModelTags = f
	mmCreateModelTags.mock.funcCreateModelTagsOrigin = minimock.CallerInfo(1)
	return mmCreateModelTags.mock
}

// When sets expectation for the Repository.CreateModelTags which will trigger the result defined by the following
// Then helper
func (mmCreateModelTags *mRepositoryMockCreateModelTags) When(ctx context.Context, modelUID uuid.UUID, tagNames []string) *RepositoryMockCreateModelTagsExpectation {
	if mmCreateModelTags.mock.funcCreateModelTags != nil {
		mmCreateModelTags.mock.t.Fatalf("RepositoryMock.CreateModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelTagsExpectation{
		mock:               mmCreateModelTags.mock,
		params:             &RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames},
		expectationOrigins: RepositoryMockCreateModelTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateModelTags.expectations = append(mmCreateModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateModelTags should be invoked
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Times(n uint64) *mRepositoryMockCreateModelTags {
	if n == 0 {
		mmCreateModelTags.mock.t.Fatalf("Times of RepositoryMock.CreateModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelTags.expectedInvocations, n)
	mmCreateModelTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateModelTags
}

func (mmCreateModelTags *mRepositoryMockCreateModelTags) invocationsDone() bool {
	if len(mmCreateModelTags.expectations) == 0 && mmCreateModelTags.defaultExpectation == nil && mmCreateModelTags.mock.funcCreateModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelTags.mock.afterCreateModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelTags implements mm_repository.Repository
func (mmCreateModelTags *RepositoryMock) CreateModelTags(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmCreateModelTags.beforeCreateModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelTags.afterCreateModelTagsCounter, 1)

	mmCreateModelTags.t.Helper()

	if mmCreateModelTags.inspectFuncCreateModelTags != nil {
		mmCreateModelTags.inspectFuncCreateModelTags(ctx, modelUID, tagNames)
	}

	mm_params := RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}

	// Record call args
	mmCreateModelTags.CreateModelTagsMock.mutex.Lock()
	mmCreateModelTags.CreateModelTagsMock.callArgs = append(mmCreateModelTags.CreateModelTagsMock.callArgs, &mm_params)
	mmCreateModelTags.CreateModelTagsMock.mutex.Unlock()

	for _, e := range mmCreateModelTags.CreateModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateModelTags.CreateModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelTags.CreateModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelTagsParams{ctx, modelUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelTags.CreateModelTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelTags.CreateModelTagsMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelTags.CreateModelTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelTags.t.Errorf("RepositoryMock.CreateModelTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateModelTags.CreateModelTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelTags.CreateModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelTags.t.Fatal("No results are set for the RepositoryMock.CreateModelTags")
		}
		return (*mm_results).err
	}
	if mmCreateModelTags.funcCreateModelTags != nil {
		return mmCreateModelTags.funcCreateModelTags(ctx, modelUID, tagNames)
	}
	mmCreateModelTags.t.Fatalf("Unexpected call to RepositoryMock.CreateModelTags. %v %v %v", ctx, modelUID, tagNames)
	return
}

// CreateModelTagsAfterCounter returns a count of finished RepositoryMock.CreateModelTags invocations
func (mmCreateModelTags *RepositoryMock) CreateModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelTags.afterCreateModelTagsCounter)
}

// CreateModelTagsBeforeCounter returns a count of RepositoryMock.CreateModelTags invocations
func (mmCreateModelTags *RepositoryMock) CreateModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelTags.beforeCreateModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelTags *mRepositoryMockCreateModelTags) Calls() []*RepositoryMockCreateModelTagsParams {
	mmCreateModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelTagsParams, len(mmCreateModelTags.callArgs))
	copy(argCopy, mmCreateModelTags.callArgs)

	mmCreateModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelTagsDone returns true if the count of the CreateModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelTagsDone() bool {
	if m.CreateModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelTagsMock.invocationsDone()
}

// MinimockCreateModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelTagsInspect() {
	for _, e := range m.CreateModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateModelTagsCounter := mm_atomic.LoadUint64(&m.afterCreateModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelTagsMock.defaultExpectation != nil && afterCreateModelTagsCounter < 1 {
		if m.CreateModelTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelTags at\n%s", m.CreateModelTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelTags at\n%s with params: %#v", m.CreateModelTagsMock.defaultExpectation.expectationOrigins.origin, *m.CreateModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelTags != nil && afterCreateModelTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateModelTags at\n%s", m.funcCreateModelTagsOrigin)
	}

	if !m.CreateModelTagsMock.invocationsDone() && afterCreateModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelTagsMock.expectedInvocations), m.CreateModelTagsMock.expectedInvocationsOrigin, afterCreateModelTagsCounter)
	}
}

type mRepositoryMockCreateModelVersion struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateModelVersionExpectation
	expectations       []*RepositoryMockCreateModelVersionExpectation

	callArgs []*RepositoryMockCreateModelVersionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateModelVersionExpectation specifies expectation struct of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateModelVersionParams
	paramPtrs          *RepositoryMockCreateModelVersionParamPtrs
	expectationOrigins RepositoryMockCreateModelVersionExpectationOrigins
	results            *RepositoryMockCreateModelVersionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateModelVersionParams contains parameters of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionParams struct {
	ctx            context.Context
	ownerPermalink string
	version        *datamodel.ModelVersion
}

// RepositoryMockCreateModelVersionParamPtrs contains pointers to parameters of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	version        **datamodel.ModelVersion
}

// RepositoryMockCreateModelVersionResults contains results of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionResults struct {
	err error
}

// RepositoryMockCreateModelVersionOrigins contains origins of expectations of the Repository.CreateModelVersion
type RepositoryMockCreateModelVersionExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originVersion        string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Optional() *mRepositoryMockCreateModelVersion {
	mmCreateModelVersion.optional = true
	return mmCreateModelVersion
}

// Expect sets up expected params for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Expect(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by ExpectParams functions")
	}

	mmCreateModelVersion.defaultExpectation.params = &RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}
	mmCreateModelVersion.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateModelVersion.expectations {
		if minimock.Equal(e.params, mmCreateModelVersion.defaultExpectation.params) {
			mmCreateModelVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateModelVersion.defaultExpectation.params)
		}
	}

	return mmCreateModelVersion
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateModelVersion.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateModelVersion
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreateModelVersion.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreateModelVersion
}

// ExpectVersionParam3 sets up expected param version for Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) ExpectVersionParam3(version *datamodel.ModelVersion) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{}
	}

	if mmCreateModelVersion.defaultExpectation.params != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Expect")
	}

	if mmCreateModelVersion.defaultExpectation.paramPtrs == nil {
		mmCreateModelVersion.defaultExpectation.paramPtrs = &RepositoryMockCreateModelVersionParamPtrs{}
	}
	mmCreateModelVersion.defaultExpectation.paramPtrs.version = &version
	mmCreateModelVersion.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmCreateModelVersion
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Inspect(f func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion)) *mRepositoryMockCreateModelVersion {
	if mmCreateModelVersion.mock.inspectFuncCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateModelVersion")
	}

	mmCreateModelVersion.mock.inspectFuncCreateModelVersion = f

	return mmCreateModelVersion
}

// Return sets up results that will be returned by Repository.CreateModelVersion
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Return(err error) *RepositoryMock {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	if mmCreateModelVersion.defaultExpectation == nil {
		mmCreateModelVersion.defaultExpectation = &RepositoryMockCreateModelVersionExpectation{mock: mmCreateModelVersion.mock}
	}
	mmCreateModelVersion.defaultExpectation.results = &RepositoryMockCreateModelVersionResults{err}
	mmCreateModelVersion.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateModelVersion.mock
}

// Set uses given function f to mock the Repository.CreateModelVersion method
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Set(f func(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error)) *RepositoryMock {
	if mmCreateModelVersion.defaultExpectation != nil {
		mmCreateModelVersion.mock.t.Fatalf("Default expectation is already set for the Repository.CreateModelVersion method")
	}

	if len(mmCreateModelVersion.expectations) > 0 {
		mmCreateModelVersion.mock.t.Fatalf("Some expectations are already set for the Repository.CreateModelVersion method")
	}

	mmCreateModelVersion.mock.funcCreateModelVersion = f
	mmCreateModelVersion.mock.funcCreateModelVersionOrigin = minimock.CallerInfo(1)
	return mmCreateModelVersion.mock
}

// When sets expectation for the Repository.CreateModelVersion which will trigger the result defined by the following
// Then helper
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) When(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) *RepositoryMockCreateModelVersionExpectation {
	if mmCreateModelVersion.mock.funcCreateModelVersion != nil {
		mmCreateModelVersion.mock.t.Fatalf("RepositoryMock.CreateModelVersion mock is already set by Set")
	}

	expectation := &RepositoryMockCreateModelVersionExpectation{
		mock:               mmCreateModelVersion.mock,
		params:             &RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version},
		expectationOrigins: RepositoryMockCreateModelVersionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateModelVersion.expectations = append(mmCreateModelVersion.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateModelVersion return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateModelVersionExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateModelVersionResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateModelVersion should be invoked
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Times(n uint64) *mRepositoryMockCreateModelVersion {
	if n == 0 {
		mmCreateModelVersion.mock.t.Fatalf("Times of RepositoryMock.CreateModelVersion mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateModelVersion.expectedInvocations, n)
	mmCreateModelVersion.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateModelVersion
}

func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) invocationsDone() bool {
	if len(mmCreateModelVersion.expectations) == 0 && mmCreateModelVersion.defaultExpectation == nil && mmCreateModelVersion.mock.funcCreateModelVersion == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateModelVersion.mock.afterCreateModelVersionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateModelVersion.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateModelVersion implements mm_repository.Repository
func (mmCreateModelVersion *RepositoryMock) CreateModelVersion(ctx context.Context, ownerPermalink string, version *datamodel.ModelVersion) (err error) {
	mm_atomic.AddUint64(&mmCreateModelVersion.beforeCreateModelVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateModelVersion.afterCreateModelVersionCounter, 1)

	mmCreateModelVersion.t.Helper()

	if mmCreateModelVersion.inspectFuncCreateModelVersion != nil {
		mmCreateModelVersion.inspectFuncCreateModelVersion(ctx, ownerPermalink, version)
	}

	mm_params := RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}

	// Record call args
	mmCreateModelVersion.CreateModelVersionMock.mutex.Lock()
	mmCreateModelVersion.CreateModelVersionMock.callArgs = append(mmCreateModelVersion.CreateModelVersionMock.callArgs, &mm_params)
	mmCreateModelVersion.CreateModelVersionMock.mutex.Unlock()

	for _, e := range mmCreateModelVersion.CreateModelVersionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateModelVersion.CreateModelVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateModelVersionParams{ctx, ownerPermalink, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateModelVersion.t.Errorf("RepositoryMock.CreateModelVersion got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateModelVersion.CreateModelVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateModelVersion.t.Fatal("No results are set for the RepositoryMock.CreateModelVersion")
		}
		return (*mm_results).err
	}
	if mmCreateModelVersion.funcCreateModelVersion != nil {
		return mmCreateModelVersion.funcCreateModelVersion(ctx, ownerPermalink, version)
	}
	mmCreateModelVersion.t.Fatalf("Unexpected call to RepositoryMock.CreateModelVersion. %v %v %v", ctx, ownerPermalink, version)
	return
}

// CreateModelVersionAfterCounter returns a count of finished RepositoryMock.CreateModelVersion invocations
func (mmCreateModelVersion *RepositoryMock) CreateModelVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelVersion.afterCreateModelVersionCounter)
}

// CreateModelVersionBeforeCounter returns a count of RepositoryMock.CreateModelVersion invocations
func (mmCreateModelVersion *RepositoryMock) CreateModelVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateModelVersion.beforeCreateModelVersionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateModelVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateModelVersion *mRepositoryMockCreateModelVersion) Calls() []*RepositoryMockCreateModelVersionParams {
	mmCreateModelVersion.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateModelVersionParams, len(mmCreateModelVersion.callArgs))
	copy(argCopy, mmCreateModelVersion.callArgs)

	mmCreateModelVersion.mutex.RUnlock()

	return argCopy
}

// MinimockCreateModelVersionDone returns true if the count of the CreateModelVersion invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateModelVersionDone() bool {
	if m.CreateModelVersionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateModelVersionMock.invocationsDone()
}

// MinimockCreateModelVersionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateModelVersionInspect() {
	for _, e := range m.CreateModelVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateModelVersionCounter := mm_atomic.LoadUint64(&m.afterCreateModelVersionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateModelVersionMock.defaultExpectation != nil && afterCreateModelVersionCounter < 1 {
		if m.CreateModelVersionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion at\n%s", m.CreateModelVersionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion at\n%s with params: %#v", m.CreateModelVersionMock.defaultExpectation.expectationOrigins.origin, *m.CreateModelVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateModelVersion != nil && afterCreateModelVersionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateModelVersion at\n%s", m.funcCreateModelVersionOrigin)
	}

	if !m.CreateModelVersionMock.invocationsDone() && afterCreateModelVersionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateModelVersion at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateModelVersionMock.expectedInvocations), m.CreateModelVersionMock.expectedInvocationsOrigin, afterCreateModelVersionCounter)
	}
}

type mRepositoryMockCreateNamespaceModel struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateNamespaceModelExpectation
	expectations       []*RepositoryMockCreateNamespaceModelExpectation

	callArgs []*RepositoryMockCreateNamespaceModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateNamespaceModelExpectation specifies expectation struct of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateNamespaceModelParams
	paramPtrs          *RepositoryMockCreateNamespaceModelParamPtrs
	expectationOrigins RepositoryMockCreateNamespaceModelExpectationOrigins
	results            *RepositoryMockCreateNamespaceModelResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateNamespaceModelParams contains parameters of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelParams struct {
	ctx            context.Context
	ownerPermalink string
	model          *datamodel.Model
}

// RepositoryMockCreateNamespaceModelParamPtrs contains pointers to parameters of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	model          **datamodel.Model
}

// RepositoryMockCreateNamespaceModelResults contains results of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelResults struct {
	err error
}

// RepositoryMockCreateNamespaceModelOrigins contains origins of expectations of the Repository.CreateNamespaceModel
type RepositoryMockCreateNamespaceModelExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originModel          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Optional() *mRepositoryMockCreateNamespaceModel {
	mmCreateNamespaceModel.optional = true
	return mmCreateNamespaceModel
}

// Expect sets up expected params for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Expect(ctx context.Context, ownerPermalink string, model *datamodel.Model) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by ExpectParams functions")
	}

	mmCreateNamespaceModel.defaultExpectation.params = &RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateNamespaceModel.expectations {
		if minimock.Equal(e.params, mmCreateNamespaceModel.defaultExpectation.params) {
			mmCreateNamespaceModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateNamespaceModel.defaultExpectation.params)
		}
	}

	return mmCreateNamespaceModel
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateNamespaceModel
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmCreateNamespaceModel
}

// ExpectModelParam3 sets up expected param model for Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) ExpectModelParam3(model *datamodel.Model) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{}
	}

	if mmCreateNamespaceModel.defaultExpectation.params != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Expect")
	}

	if mmCreateNamespaceModel.defaultExpectation.paramPtrs == nil {
		mmCreateNamespaceModel.defaultExpectation.paramPtrs = &RepositoryMockCreateNamespaceModelParamPtrs{}
	}
	mmCreateNamespaceModel.defaultExpectation.paramPtrs.model = &model
	mmCreateNamespaceModel.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmCreateNamespaceModel
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Inspect(f func(ctx context.Context, ownerPermalink string, model *datamodel.Model)) *mRepositoryMockCreateNamespaceModel {
	if mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateNamespaceModel")
	}

	mmCreateNamespaceModel.mock.inspectFuncCreateNamespaceModel = f

	return mmCreateNamespaceModel
}

// Return sets up results that will be returned by Repository.CreateNamespaceModel
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Return(err error) *RepositoryMock {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	if mmCreateNamespaceModel.defaultExpectation == nil {
		mmCreateNamespaceModel.defaultExpectation = &RepositoryMockCreateNamespaceModelExpectation{mock: mmCreateNamespaceModel.mock}
	}
	mmCreateNamespaceModel.defaultExpectation.results = &RepositoryMockCreateNamespaceModelResults{err}
	mmCreateNamespaceModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel.mock
}

// Set uses given function f to mock the Repository.CreateNamespaceModel method
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Set(f func(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error)) *RepositoryMock {
	if mmCreateNamespaceModel.defaultExpectation != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("Default expectation is already set for the Repository.CreateNamespaceModel method")
	}

	if len(mmCreateNamespaceModel.expectations) > 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Some expectations are already set for the Repository.CreateNamespaceModel method")
	}

	mmCreateNamespaceModel.mock.funcCreateNamespaceModel = f
	mmCreateNamespaceModel.mock.funcCreateNamespaceModelOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel.mock
}

// When sets expectation for the Repository.CreateNamespaceModel which will trigger the result defined by the following
// Then helper
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) When(ctx context.Context, ownerPermalink string, model *datamodel.Model) *RepositoryMockCreateNamespaceModelExpectation {
	if mmCreateNamespaceModel.mock.funcCreateNamespaceModel != nil {
		mmCreateNamespaceModel.mock.t.Fatalf("RepositoryMock.CreateNamespaceModel mock is already set by Set")
	}

	expectation := &RepositoryMockCreateNamespaceModelExpectation{
		mock:               mmCreateNamespaceModel.mock,
		params:             &RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model},
		expectationOrigins: RepositoryMockCreateNamespaceModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateNamespaceModel.expectations = append(mmCreateNamespaceModel.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateNamespaceModel return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateNamespaceModelExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateNamespaceModelResults{err}
	return e.mock
}

// Times sets number of times Repository.CreateNamespaceModel should be invoked
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Times(n uint64) *mRepositoryMockCreateNamespaceModel {
	if n == 0 {
		mmCreateNamespaceModel.mock.t.Fatalf("Times of RepositoryMock.CreateNamespaceModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateNamespaceModel.expectedInvocations, n)
	mmCreateNamespaceModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateNamespaceModel
}

func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) invocationsDone() bool {
	if len(mmCreateNamespaceModel.expectations) == 0 && mmCreateNamespaceModel.defaultExpectation == nil && mmCreateNamespaceModel.mock.funcCreateNamespaceModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.mock.afterCreateNamespaceModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateNamespaceModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateNamespaceModel implements mm_repository.Repository
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModel(ctx context.Context, ownerPermalink string, model *datamodel.Model) (err error) {
	mm_atomic.AddUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter, 1)

	mmCreateNamespaceModel.t.Helper()

	if mmCreateNamespaceModel.inspectFuncCreateNamespaceModel != nil {
		mmCreateNamespaceModel.inspectFuncCreateNamespaceModel(ctx, ownerPermalink, model)
	}

	mm_params := RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}

	// Record call args
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Lock()
	mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs = append(mmCreateNamespaceModel.CreateNamespaceModelMock.callArgs, &mm_params)
	mmCreateNamespaceModel.CreateNamespaceModelMock.mutex.Unlock()

	for _, e := range mmCreateNamespaceModel.CreateNamespaceModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.params
		mm_want_ptrs := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateNamespaceModelParams{ctx, ownerPermalink, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateNamespaceModel.t.Errorf("RepositoryMock.CreateNamespaceModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateNamespaceModel.CreateNamespaceModelMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateNamespaceModel.t.Fatal("No results are set for the RepositoryMock.CreateNamespaceModel")
		}
		return (*mm_results).err
	}
	if mmCreateNamespaceModel.funcCreateNamespaceModel != nil {
		return mmCreateNamespaceModel.funcCreateNamespaceModel(ctx, ownerPermalink, model)
	}
	mmCreateNamespaceModel.t.Fatalf("Unexpected call to RepositoryMock.CreateNamespaceModel. %v %v %v", ctx, ownerPermalink, model)
	return
}

// CreateNamespaceModelAfterCounter returns a count of finished RepositoryMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.afterCreateNamespaceModelCounter)
}

// CreateNamespaceModelBeforeCounter returns a count of RepositoryMock.CreateNamespaceModel invocations
func (mmCreateNamespaceModel *RepositoryMock) CreateNamespaceModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateNamespaceModel.beforeCreateNamespaceModelCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateNamespaceModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateNamespaceModel *mRepositoryMockCreateNamespaceModel) Calls() []*RepositoryMockCreateNamespaceModelParams {
	mmCreateNamespaceModel.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateNamespaceModelParams, len(mmCreateNamespaceModel.callArgs))
	copy(argCopy, mmCreateNamespaceModel.callArgs)

	mmCreateNamespaceModel.mutex.RUnlock()

	return argCopy
}

// MinimockCreateNamespaceModelDone returns true if the count of the CreateNamespaceModel invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateNamespaceModelDone() bool {
	if m.CreateNamespaceModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateNamespaceModelMock.invocationsDone()
}

// MinimockCreateNamespaceModelInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateNamespaceModelInspect() {
	for _, e := range m.CreateNamespaceModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateNamespaceModelCounter := mm_atomic.LoadUint64(&m.afterCreateNamespaceModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateNamespaceModelMock.defaultExpectation != nil && afterCreateNamespaceModelCounter < 1 {
		if m.CreateNamespaceModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel at\n%s", m.CreateNamespaceModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel at\n%s with params: %#v", m.CreateNamespaceModelMock.defaultExpectation.expectationOrigins.origin, *m.CreateNamespaceModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateNamespaceModel != nil && afterCreateNamespaceModelCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateNamespaceModel at\n%s", m.funcCreateNamespaceModelOrigin)
	}

	if !m.CreateNamespaceModelMock.invocationsDone() && afterCreateNamespaceModelCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateNamespaceModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateNamespaceModelMock.expectedInvocations), m.CreateNamespaceModelMock.expectedInvocationsOrigin, afterCreateNamespaceModelCounter)
	}
}

type mRepositoryMockDeleteModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelTagsExpectation
	expectations       []*RepositoryMockDeleteModelTagsExpectation

	callArgs []*RepositoryMockDeleteModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteModelTagsExpectation specifies expectation struct of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteModelTagsParams
	paramPtrs          *RepositoryMockDeleteModelTagsParamPtrs
	expectationOrigins RepositoryMockDeleteModelTagsExpectationOrigins
	results            *RepositoryMockDeleteModelTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteModelTagsParams contains parameters of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	tagNames []string
}

// RepositoryMockDeleteModelTagsParamPtrs contains pointers to parameters of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	tagNames *[]string
}

// RepositoryMockDeleteModelTagsResults contains results of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsResults struct {
	err error
}

// RepositoryMockDeleteModelTagsOrigins contains origins of expectations of the Repository.DeleteModelTags
type RepositoryMockDeleteModelTagsExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originTagNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Optional() *mRepositoryMockDeleteModelTags {
	mmDeleteModelTags.optional = true
	return mmDeleteModelTags
}

// Expect sets up expected params for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Expect(ctx context.Context, modelUID uuid.UUID, tagNames []string) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by ExpectParams functions")
	}

	mmDeleteModelTags.defaultExpectation.params = &RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}
	mmDeleteModelTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteModelTags.expectations {
		if minimock.Equal(e.params, mmDeleteModelTags.defaultExpectation.params) {
			mmDeleteModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelTags.defaultExpectation.params)
		}
	}

	return mmDeleteModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteModelTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeleteModelTags.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeleteModelTags
}

// ExpectTagNamesParam3 sets up expected param tagNames for Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) ExpectTagNamesParam3(tagNames []string) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{}
	}

	if mmDeleteModelTags.defaultExpectation.params != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Expect")
	}

	if mmDeleteModelTags.defaultExpectation.paramPtrs == nil {
		mmDeleteModelTags.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelTagsParamPtrs{}
	}
	mmDeleteModelTags.defaultExpectation.paramPtrs.tagNames = &tagNames
	mmDeleteModelTags.defaultExpectation.expectationOrigins.originTagNames = minimock.CallerInfo(1)

	return mmDeleteModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string)) *mRepositoryMockDeleteModelTags {
	if mmDeleteModelTags.mock.inspectFuncDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelTags")
	}

	mmDeleteModelTags.mock.inspectFuncDeleteModelTags = f

	return mmDeleteModelTags
}

// Return sets up results that will be returned by Repository.DeleteModelTags
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Return(err error) *RepositoryMock {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	if mmDeleteModelTags.defaultExpectation == nil {
		mmDeleteModelTags.defaultExpectation = &RepositoryMockDeleteModelTagsExpectation{mock: mmDeleteModelTags.mock}
	}
	mmDeleteModelTags.defaultExpectation.results = &RepositoryMockDeleteModelTagsResults{err}
	mmDeleteModelTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteModelTags.mock
}

// Set uses given function f to mock the Repository.DeleteModelTags method
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error)) *RepositoryMock {
	if mmDeleteModelTags.defaultExpectation != nil {
		mmDeleteModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelTags method")
	}

	if len(mmDeleteModelTags.expectations) > 0 {
		mmDeleteModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelTags method")
	}

	mmDeleteModelTags.mock.funcDeleteModelTags = f
	mmDeleteModelTags.mock.funcDeleteModelTagsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelTags.mock
}

// When sets expectation for the Repository.DeleteModelTags which will trigger the result defined by the following
// Then helper
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) When(ctx context.Context, modelUID uuid.UUID, tagNames []string) *RepositoryMockDeleteModelTagsExpectation {
	if mmDeleteModelTags.mock.funcDeleteModelTags != nil {
		mmDeleteModelTags.mock.t.Fatalf("RepositoryMock.DeleteModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelTagsExpectation{
		mock:               mmDeleteModelTags.mock,
		params:             &RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames},
		expectationOrigins: RepositoryMockDeleteModelTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteModelTags.expectations = append(mmDeleteModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelTagsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelTagsResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelTags should be invoked
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Times(n uint64) *mRepositoryMockDeleteModelTags {
	if n == 0 {
		mmDeleteModelTags.mock.t.Fatalf("Times of RepositoryMock.DeleteModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelTags.expectedInvocations, n)
	mmDeleteModelTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelTags
}

func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) invocationsDone() bool {
	if len(mmDeleteModelTags.expectations) == 0 && mmDeleteModelTags.defaultExpectation == nil && mmDeleteModelTags.mock.funcDeleteModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelTags.mock.afterDeleteModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelTags implements mm_repository.Repository
func (mmDeleteModelTags *RepositoryMock) DeleteModelTags(ctx context.Context, modelUID uuid.UUID, tagNames []string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelTags.beforeDeleteModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelTags.afterDeleteModelTagsCounter, 1)

	mmDeleteModelTags.t.Helper()

	if mmDeleteModelTags.inspectFuncDeleteModelTags != nil {
		mmDeleteModelTags.inspectFuncDeleteModelTags(ctx, modelUID, tagNames)
	}

	mm_params := RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}

	// Record call args
	mmDeleteModelTags.DeleteModelTagsMock.mutex.Lock()
	mmDeleteModelTags.DeleteModelTagsMock.callArgs = append(mmDeleteModelTags.DeleteModelTagsMock.callArgs, &mm_params)
	mmDeleteModelTags.DeleteModelTagsMock.mutex.Unlock()

	for _, e := range mmDeleteModelTags.DeleteModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelTagsParams{ctx, modelUID, tagNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.tagNames != nil && !minimock.Equal(*mm_want_ptrs.tagNames, mm_got.tagNames) {
				mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameter tagNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.expectationOrigins.originTagNames, *mm_want_ptrs.tagNames, mm_got.tagNames, minimock.Diff(*mm_want_ptrs.tagNames, mm_got.tagNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelTags.t.Errorf("RepositoryMock.DeleteModelTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelTags.DeleteModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelTags.t.Fatal("No results are set for the RepositoryMock.DeleteModelTags")
		}
		return (*mm_results).err
	}
	if mmDeleteModelTags.funcDeleteModelTags != nil {
		return mmDeleteModelTags.funcDeleteModelTags(ctx, modelUID, tagNames)
	}
	mmDeleteModelTags.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelTags. %v %v %v", ctx, modelUID, tagNames)
	return
}

// DeleteModelTagsAfterCounter returns a count of finished RepositoryMock.DeleteModelTags invocations
func (mmDeleteModelTags *RepositoryMock) DeleteModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelTags.afterDeleteModelTagsCounter)
}

// DeleteModelTagsBeforeCounter returns a count of RepositoryMock.DeleteModelTags invocations
func (mmDeleteModelTags *RepositoryMock) DeleteModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelTags.beforeDeleteModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelTags *mRepositoryMockDeleteModelTags) Calls() []*RepositoryMockDeleteModelTagsParams {
	mmDeleteModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelTagsParams, len(mmDeleteModelTags.callArgs))
	copy(argCopy, mmDeleteModelTags.callArgs)

	mmDeleteModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelTagsDone returns true if the count of the DeleteModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelTagsDone() bool {
	if m.DeleteModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelTagsMock.invocationsDone()
}

// MinimockDeleteModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelTagsInspect() {
	for _, e := range m.DeleteModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteModelTagsCounter := mm_atomic.LoadUint64(&m.afterDeleteModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelTagsMock.defaultExpectation != nil && afterDeleteModelTagsCounter < 1 {
		if m.DeleteModelTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags at\n%s", m.DeleteModelTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags at\n%s with params: %#v", m.DeleteModelTagsMock.defaultExpectation.expectationOrigins.origin, *m.DeleteModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelTags != nil && afterDeleteModelTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteModelTags at\n%s", m.funcDeleteModelTagsOrigin)
	}

	if !m.DeleteModelTagsMock.invocationsDone() && afterDeleteModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelTagsMock.expectedInvocations), m.DeleteModelTagsMock.expectedInvocationsOrigin, afterDeleteModelTagsCounter)
	}
}

type mRepositoryMockDeleteModelVersionByDigest struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelVersionByDigestExpectation
	expectations       []*RepositoryMockDeleteModelVersionByDigestExpectation

	callArgs []*RepositoryMockDeleteModelVersionByDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteModelVersionByDigestExpectation specifies expectation struct of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteModelVersionByDigestParams
	paramPtrs          *RepositoryMockDeleteModelVersionByDigestParamPtrs
	expectationOrigins RepositoryMockDeleteModelVersionByDigestExpectationOrigins
	results            *RepositoryMockDeleteModelVersionByDigestResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteModelVersionByDigestParams contains parameters of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	digest   string
}

// RepositoryMockDeleteModelVersionByDigestParamPtrs contains pointers to parameters of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	digest   *string
}

// RepositoryMockDeleteModelVersionByDigestResults contains results of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestResults struct {
	err error
}

// RepositoryMockDeleteModelVersionByDigestOrigins contains origins of expectations of the Repository.DeleteModelVersionByDigest
type RepositoryMockDeleteModelVersionByDigestExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originDigest   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Optional() *mRepositoryMockDeleteModelVersionByDigest {
	mmDeleteModelVersionByDigest.optional = true
	return mmDeleteModelVersionByDigest
}

// Expect sets up expected params for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Expect(ctx context.Context, modelUID uuid.UUID, digest string) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by ExpectParams functions")
	}

	mmDeleteModelVersionByDigest.defaultExpectation.params = &RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}
	mmDeleteModelVersionByDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteModelVersionByDigest.expectations {
		if minimock.Equal(e.params, mmDeleteModelVersionByDigest.defaultExpectation.params) {
			mmDeleteModelVersionByDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelVersionByDigest.defaultExpectation.params)
		}
	}

	return mmDeleteModelVersionByDigest
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteModelVersionByDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteModelVersionByDigest
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeleteModelVersionByDigest.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeleteModelVersionByDigest
}

// ExpectDigestParam3 sets up expected param digest for Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) ExpectDigestParam3(digest string) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{}
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.params != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Expect")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByDigestParamPtrs{}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.paramPtrs.digest = &digest
	mmDeleteModelVersionByDigest.defaultExpectation.expectationOrigins.originDigest = minimock.CallerInfo(1)

	return mmDeleteModelVersionByDigest
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Inspect(f func(ctx context.Context, modelUID uuid.UUID, digest string)) *mRepositoryMockDeleteModelVersionByDigest {
	if mmDeleteModelVersionByDigest.mock.inspectFuncDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelVersionByDigest")
	}

	mmDeleteModelVersionByDigest.mock.inspectFuncDeleteModelVersionByDigest = f

	return mmDeleteModelVersionByDigest
}

// Return sets up results that will be returned by Repository.DeleteModelVersionByDigest
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Return(err error) *RepositoryMock {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	if mmDeleteModelVersionByDigest.defaultExpectation == nil {
		mmDeleteModelVersionByDigest.defaultExpectation = &RepositoryMockDeleteModelVersionByDigestExpectation{mock: mmDeleteModelVersionByDigest.mock}
	}
	mmDeleteModelVersionByDigest.defaultExpectation.results = &RepositoryMockDeleteModelVersionByDigestResults{err}
	mmDeleteModelVersionByDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByDigest.mock
}

// Set uses given function f to mock the Repository.DeleteModelVersionByDigest method
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Set(f func(ctx context.Context, modelUID uuid.UUID, digest string) (err error)) *RepositoryMock {
	if mmDeleteModelVersionByDigest.defaultExpectation != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelVersionByDigest method")
	}

	if len(mmDeleteModelVersionByDigest.expectations) > 0 {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelVersionByDigest method")
	}

	mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest = f
	mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigestOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByDigest.mock
}

// When sets expectation for the Repository.DeleteModelVersionByDigest which will trigger the result defined by the following
// Then helper
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) When(ctx context.Context, modelUID uuid.UUID, digest string) *RepositoryMockDeleteModelVersionByDigestExpectation {
	if mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByDigest mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelVersionByDigestExpectation{
		mock:               mmDeleteModelVersionByDigest.mock,
		params:             &RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest},
		expectationOrigins: RepositoryMockDeleteModelVersionByDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteModelVersionByDigest.expectations = append(mmDeleteModelVersionByDigest.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelVersionByDigest return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelVersionByDigestExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelVersionByDigestResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelVersionByDigest should be invoked
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Times(n uint64) *mRepositoryMockDeleteModelVersionByDigest {
	if n == 0 {
		mmDeleteModelVersionByDigest.mock.t.Fatalf("Times of RepositoryMock.DeleteModelVersionByDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelVersionByDigest.expectedInvocations, n)
	mmDeleteModelVersionByDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByDigest
}

func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) invocationsDone() bool {
	if len(mmDeleteModelVersionByDigest.expectations) == 0 && mmDeleteModelVersionByDigest.defaultExpectation == nil && mmDeleteModelVersionByDigest.mock.funcDeleteModelVersionByDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.mock.afterDeleteModelVersionByDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelVersionByDigest implements mm_repository.Repository
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigest(ctx context.Context, modelUID uuid.UUID, digest string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.beforeDeleteModelVersionByDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.afterDeleteModelVersionByDigestCounter, 1)

	mmDeleteModelVersionByDigest.t.Helper()

	if mmDeleteModelVersionByDigest.inspectFuncDeleteModelVersionByDigest != nil {
		mmDeleteModelVersionByDigest.inspectFuncDeleteModelVersionByDigest(ctx, modelUID, digest)
	}

	mm_params := RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}

	// Record call args
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.mutex.Lock()
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.callArgs = append(mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.callArgs, &mm_params)
	mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.mutex.Unlock()

	for _, e := range mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelVersionByDigestParams{ctx, modelUID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameter digest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.expectationOrigins.originDigest, *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelVersionByDigest.t.Errorf("RepositoryMock.DeleteModelVersionByDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelVersionByDigest.DeleteModelVersionByDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelVersionByDigest.t.Fatal("No results are set for the RepositoryMock.DeleteModelVersionByDigest")
		}
		return (*mm_results).err
	}
	if mmDeleteModelVersionByDigest.funcDeleteModelVersionByDigest != nil {
		return mmDeleteModelVersionByDigest.funcDeleteModelVersionByDigest(ctx, modelUID, digest)
	}
	mmDeleteModelVersionByDigest.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelVersionByDigest. %v %v %v", ctx, modelUID, digest)
	return
}

// DeleteModelVersionByDigestAfterCounter returns a count of finished RepositoryMock.DeleteModelVersionByDigest invocations
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.afterDeleteModelVersionByDigestCounter)
}

// DeleteModelVersionByDigestBeforeCounter returns a count of RepositoryMock.DeleteModelVersionByDigest invocations
func (mmDeleteModelVersionByDigest *RepositoryMock) DeleteModelVersionByDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByDigest.beforeDeleteModelVersionByDigestCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelVersionByDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelVersionByDigest *mRepositoryMockDeleteModelVersionByDigest) Calls() []*RepositoryMockDeleteModelVersionByDigestParams {
	mmDeleteModelVersionByDigest.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelVersionByDigestParams, len(mmDeleteModelVersionByDigest.callArgs))
	copy(argCopy, mmDeleteModelVersionByDigest.callArgs)

	mmDeleteModelVersionByDigest.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelVersionByDigestDone returns true if the count of the DeleteModelVersionByDigest invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelVersionByDigestDone() bool {
	if m.DeleteModelVersionByDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelVersionByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelVersionByDigestMock.invocationsDone()
}

// MinimockDeleteModelVersionByDigestInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelVersionByDigestInspect() {
	for _, e := range m.DeleteModelVersionByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteModelVersionByDigestCounter := mm_atomic.LoadUint64(&m.afterDeleteModelVersionByDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelVersionByDigestMock.defaultExpectation != nil && afterDeleteModelVersionByDigestCounter < 1 {
		if m.DeleteModelVersionByDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest at\n%s", m.DeleteModelVersionByDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest at\n%s with params: %#v", m.DeleteModelVersionByDigestMock.defaultExpectation.expectationOrigins.origin, *m.DeleteModelVersionByDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelVersionByDigest != nil && afterDeleteModelVersionByDigestCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByDigest at\n%s", m.funcDeleteModelVersionByDigestOrigin)
	}

	if !m.DeleteModelVersionByDigestMock.invocationsDone() && afterDeleteModelVersionByDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelVersionByDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelVersionByDigestMock.expectedInvocations), m.DeleteModelVersionByDigestMock.expectedInvocationsOrigin, afterDeleteModelVersionByDigestCounter)
	}
}

type mRepositoryMockDeleteModelVersionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteModelVersionByIDExpectation
	expectations       []*RepositoryMockDeleteModelVersionByIDExpectation

	callArgs []*RepositoryMockDeleteModelVersionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteModelVersionByIDExpectation specifies expectation struct of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteModelVersionByIDParams
	paramPtrs          *RepositoryMockDeleteModelVersionByIDParamPtrs
	expectationOrigins RepositoryMockDeleteModelVersionByIDExpectationOrigins
	results            *RepositoryMockDeleteModelVersionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteModelVersionByIDParams contains parameters of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
}

// RepositoryMockDeleteModelVersionByIDParamPtrs contains pointers to parameters of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
}

// RepositoryMockDeleteModelVersionByIDResults contains results of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDResults struct {
	err error
}

// RepositoryMockDeleteModelVersionByIDOrigins contains origins of expectations of the Repository.DeleteModelVersionByID
type RepositoryMockDeleteModelVersionByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelUID  string
	originVersionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Optional() *mRepositoryMockDeleteModelVersionByID {
	mmDeleteModelVersionByID.optional = true
	return mmDeleteModelVersionByID
}

// Expect sets up expected params for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by ExpectParams functions")
	}

	mmDeleteModelVersionByID.defaultExpectation.params = &RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}
	mmDeleteModelVersionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteModelVersionByID.expectations {
		if minimock.Equal(e.params, mmDeleteModelVersionByID.defaultExpectation.params) {
			mmDeleteModelVersionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelVersionByID.defaultExpectation.params)
		}
	}

	return mmDeleteModelVersionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteModelVersionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteModelVersionByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeleteModelVersionByID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeleteModelVersionByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{}
	}

	if mmDeleteModelVersionByID.defaultExpectation.params != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Expect")
	}

	if mmDeleteModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmDeleteModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteModelVersionByIDParamPtrs{}
	}
	mmDeleteModelVersionByID.defaultExpectation.paramPtrs.versionID = &versionID
	mmDeleteModelVersionByID.defaultExpectation.expectationOrigins.originVersionID = minimock.CallerInfo(1)

	return mmDeleteModelVersionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string)) *mRepositoryMockDeleteModelVersionByID {
	if mmDeleteModelVersionByID.mock.inspectFuncDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteModelVersionByID")
	}

	mmDeleteModelVersionByID.mock.inspectFuncDeleteModelVersionByID = f

	return mmDeleteModelVersionByID
}

// Return sets up results that will be returned by Repository.DeleteModelVersionByID
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Return(err error) *RepositoryMock {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	if mmDeleteModelVersionByID.defaultExpectation == nil {
		mmDeleteModelVersionByID.defaultExpectation = &RepositoryMockDeleteModelVersionByIDExpectation{mock: mmDeleteModelVersionByID.mock}
	}
	mmDeleteModelVersionByID.defaultExpectation.results = &RepositoryMockDeleteModelVersionByIDResults{err}
	mmDeleteModelVersionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByID.mock
}

// Set uses given function f to mock the Repository.DeleteModelVersionByID method
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string) (err error)) *RepositoryMock {
	if mmDeleteModelVersionByID.defaultExpectation != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteModelVersionByID method")
	}

	if len(mmDeleteModelVersionByID.expectations) > 0 {
		mmDeleteModelVersionByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteModelVersionByID method")
	}

	mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID = f
	mmDeleteModelVersionByID.mock.funcDeleteModelVersionByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByID.mock
}

// When sets expectation for the Repository.DeleteModelVersionByID which will trigger the result defined by the following
// Then helper
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) When(ctx context.Context, modelUID uuid.UUID, versionID string) *RepositoryMockDeleteModelVersionByIDExpectation {
	if mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.mock.t.Fatalf("RepositoryMock.DeleteModelVersionByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteModelVersionByIDExpectation{
		mock:               mmDeleteModelVersionByID.mock,
		params:             &RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID},
		expectationOrigins: RepositoryMockDeleteModelVersionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteModelVersionByID.expectations = append(mmDeleteModelVersionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteModelVersionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteModelVersionByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteModelVersionByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteModelVersionByID should be invoked
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Times(n uint64) *mRepositoryMockDeleteModelVersionByID {
	if n == 0 {
		mmDeleteModelVersionByID.mock.t.Fatalf("Times of RepositoryMock.DeleteModelVersionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelVersionByID.expectedInvocations, n)
	mmDeleteModelVersionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelVersionByID
}

func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) invocationsDone() bool {
	if len(mmDeleteModelVersionByID.expectations) == 0 && mmDeleteModelVersionByID.defaultExpectation == nil && mmDeleteModelVersionByID.mock.funcDeleteModelVersionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByID.mock.afterDeleteModelVersionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelVersionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelVersionByID implements mm_repository.Repository
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByID(ctx context.Context, modelUID uuid.UUID, versionID string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelVersionByID.beforeDeleteModelVersionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelVersionByID.afterDeleteModelVersionByIDCounter, 1)

	mmDeleteModelVersionByID.t.Helper()

	if mmDeleteModelVersionByID.inspectFuncDeleteModelVersionByID != nil {
		mmDeleteModelVersionByID.inspectFuncDeleteModelVersionByID(ctx, modelUID, versionID)
	}

	mm_params := RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}

	// Record call args
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.mutex.Lock()
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.callArgs = append(mmDeleteModelVersionByID.DeleteModelVersionByIDMock.callArgs, &mm_params)
	mmDeleteModelVersionByID.DeleteModelVersionByIDMock.mutex.Unlock()

	for _, e := range mmDeleteModelVersionByID.DeleteModelVersionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteModelVersionByIDParams{ctx, modelUID, versionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameter versionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.expectationOrigins.originVersionID, *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelVersionByID.t.Errorf("RepositoryMock.DeleteModelVersionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelVersionByID.DeleteModelVersionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelVersionByID.t.Fatal("No results are set for the RepositoryMock.DeleteModelVersionByID")
		}
		return (*mm_results).err
	}
	if mmDeleteModelVersionByID.funcDeleteModelVersionByID != nil {
		return mmDeleteModelVersionByID.funcDeleteModelVersionByID(ctx, modelUID, versionID)
	}
	mmDeleteModelVersionByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteModelVersionByID. %v %v %v", ctx, modelUID, versionID)
	return
}

// DeleteModelVersionByIDAfterCounter returns a count of finished RepositoryMock.DeleteModelVersionByID invocations
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByID.afterDeleteModelVersionByIDCounter)
}

// DeleteModelVersionByIDBeforeCounter returns a count of RepositoryMock.DeleteModelVersionByID invocations
func (mmDeleteModelVersionByID *RepositoryMock) DeleteModelVersionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelVersionByID.beforeDeleteModelVersionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteModelVersionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelVersionByID *mRepositoryMockDeleteModelVersionByID) Calls() []*RepositoryMockDeleteModelVersionByIDParams {
	mmDeleteModelVersionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteModelVersionByIDParams, len(mmDeleteModelVersionByID.callArgs))
	copy(argCopy, mmDeleteModelVersionByID.callArgs)

	mmDeleteModelVersionByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelVersionByIDDone returns true if the count of the DeleteModelVersionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteModelVersionByIDDone() bool {
	if m.DeleteModelVersionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelVersionByIDMock.invocationsDone()
}

// MinimockDeleteModelVersionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteModelVersionByIDInspect() {
	for _, e := range m.DeleteModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteModelVersionByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteModelVersionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelVersionByIDMock.defaultExpectation != nil && afterDeleteModelVersionByIDCounter < 1 {
		if m.DeleteModelVersionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID at\n%s", m.DeleteModelVersionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID at\n%s with params: %#v", m.DeleteModelVersionByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteModelVersionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelVersionByID != nil && afterDeleteModelVersionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteModelVersionByID at\n%s", m.funcDeleteModelVersionByIDOrigin)
	}

	if !m.DeleteModelVersionByIDMock.invocationsDone() && afterDeleteModelVersionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteModelVersionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelVersionByIDMock.expectedInvocations), m.DeleteModelVersionByIDMock.expectedInvocationsOrigin, afterDeleteModelVersionByIDCounter)
	}
}

type mRepositoryMockDeleteNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteNamespaceModelByIDExpectation
	expectations       []*RepositoryMockDeleteNamespaceModelByIDExpectation

	callArgs []*RepositoryMockDeleteNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteNamespaceModelByIDExpectation specifies expectation struct of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteNamespaceModelByIDParams
	paramPtrs          *RepositoryMockDeleteNamespaceModelByIDParamPtrs
	expectationOrigins RepositoryMockDeleteNamespaceModelByIDExpectationOrigins
	results            *RepositoryMockDeleteNamespaceModelByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteNamespaceModelByIDParams contains parameters of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
}

// RepositoryMockDeleteNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
}

// RepositoryMockDeleteNamespaceModelByIDResults contains results of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDResults struct {
	err error
}

// RepositoryMockDeleteNamespaceModelByIDOrigins contains origins of expectations of the Repository.DeleteNamespaceModelByID
type RepositoryMockDeleteNamespaceModelByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Optional() *mRepositoryMockDeleteNamespaceModelByID {
	mmDeleteNamespaceModelByID.optional = true
	return mmDeleteNamespaceModelByID
}

// Expect sets up expected params for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmDeleteNamespaceModelByID.defaultExpectation.params = &RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}
	mmDeleteNamespaceModelByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmDeleteNamespaceModelByID.defaultExpectation.params) {
			mmDeleteNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmDeleteNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteNamespaceModelByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmDeleteNamespaceModelByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmDeleteNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{}
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.params != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Expect")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockDeleteNamespaceModelByIDParamPtrs{}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.paramPtrs.id = &id
	mmDeleteNamespaceModelByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string)) *mRepositoryMockDeleteNamespaceModelByID {
	if mmDeleteNamespaceModelByID.mock.inspectFuncDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteNamespaceModelByID")
	}

	mmDeleteNamespaceModelByID.mock.inspectFuncDeleteNamespaceModelByID = f

	return mmDeleteNamespaceModelByID
}

// Return sets up results that will be returned by Repository.DeleteNamespaceModelByID
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Return(err error) *RepositoryMock {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	if mmDeleteNamespaceModelByID.defaultExpectation == nil {
		mmDeleteNamespaceModelByID.defaultExpectation = &RepositoryMockDeleteNamespaceModelByIDExpectation{mock: mmDeleteNamespaceModelByID.mock}
	}
	mmDeleteNamespaceModelByID.defaultExpectation.results = &RepositoryMockDeleteNamespaceModelByIDResults{err}
	mmDeleteNamespaceModelByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.DeleteNamespaceModelByID method
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string) (err error)) *RepositoryMock {
	if mmDeleteNamespaceModelByID.defaultExpectation != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteNamespaceModelByID method")
	}

	if len(mmDeleteNamespaceModelByID.expectations) > 0 {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteNamespaceModelByID method")
	}

	mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID = f
	mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelByID.mock
}

// When sets expectation for the Repository.DeleteNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string) *RepositoryMockDeleteNamespaceModelByIDExpectation {
	if mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("RepositoryMock.DeleteNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteNamespaceModelByIDExpectation{
		mock:               mmDeleteNamespaceModelByID.mock,
		params:             &RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id},
		expectationOrigins: RepositoryMockDeleteNamespaceModelByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteNamespaceModelByID.expectations = append(mmDeleteNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteNamespaceModelByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteNamespaceModelByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteNamespaceModelByID should be invoked
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Times(n uint64) *mRepositoryMockDeleteNamespaceModelByID {
	if n == 0 {
		mmDeleteNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.DeleteNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteNamespaceModelByID.expectedInvocations, n)
	mmDeleteNamespaceModelByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteNamespaceModelByID
}

func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) invocationsDone() bool {
	if len(mmDeleteNamespaceModelByID.expectations) == 0 && mmDeleteNamespaceModelByID.defaultExpectation == nil && mmDeleteNamespaceModelByID.mock.funcDeleteNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.mock.afterDeleteNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteNamespaceModelByID implements mm_repository.Repository
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByID(ctx context.Context, ownerPermalink string, id string) (err error) {
	mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.beforeDeleteNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.afterDeleteNamespaceModelByIDCounter, 1)

	mmDeleteNamespaceModelByID.t.Helper()

	if mmDeleteNamespaceModelByID.inspectFuncDeleteNamespaceModelByID != nil {
		mmDeleteNamespaceModelByID.inspectFuncDeleteNamespaceModelByID(ctx, ownerPermalink, id)
	}

	mm_params := RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}

	// Record call args
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.mutex.Lock()
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.callArgs = append(mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.callArgs, &mm_params)
	mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteNamespaceModelByIDParams{ctx, ownerPermalink, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteNamespaceModelByID.t.Errorf("RepositoryMock.DeleteNamespaceModelByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteNamespaceModelByID.DeleteNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.DeleteNamespaceModelByID")
		}
		return (*mm_results).err
	}
	if mmDeleteNamespaceModelByID.funcDeleteNamespaceModelByID != nil {
		return mmDeleteNamespaceModelByID.funcDeleteNamespaceModelByID(ctx, ownerPermalink, id)
	}
	mmDeleteNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.DeleteNamespaceModelByID. %v %v %v", ctx, ownerPermalink, id)
	return
}

// DeleteNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.DeleteNamespaceModelByID invocations
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.afterDeleteNamespaceModelByIDCounter)
}

// DeleteNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.DeleteNamespaceModelByID invocations
func (mmDeleteNamespaceModelByID *RepositoryMock) DeleteNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteNamespaceModelByID.beforeDeleteNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteNamespaceModelByID *mRepositoryMockDeleteNamespaceModelByID) Calls() []*RepositoryMockDeleteNamespaceModelByIDParams {
	mmDeleteNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteNamespaceModelByIDParams, len(mmDeleteNamespaceModelByID.callArgs))
	copy(argCopy, mmDeleteNamespaceModelByID.callArgs)

	mmDeleteNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteNamespaceModelByIDDone returns true if the count of the DeleteNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteNamespaceModelByIDDone() bool {
	if m.DeleteNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteNamespaceModelByIDMock.invocationsDone()
}

// MinimockDeleteNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteNamespaceModelByIDInspect() {
	for _, e := range m.DeleteNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteNamespaceModelByIDMock.defaultExpectation != nil && afterDeleteNamespaceModelByIDCounter < 1 {
		if m.DeleteNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID at\n%s", m.DeleteNamespaceModelByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID at\n%s with params: %#v", m.DeleteNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteNamespaceModelByID != nil && afterDeleteNamespaceModelByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteNamespaceModelByID at\n%s", m.funcDeleteNamespaceModelByIDOrigin)
	}

	if !m.DeleteNamespaceModelByIDMock.invocationsDone() && afterDeleteNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteNamespaceModelByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteNamespaceModelByIDMock.expectedInvocations), m.DeleteNamespaceModelByIDMock.expectedInvocationsOrigin, afterDeleteNamespaceModelByIDCounter)
	}
}

type mRepositoryMockDeleteRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteRepositoryTagExpectation
	expectations       []*RepositoryMockDeleteRepositoryTagExpectation

	callArgs []*RepositoryMockDeleteRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteRepositoryTagExpectation specifies expectation struct of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteRepositoryTagParams
	paramPtrs          *RepositoryMockDeleteRepositoryTagParamPtrs
	expectationOrigins RepositoryMockDeleteRepositoryTagExpectationOrigins
	results            *RepositoryMockDeleteRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockDeleteRepositoryTagParams contains parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParams struct {
	ctx    context.Context
	digest string
}

// RepositoryMockDeleteRepositoryTagParamPtrs contains pointers to parameters of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagParamPtrs struct {
	ctx    *context.Context
	digest *string
}

// RepositoryMockDeleteRepositoryTagResults contains results of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagResults struct {
	err error
}

// RepositoryMockDeleteRepositoryTagOrigins contains origins of expectations of the Repository.DeleteRepositoryTag
type RepositoryMockDeleteRepositoryTagExpectationOrigins struct {
	origin       string
	originCtx    string
	originDigest string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Optional() *mRepositoryMockDeleteRepositoryTag {
	mmDeleteRepositoryTag.optional = true
	return mmDeleteRepositoryTag
}

// Expect sets up expected params for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Expect(ctx context.Context, digest string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by ExpectParams functions")
	}

	mmDeleteRepositoryTag.defaultExpectation.params = &RepositoryMockDeleteRepositoryTagParams{ctx, digest}
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteRepositoryTag.expectations {
		if minimock.Equal(e.params, mmDeleteRepositoryTag.defaultExpectation.params) {
			mmDeleteRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRepositoryTag.defaultExpectation.params)
		}
	}

	return mmDeleteRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// ExpectDigestParam2 sets up expected param digest for Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) ExpectDigestParam2(digest string) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{}
	}

	if mmDeleteRepositoryTag.defaultExpectation.params != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Expect")
	}

	if mmDeleteRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmDeleteRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockDeleteRepositoryTagParamPtrs{}
	}
	mmDeleteRepositoryTag.defaultExpectation.paramPtrs.digest = &digest
	mmDeleteRepositoryTag.defaultExpectation.expectationOrigins.originDigest = minimock.CallerInfo(1)

	return mmDeleteRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Inspect(f func(ctx context.Context, digest string)) *mRepositoryMockDeleteRepositoryTag {
	if mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteRepositoryTag")
	}

	mmDeleteRepositoryTag.mock.inspectFuncDeleteRepositoryTag = f

	return mmDeleteRepositoryTag
}

// Return sets up results that will be returned by Repository.DeleteRepositoryTag
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Return(err error) *RepositoryMock {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	if mmDeleteRepositoryTag.defaultExpectation == nil {
		mmDeleteRepositoryTag.defaultExpectation = &RepositoryMockDeleteRepositoryTagExpectation{mock: mmDeleteRepositoryTag.mock}
	}
	mmDeleteRepositoryTag.defaultExpectation.results = &RepositoryMockDeleteRepositoryTagResults{err}
	mmDeleteRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// Set uses given function f to mock the Repository.DeleteRepositoryTag method
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Set(f func(ctx context.Context, digest string) (err error)) *RepositoryMock {
	if mmDeleteRepositoryTag.defaultExpectation != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteRepositoryTag method")
	}

	if len(mmDeleteRepositoryTag.expectations) > 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteRepositoryTag method")
	}

	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag = f
	mmDeleteRepositoryTag.mock.funcDeleteRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag.mock
}

// When sets expectation for the Repository.DeleteRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) When(ctx context.Context, digest string) *RepositoryMockDeleteRepositoryTagExpectation {
	if mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.mock.t.Fatalf("RepositoryMock.DeleteRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteRepositoryTagExpectation{
		mock:               mmDeleteRepositoryTag.mock,
		params:             &RepositoryMockDeleteRepositoryTagParams{ctx, digest},
		expectationOrigins: RepositoryMockDeleteRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteRepositoryTag.expectations = append(mmDeleteRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteRepositoryTagExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteRepositoryTagResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteRepositoryTag should be invoked
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Times(n uint64) *mRepositoryMockDeleteRepositoryTag {
	if n == 0 {
		mmDeleteRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.DeleteRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteRepositoryTag.expectedInvocations, n)
	mmDeleteRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteRepositoryTag
}

func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) invocationsDone() bool {
	if len(mmDeleteRepositoryTag.expectations) == 0 && mmDeleteRepositoryTag.defaultExpectation == nil && mmDeleteRepositoryTag.mock.funcDeleteRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.mock.afterDeleteRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteRepositoryTag implements mm_repository.Repository
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTag(ctx context.Context, digest string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter, 1)

	mmDeleteRepositoryTag.t.Helper()

	if mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag != nil {
		mmDeleteRepositoryTag.inspectFuncDeleteRepositoryTag(ctx, digest)
	}

	mm_params := RepositoryMockDeleteRepositoryTagParams{ctx, digest}

	// Record call args
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Lock()
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs = append(mmDeleteRepositoryTag.DeleteRepositoryTagMock.callArgs, &mm_params)
	mmDeleteRepositoryTag.DeleteRepositoryTagMock.mutex.Unlock()

	for _, e := range mmDeleteRepositoryTag.DeleteRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteRepositoryTagParams{ctx, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameter digest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.originDigest, *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRepositoryTag.t.Errorf("RepositoryMock.DeleteRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRepositoryTag.DeleteRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRepositoryTag.t.Fatal("No results are set for the RepositoryMock.DeleteRepositoryTag")
		}
		return (*mm_results).err
	}
	if mmDeleteRepositoryTag.funcDeleteRepositoryTag != nil {
		return mmDeleteRepositoryTag.funcDeleteRepositoryTag(ctx, digest)
	}
	mmDeleteRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.DeleteRepositoryTag. %v %v", ctx, digest)
	return
}

// DeleteRepositoryTagAfterCounter returns a count of finished RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.afterDeleteRepositoryTagCounter)
}

// DeleteRepositoryTagBeforeCounter returns a count of RepositoryMock.DeleteRepositoryTag invocations
func (mmDeleteRepositoryTag *RepositoryMock) DeleteRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRepositoryTag.beforeDeleteRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRepositoryTag *mRepositoryMockDeleteRepositoryTag) Calls() []*RepositoryMockDeleteRepositoryTagParams {
	mmDeleteRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteRepositoryTagParams, len(mmDeleteRepositoryTag.callArgs))
	copy(argCopy, mmDeleteRepositoryTag.callArgs)

	mmDeleteRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRepositoryTagDone returns true if the count of the DeleteRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteRepositoryTagDone() bool {
	if m.DeleteRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteRepositoryTagMock.invocationsDone()
}

// MinimockDeleteRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteRepositoryTagInspect() {
	for _, e := range m.DeleteRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterDeleteRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRepositoryTagMock.defaultExpectation != nil && afterDeleteRepositoryTagCounter < 1 {
		if m.DeleteRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.DeleteRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s with params: %#v", m.DeleteRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.DeleteRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRepositoryTag != nil && afterDeleteRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteRepositoryTag at\n%s", m.funcDeleteRepositoryTagOrigin)
	}

	if !m.DeleteRepositoryTagMock.invocationsDone() && afterDeleteRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteRepositoryTagMock.expectedInvocations), m.DeleteRepositoryTagMock.expectedInvocationsOrigin, afterDeleteRepositoryTagCounter)
	}
}

type mRepositoryMockGetLatestModelRunByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelRunByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelRunByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelRunByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetLatestModelRunByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetLatestModelRunByModelUIDParams
	paramPtrs          *RepositoryMockGetLatestModelRunByModelUIDParamPtrs
	expectationOrigins RepositoryMockGetLatestModelRunByModelUIDExpectationOrigins
	results            *RepositoryMockGetLatestModelRunByModelUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetLatestModelRunByModelUIDParams contains parameters of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDParams struct {
	ctx      context.Context
	userUID  string
	modelUID string
}

// RepositoryMockGetLatestModelRunByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDParamPtrs struct {
	ctx      *context.Context
	userUID  *string
	modelUID *string
}

// RepositoryMockGetLatestModelRunByModelUIDResults contains results of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// RepositoryMockGetLatestModelRunByModelUIDOrigins contains origins of expectations of the Repository.GetLatestModelRunByModelUID
type RepositoryMockGetLatestModelRunByModelUIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserUID  string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Optional() *mRepositoryMockGetLatestModelRunByModelUID {
	mmGetLatestModelRunByModelUID.optional = true
	return mmGetLatestModelRunByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Expect(ctx context.Context, userUID string, modelUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelRunByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}
	mmGetLatestModelRunByModelUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestModelRunByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelRunByModelUID.defaultExpectation.params) {
			mmGetLatestModelRunByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelRunByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelRunByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestModelRunByModelUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestModelRunByModelUID
}

// ExpectUserUIDParam2 sets up expected param userUID for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectUserUIDParam2(userUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.userUID = &userUID
	mmGetLatestModelRunByModelUID.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmGetLatestModelRunByModelUID
}

// ExpectModelUIDParam3 sets up expected param modelUID for Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) ExpectModelUIDParam3(modelUID string) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{}
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmGetLatestModelRunByModelUID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmGetLatestModelRunByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Inspect(f func(ctx context.Context, userUID string, modelUID string)) *mRepositoryMockGetLatestModelRunByModelUID {
	if mmGetLatestModelRunByModelUID.mock.inspectFuncGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelRunByModelUID")
	}

	mmGetLatestModelRunByModelUID.mock.inspectFuncGetLatestModelRunByModelUID = f

	return mmGetLatestModelRunByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelRunByModelUID
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelRunByModelUIDExpectation{mock: mmGetLatestModelRunByModelUID.mock}
	}
	mmGetLatestModelRunByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelRunByModelUIDResults{modelRun, err}
	mmGetLatestModelRunByModelUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelRunByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelRunByModelUID method
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Set(f func(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetLatestModelRunByModelUID.defaultExpectation != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelRunByModelUID method")
	}

	if len(mmGetLatestModelRunByModelUID.expectations) > 0 {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelRunByModelUID method")
	}

	mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID = f
	mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUIDOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelRunByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelRunByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) When(ctx context.Context, userUID string, modelUID string) *RepositoryMockGetLatestModelRunByModelUIDExpectation {
	if mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelRunByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelRunByModelUIDExpectation{
		mock:               mmGetLatestModelRunByModelUID.mock,
		params:             &RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID},
		expectationOrigins: RepositoryMockGetLatestModelRunByModelUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestModelRunByModelUID.expectations = append(mmGetLatestModelRunByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelRunByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelRunByModelUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelRunByModelUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelRunByModelUID should be invoked
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelRunByModelUID {
	if n == 0 {
		mmGetLatestModelRunByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelRunByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelRunByModelUID.expectedInvocations, n)
	mmGetLatestModelRunByModelUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelRunByModelUID
}

func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelRunByModelUID.expectations) == 0 && mmGetLatestModelRunByModelUID.defaultExpectation == nil && mmGetLatestModelRunByModelUID.mock.funcGetLatestModelRunByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.mock.afterGetLatestModelRunByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelRunByModelUID implements mm_repository.Repository
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUID(ctx context.Context, userUID string, modelUID string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.beforeGetLatestModelRunByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.afterGetLatestModelRunByModelUIDCounter, 1)

	mmGetLatestModelRunByModelUID.t.Helper()

	if mmGetLatestModelRunByModelUID.inspectFuncGetLatestModelRunByModelUID != nil {
		mmGetLatestModelRunByModelUID.inspectFuncGetLatestModelRunByModelUID(ctx, userUID, modelUID)
	}

	mm_params := RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}

	// Record call args
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.mutex.Lock()
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.callArgs = append(mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelRunByModelUIDParams{ctx, userUID, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelRunByModelUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelRunByModelUID.GetLatestModelRunByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelRunByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelRunByModelUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetLatestModelRunByModelUID.funcGetLatestModelRunByModelUID != nil {
		return mmGetLatestModelRunByModelUID.funcGetLatestModelRunByModelUID(ctx, userUID, modelUID)
	}
	mmGetLatestModelRunByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelRunByModelUID. %v %v %v", ctx, userUID, modelUID)
	return
}

// GetLatestModelRunByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelRunByModelUID invocations
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.afterGetLatestModelRunByModelUIDCounter)
}

// GetLatestModelRunByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelRunByModelUID invocations
func (mmGetLatestModelRunByModelUID *RepositoryMock) GetLatestModelRunByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelRunByModelUID.beforeGetLatestModelRunByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelRunByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelRunByModelUID *mRepositoryMockGetLatestModelRunByModelUID) Calls() []*RepositoryMockGetLatestModelRunByModelUIDParams {
	mmGetLatestModelRunByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelRunByModelUIDParams, len(mmGetLatestModelRunByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelRunByModelUID.callArgs)

	mmGetLatestModelRunByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelRunByModelUIDDone returns true if the count of the GetLatestModelRunByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelRunByModelUIDDone() bool {
	if m.GetLatestModelRunByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelRunByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelRunByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelRunByModelUIDInspect() {
	for _, e := range m.GetLatestModelRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestModelRunByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelRunByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelRunByModelUIDMock.defaultExpectation != nil && afterGetLatestModelRunByModelUIDCounter < 1 {
		if m.GetLatestModelRunByModelUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID at\n%s", m.GetLatestModelRunByModelUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID at\n%s with params: %#v", m.GetLatestModelRunByModelUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestModelRunByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelRunByModelUID != nil && afterGetLatestModelRunByModelUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetLatestModelRunByModelUID at\n%s", m.funcGetLatestModelRunByModelUIDOrigin)
	}

	if !m.GetLatestModelRunByModelUIDMock.invocationsDone() && afterGetLatestModelRunByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelRunByModelUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelRunByModelUIDMock.expectedInvocations), m.GetLatestModelRunByModelUIDMock.expectedInvocationsOrigin, afterGetLatestModelRunByModelUIDCounter)
	}
}

type mRepositoryMockGetLatestModelVersionByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelVersionByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelVersionByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelVersionByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetLatestModelVersionByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetLatestModelVersionByModelUIDParams
	paramPtrs          *RepositoryMockGetLatestModelVersionByModelUIDParamPtrs
	expectationOrigins RepositoryMockGetLatestModelVersionByModelUIDExpectationOrigins
	results            *RepositoryMockGetLatestModelVersionByModelUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetLatestModelVersionByModelUIDParams contains parameters of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// RepositoryMockGetLatestModelVersionByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// RepositoryMockGetLatestModelVersionByModelUIDResults contains results of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDResults struct {
	version *datamodel.ModelVersion
	err     error
}

// RepositoryMockGetLatestModelVersionByModelUIDOrigins contains origins of expectations of the Repository.GetLatestModelVersionByModelUID
type RepositoryMockGetLatestModelVersionByModelUIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Optional() *mRepositoryMockGetLatestModelVersionByModelUID {
	mmGetLatestModelVersionByModelUID.optional = true
	return mmGetLatestModelVersionByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Expect(ctx context.Context, modelUID uuid.UUID) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelVersionByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}
	mmGetLatestModelVersionByModelUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestModelVersionByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelVersionByModelUID.defaultExpectation.params) {
			mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelVersionByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelVersionByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestModelVersionByModelUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestModelVersionByModelUID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmGetLatestModelVersionByModelUID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmGetLatestModelVersionByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mRepositoryMockGetLatestModelVersionByModelUID {
	if mmGetLatestModelVersionByModelUID.mock.inspectFuncGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelVersionByModelUID")
	}

	mmGetLatestModelVersionByModelUID.mock.inspectFuncGetLatestModelVersionByModelUID = f

	return mmGetLatestModelVersionByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelVersionByModelUID
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Return(version *datamodel.ModelVersion, err error) *RepositoryMock {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionByModelUIDExpectation{mock: mmGetLatestModelVersionByModelUID.mock}
	}
	mmGetLatestModelVersionByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelVersionByModelUIDResults{version, err}
	mmGetLatestModelVersionByModelUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelVersionByModelUID method
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Set(f func(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmGetLatestModelVersionByModelUID.defaultExpectation != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelVersionByModelUID method")
	}

	if len(mmGetLatestModelVersionByModelUID.expectations) > 0 {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelVersionByModelUID method")
	}

	mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID = f
	mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUIDOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelVersionByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) When(ctx context.Context, modelUID uuid.UUID) *RepositoryMockGetLatestModelVersionByModelUIDExpectation {
	if mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelVersionByModelUIDExpectation{
		mock:               mmGetLatestModelVersionByModelUID.mock,
		params:             &RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID},
		expectationOrigins: RepositoryMockGetLatestModelVersionByModelUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestModelVersionByModelUID.expectations = append(mmGetLatestModelVersionByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelVersionByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelVersionByModelUIDExpectation) Then(version *datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelVersionByModelUIDResults{version, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelVersionByModelUID should be invoked
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelVersionByModelUID {
	if n == 0 {
		mmGetLatestModelVersionByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelVersionByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelVersionByModelUID.expectedInvocations, n)
	mmGetLatestModelVersionByModelUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionByModelUID
}

func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelVersionByModelUID.expectations) == 0 && mmGetLatestModelVersionByModelUID.defaultExpectation == nil && mmGetLatestModelVersionByModelUID.mock.funcGetLatestModelVersionByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.mock.afterGetLatestModelVersionByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelVersionByModelUID implements mm_repository.Repository
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUID(ctx context.Context, modelUID uuid.UUID) (version *datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.beforeGetLatestModelVersionByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.afterGetLatestModelVersionByModelUIDCounter, 1)

	mmGetLatestModelVersionByModelUID.t.Helper()

	if mmGetLatestModelVersionByModelUID.inspectFuncGetLatestModelVersionByModelUID != nil {
		mmGetLatestModelVersionByModelUID.inspectFuncGetLatestModelVersionByModelUID(ctx, modelUID)
	}

	mm_params := RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}

	// Record call args
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.mutex.Lock()
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.callArgs = append(mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.version, e.results.err
		}
	}

	if mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelVersionByModelUIDParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelVersionByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionByModelUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelVersionByModelUID.GetLatestModelVersionByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelVersionByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelVersionByModelUID")
		}
		return (*mm_results).version, (*mm_results).err
	}
	if mmGetLatestModelVersionByModelUID.funcGetLatestModelVersionByModelUID != nil {
		return mmGetLatestModelVersionByModelUID.funcGetLatestModelVersionByModelUID(ctx, modelUID)
	}
	mmGetLatestModelVersionByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelVersionByModelUID. %v %v", ctx, modelUID)
	return
}

// GetLatestModelVersionByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelVersionByModelUID invocations
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.afterGetLatestModelVersionByModelUIDCounter)
}

// GetLatestModelVersionByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelVersionByModelUID invocations
func (mmGetLatestModelVersionByModelUID *RepositoryMock) GetLatestModelVersionByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionByModelUID.beforeGetLatestModelVersionByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelVersionByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelVersionByModelUID *mRepositoryMockGetLatestModelVersionByModelUID) Calls() []*RepositoryMockGetLatestModelVersionByModelUIDParams {
	mmGetLatestModelVersionByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelVersionByModelUIDParams, len(mmGetLatestModelVersionByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelVersionByModelUID.callArgs)

	mmGetLatestModelVersionByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelVersionByModelUIDDone returns true if the count of the GetLatestModelVersionByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelVersionByModelUIDDone() bool {
	if m.GetLatestModelVersionByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelVersionByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelVersionByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelVersionByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelVersionByModelUIDInspect() {
	for _, e := range m.GetLatestModelVersionByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestModelVersionByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelVersionByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelVersionByModelUIDMock.defaultExpectation != nil && afterGetLatestModelVersionByModelUIDCounter < 1 {
		if m.GetLatestModelVersionByModelUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID at\n%s", m.GetLatestModelVersionByModelUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID at\n%s with params: %#v", m.GetLatestModelVersionByModelUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestModelVersionByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelVersionByModelUID != nil && afterGetLatestModelVersionByModelUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionByModelUID at\n%s", m.funcGetLatestModelVersionByModelUIDOrigin)
	}

	if !m.GetLatestModelVersionByModelUIDMock.invocationsDone() && afterGetLatestModelVersionByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelVersionByModelUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelVersionByModelUIDMock.expectedInvocations), m.GetLatestModelVersionByModelUIDMock.expectedInvocationsOrigin, afterGetLatestModelVersionByModelUIDCounter)
	}
}

type mRepositoryMockGetLatestModelVersionRunByModelUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation
	expectations       []*RepositoryMockGetLatestModelVersionRunByModelUIDExpectation

	callArgs []*RepositoryMockGetLatestModelVersionRunByModelUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetLatestModelVersionRunByModelUIDExpectation specifies expectation struct of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetLatestModelVersionRunByModelUIDParams
	paramPtrs          *RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs
	expectationOrigins RepositoryMockGetLatestModelVersionRunByModelUIDExpectationOrigins
	results            *RepositoryMockGetLatestModelVersionRunByModelUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetLatestModelVersionRunByModelUIDParams contains parameters of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDParams struct {
	ctx      context.Context
	userUID  string
	modelUID string
	version  string
}

// RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs contains pointers to parameters of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs struct {
	ctx      *context.Context
	userUID  *string
	modelUID *string
	version  *string
}

// RepositoryMockGetLatestModelVersionRunByModelUIDResults contains results of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// RepositoryMockGetLatestModelVersionRunByModelUIDOrigins contains origins of expectations of the Repository.GetLatestModelVersionRunByModelUID
type RepositoryMockGetLatestModelVersionRunByModelUIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originUserUID  string
	originModelUID string
	originVersion  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Optional() *mRepositoryMockGetLatestModelVersionRunByModelUID {
	mmGetLatestModelVersionRunByModelUID.optional = true
	return mmGetLatestModelVersionRunByModelUID
}

// Expect sets up expected params for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Expect(ctx context.Context, userUID string, modelUID string, version string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by ExpectParams functions")
	}

	mmGetLatestModelVersionRunByModelUID.defaultExpectation.params = &RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLatestModelVersionRunByModelUID.expectations {
		if minimock.Equal(e.params, mmGetLatestModelVersionRunByModelUID.defaultExpectation.params) {
			mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLatestModelVersionRunByModelUID.defaultExpectation.params)
		}
	}

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectUserUIDParam2 sets up expected param userUID for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectUserUIDParam2(userUID string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.userUID = &userUID
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectModelUIDParam3 sets up expected param modelUID for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectModelUIDParam3(modelUID string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmGetLatestModelVersionRunByModelUID
}

// ExpectVersionParam4 sets up expected param version for Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) ExpectVersionParam4(version string) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{}
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.params != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Expect")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs = &RepositoryMockGetLatestModelVersionRunByModelUIDParamPtrs{}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.paramPtrs.version = &version
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmGetLatestModelVersionRunByModelUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Inspect(f func(ctx context.Context, userUID string, modelUID string, version string)) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if mmGetLatestModelVersionRunByModelUID.mock.inspectFuncGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetLatestModelVersionRunByModelUID")
	}

	mmGetLatestModelVersionRunByModelUID.mock.inspectFuncGetLatestModelVersionRunByModelUID = f

	return mmGetLatestModelVersionRunByModelUID
}

// Return sets up results that will be returned by Repository.GetLatestModelVersionRunByModelUID
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	if mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil {
		mmGetLatestModelVersionRunByModelUID.defaultExpectation = &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{mock: mmGetLatestModelVersionRunByModelUID.mock}
	}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.results = &RepositoryMockGetLatestModelVersionRunByModelUIDResults{modelRun, err}
	mmGetLatestModelVersionRunByModelUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionRunByModelUID.mock
}

// Set uses given function f to mock the Repository.GetLatestModelVersionRunByModelUID method
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Set(f func(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetLatestModelVersionRunByModelUID.defaultExpectation != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetLatestModelVersionRunByModelUID method")
	}

	if len(mmGetLatestModelVersionRunByModelUID.expectations) > 0 {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetLatestModelVersionRunByModelUID method")
	}

	mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID = f
	mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUIDOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionRunByModelUID.mock
}

// When sets expectation for the Repository.GetLatestModelVersionRunByModelUID which will trigger the result defined by the following
// Then helper
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) When(ctx context.Context, userUID string, modelUID string, version string) *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation {
	if mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("RepositoryMock.GetLatestModelVersionRunByModelUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetLatestModelVersionRunByModelUIDExpectation{
		mock:               mmGetLatestModelVersionRunByModelUID.mock,
		params:             &RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version},
		expectationOrigins: RepositoryMockGetLatestModelVersionRunByModelUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLatestModelVersionRunByModelUID.expectations = append(mmGetLatestModelVersionRunByModelUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetLatestModelVersionRunByModelUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetLatestModelVersionRunByModelUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetLatestModelVersionRunByModelUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetLatestModelVersionRunByModelUID should be invoked
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Times(n uint64) *mRepositoryMockGetLatestModelVersionRunByModelUID {
	if n == 0 {
		mmGetLatestModelVersionRunByModelUID.mock.t.Fatalf("Times of RepositoryMock.GetLatestModelVersionRunByModelUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLatestModelVersionRunByModelUID.expectedInvocations, n)
	mmGetLatestModelVersionRunByModelUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLatestModelVersionRunByModelUID
}

func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) invocationsDone() bool {
	if len(mmGetLatestModelVersionRunByModelUID.expectations) == 0 && mmGetLatestModelVersionRunByModelUID.defaultExpectation == nil && mmGetLatestModelVersionRunByModelUID.mock.funcGetLatestModelVersionRunByModelUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.mock.afterGetLatestModelVersionRunByModelUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLatestModelVersionRunByModelUID implements mm_repository.Repository
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUID(ctx context.Context, userUID string, modelUID string, version string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.beforeGetLatestModelVersionRunByModelUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.afterGetLatestModelVersionRunByModelUIDCounter, 1)

	mmGetLatestModelVersionRunByModelUID.t.Helper()

	if mmGetLatestModelVersionRunByModelUID.inspectFuncGetLatestModelVersionRunByModelUID != nil {
		mmGetLatestModelVersionRunByModelUID.inspectFuncGetLatestModelVersionRunByModelUID(ctx, userUID, modelUID, version)
	}

	mm_params := RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}

	// Record call args
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.mutex.Lock()
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.callArgs = append(mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.callArgs, &mm_params)
	mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.mutex.Unlock()

	for _, e := range mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetLatestModelVersionRunByModelUIDParams{ctx, userUID, modelUID, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLatestModelVersionRunByModelUID.t.Errorf("RepositoryMock.GetLatestModelVersionRunByModelUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLatestModelVersionRunByModelUID.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLatestModelVersionRunByModelUID.t.Fatal("No results are set for the RepositoryMock.GetLatestModelVersionRunByModelUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetLatestModelVersionRunByModelUID.funcGetLatestModelVersionRunByModelUID != nil {
		return mmGetLatestModelVersionRunByModelUID.funcGetLatestModelVersionRunByModelUID(ctx, userUID, modelUID, version)
	}
	mmGetLatestModelVersionRunByModelUID.t.Fatalf("Unexpected call to RepositoryMock.GetLatestModelVersionRunByModelUID. %v %v %v %v", ctx, userUID, modelUID, version)
	return
}

// GetLatestModelVersionRunByModelUIDAfterCounter returns a count of finished RepositoryMock.GetLatestModelVersionRunByModelUID invocations
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.afterGetLatestModelVersionRunByModelUIDCounter)
}

// GetLatestModelVersionRunByModelUIDBeforeCounter returns a count of RepositoryMock.GetLatestModelVersionRunByModelUID invocations
func (mmGetLatestModelVersionRunByModelUID *RepositoryMock) GetLatestModelVersionRunByModelUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLatestModelVersionRunByModelUID.beforeGetLatestModelVersionRunByModelUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetLatestModelVersionRunByModelUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLatestModelVersionRunByModelUID *mRepositoryMockGetLatestModelVersionRunByModelUID) Calls() []*RepositoryMockGetLatestModelVersionRunByModelUIDParams {
	mmGetLatestModelVersionRunByModelUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetLatestModelVersionRunByModelUIDParams, len(mmGetLatestModelVersionRunByModelUID.callArgs))
	copy(argCopy, mmGetLatestModelVersionRunByModelUID.callArgs)

	mmGetLatestModelVersionRunByModelUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLatestModelVersionRunByModelUIDDone returns true if the count of the GetLatestModelVersionRunByModelUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetLatestModelVersionRunByModelUIDDone() bool {
	if m.GetLatestModelVersionRunByModelUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLatestModelVersionRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLatestModelVersionRunByModelUIDMock.invocationsDone()
}

// MinimockGetLatestModelVersionRunByModelUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetLatestModelVersionRunByModelUIDInspect() {
	for _, e := range m.GetLatestModelVersionRunByModelUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLatestModelVersionRunByModelUIDCounter := mm_atomic.LoadUint64(&m.afterGetLatestModelVersionRunByModelUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation != nil && afterGetLatestModelVersionRunByModelUIDCounter < 1 {
		if m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID at\n%s", m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID at\n%s with params: %#v", m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetLatestModelVersionRunByModelUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLatestModelVersionRunByModelUID != nil && afterGetLatestModelVersionRunByModelUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetLatestModelVersionRunByModelUID at\n%s", m.funcGetLatestModelVersionRunByModelUIDOrigin)
	}

	if !m.GetLatestModelVersionRunByModelUIDMock.invocationsDone() && afterGetLatestModelVersionRunByModelUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetLatestModelVersionRunByModelUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLatestModelVersionRunByModelUIDMock.expectedInvocations), m.GetLatestModelVersionRunByModelUIDMock.expectedInvocationsOrigin, afterGetLatestModelVersionRunByModelUIDCounter)
	}
}

type mRepositoryMockGetModelByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelByUIDExpectation
	expectations       []*RepositoryMockGetModelByUIDExpectation

	callArgs []*RepositoryMockGetModelByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelByUIDExpectation specifies expectation struct of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelByUIDParams
	paramPtrs          *RepositoryMockGetModelByUIDParamPtrs
	expectationOrigins RepositoryMockGetModelByUIDExpectationOrigins
	results            *RepositoryMockGetModelByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelByUIDParams contains parameters of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	includeAvatar bool
}

// RepositoryMockGetModelByUIDParamPtrs contains pointers to parameters of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	includeAvatar *bool
}

// RepositoryMockGetModelByUIDResults contains results of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDResults struct {
	mp1 *datamodel.Model
	err error
}

// RepositoryMockGetModelByUIDOrigins contains origins of expectations of the Repository.GetModelByUID
type RepositoryMockGetModelByUIDExpectationOrigins struct {
	origin              string
	originCtx           string
	originUid           string
	originIsBasicView   string
	originIncludeAvatar string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Optional() *mRepositoryMockGetModelByUID {
	mmGetModelByUID.optional = true
	return mmGetModelByUID
}

// Expect sets up expected params for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by ExpectParams functions")
	}

	mmGetModelByUID.defaultExpectation.params = &RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}
	mmGetModelByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelByUID.expectations {
		if minimock.Equal(e.params, mmGetModelByUID.defaultExpectation.params) {
			mmGetModelByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelByUID.defaultExpectation.params)
		}
	}

	return mmGetModelByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelByUID
}

// ExpectUidParam2 sets up expected param uid for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetModelByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetModelByUID
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetModelByUID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetModelByUID
}

// ExpectIncludeAvatarParam4 sets up expected param includeAvatar for Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) ExpectIncludeAvatarParam4(includeAvatar bool) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{}
	}

	if mmGetModelByUID.defaultExpectation.params != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Expect")
	}

	if mmGetModelByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDParamPtrs{}
	}
	mmGetModelByUID.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar
	mmGetModelByUID.defaultExpectation.expectationOrigins.originIncludeAvatar = minimock.CallerInfo(1)

	return mmGetModelByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetModelByUID {
	if mmGetModelByUID.mock.inspectFuncGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelByUID")
	}

	mmGetModelByUID.mock.inspectFuncGetModelByUID = f

	return mmGetModelByUID
}

// Return sets up results that will be returned by Repository.GetModelByUID
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	if mmGetModelByUID.defaultExpectation == nil {
		mmGetModelByUID.defaultExpectation = &RepositoryMockGetModelByUIDExpectation{mock: mmGetModelByUID.mock}
	}
	mmGetModelByUID.defaultExpectation.results = &RepositoryMockGetModelByUIDResults{mp1, err}
	mmGetModelByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelByUID.mock
}

// Set uses given function f to mock the Repository.GetModelByUID method
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetModelByUID.defaultExpectation != nil {
		mmGetModelByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelByUID method")
	}

	if len(mmGetModelByUID.expectations) > 0 {
		mmGetModelByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelByUID method")
	}

	mmGetModelByUID.mock.funcGetModelByUID = f
	mmGetModelByUID.mock.funcGetModelByUIDOrigin = minimock.CallerInfo(1)
	return mmGetModelByUID.mock
}

// When sets expectation for the Repository.GetModelByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelByUID *mRepositoryMockGetModelByUID) When(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *RepositoryMockGetModelByUIDExpectation {
	if mmGetModelByUID.mock.funcGetModelByUID != nil {
		mmGetModelByUID.mock.t.Fatalf("RepositoryMock.GetModelByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelByUIDExpectation{
		mock:               mmGetModelByUID.mock,
		params:             &RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar},
		expectationOrigins: RepositoryMockGetModelByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelByUID.expectations = append(mmGetModelByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelByUIDExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelByUIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelByUID should be invoked
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Times(n uint64) *mRepositoryMockGetModelByUID {
	if n == 0 {
		mmGetModelByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelByUID.expectedInvocations, n)
	mmGetModelByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelByUID
}

func (mmGetModelByUID *mRepositoryMockGetModelByUID) invocationsDone() bool {
	if len(mmGetModelByUID.expectations) == 0 && mmGetModelByUID.defaultExpectation == nil && mmGetModelByUID.mock.funcGetModelByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelByUID.mock.afterGetModelByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelByUID implements mm_repository.Repository
func (mmGetModelByUID *RepositoryMock) GetModelByUID(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetModelByUID.beforeGetModelByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelByUID.afterGetModelByUIDCounter, 1)

	mmGetModelByUID.t.Helper()

	if mmGetModelByUID.inspectFuncGetModelByUID != nil {
		mmGetModelByUID.inspectFuncGetModelByUID(ctx, uid, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}

	// Record call args
	mmGetModelByUID.GetModelByUIDMock.mutex.Lock()
	mmGetModelByUID.GetModelByUIDMock.callArgs = append(mmGetModelByUID.GetModelByUIDMock.callArgs, &mm_params)
	mmGetModelByUID.GetModelByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelByUID.GetModelByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelByUID.GetModelByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelByUID.GetModelByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelByUIDParams{ctx, uid, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUID.GetModelByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUID.GetModelByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUID.GetModelByUIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameter includeAvatar, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUID.GetModelByUIDMock.defaultExpectation.expectationOrigins.originIncludeAvatar, *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelByUID.t.Errorf("RepositoryMock.GetModelByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelByUID.GetModelByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelByUID.GetModelByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelByUID.t.Fatal("No results are set for the RepositoryMock.GetModelByUID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelByUID.funcGetModelByUID != nil {
		return mmGetModelByUID.funcGetModelByUID(ctx, uid, isBasicView, includeAvatar)
	}
	mmGetModelByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelByUID. %v %v %v %v", ctx, uid, isBasicView, includeAvatar)
	return
}

// GetModelByUIDAfterCounter returns a count of finished RepositoryMock.GetModelByUID invocations
func (mmGetModelByUID *RepositoryMock) GetModelByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUID.afterGetModelByUIDCounter)
}

// GetModelByUIDBeforeCounter returns a count of RepositoryMock.GetModelByUID invocations
func (mmGetModelByUID *RepositoryMock) GetModelByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUID.beforeGetModelByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelByUID *mRepositoryMockGetModelByUID) Calls() []*RepositoryMockGetModelByUIDParams {
	mmGetModelByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelByUIDParams, len(mmGetModelByUID.callArgs))
	copy(argCopy, mmGetModelByUID.callArgs)

	mmGetModelByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelByUIDDone returns true if the count of the GetModelByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelByUIDDone() bool {
	if m.GetModelByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelByUIDMock.invocationsDone()
}

// MinimockGetModelByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelByUIDInspect() {
	for _, e := range m.GetModelByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelByUIDMock.defaultExpectation != nil && afterGetModelByUIDCounter < 1 {
		if m.GetModelByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUID at\n%s", m.GetModelByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUID at\n%s with params: %#v", m.GetModelByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetModelByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelByUID != nil && afterGetModelByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelByUID at\n%s", m.funcGetModelByUIDOrigin)
	}

	if !m.GetModelByUIDMock.invocationsDone() && afterGetModelByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelByUIDMock.expectedInvocations), m.GetModelByUIDMock.expectedInvocationsOrigin, afterGetModelByUIDCounter)
	}
}

type mRepositoryMockGetModelByUIDAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelByUIDAdminExpectation
	expectations       []*RepositoryMockGetModelByUIDAdminExpectation

	callArgs []*RepositoryMockGetModelByUIDAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelByUIDAdminExpectation specifies expectation struct of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelByUIDAdminParams
	paramPtrs          *RepositoryMockGetModelByUIDAdminParamPtrs
	expectationOrigins RepositoryMockGetModelByUIDAdminExpectationOrigins
	results            *RepositoryMockGetModelByUIDAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelByUIDAdminParams contains parameters of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminParams struct {
	ctx           context.Context
	uid           uuid.UUID
	isBasicView   bool
	includeAvatar bool
}

// RepositoryMockGetModelByUIDAdminParamPtrs contains pointers to parameters of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminParamPtrs struct {
	ctx           *context.Context
	uid           *uuid.UUID
	isBasicView   *bool
	includeAvatar *bool
}

// RepositoryMockGetModelByUIDAdminResults contains results of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminResults struct {
	mp1 *datamodel.Model
	err error
}

// RepositoryMockGetModelByUIDAdminOrigins contains origins of expectations of the Repository.GetModelByUIDAdmin
type RepositoryMockGetModelByUIDAdminExpectationOrigins struct {
	origin              string
	originCtx           string
	originUid           string
	originIsBasicView   string
	originIncludeAvatar string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Optional() *mRepositoryMockGetModelByUIDAdmin {
	mmGetModelByUIDAdmin.optional = true
	return mmGetModelByUIDAdmin
}

// Expect sets up expected params for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Expect(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by ExpectParams functions")
	}

	mmGetModelByUIDAdmin.defaultExpectation.params = &RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}
	mmGetModelByUIDAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelByUIDAdmin.expectations {
		if minimock.Equal(e.params, mmGetModelByUIDAdmin.defaultExpectation.params) {
			mmGetModelByUIDAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelByUIDAdmin.defaultExpectation.params)
		}
	}

	return mmGetModelByUIDAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelByUIDAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelByUIDAdmin
}

// ExpectUidParam2 sets up expected param uid for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectUidParam2(uid uuid.UUID) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.uid = &uid
	mmGetModelByUIDAdmin.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetModelByUIDAdmin
}

// ExpectIsBasicViewParam3 sets up expected param isBasicView for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectIsBasicViewParam3(isBasicView bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetModelByUIDAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetModelByUIDAdmin
}

// ExpectIncludeAvatarParam4 sets up expected param includeAvatar for Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) ExpectIncludeAvatarParam4(includeAvatar bool) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{}
	}

	if mmGetModelByUIDAdmin.defaultExpectation.params != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Expect")
	}

	if mmGetModelByUIDAdmin.defaultExpectation.paramPtrs == nil {
		mmGetModelByUIDAdmin.defaultExpectation.paramPtrs = &RepositoryMockGetModelByUIDAdminParamPtrs{}
	}
	mmGetModelByUIDAdmin.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar
	mmGetModelByUIDAdmin.defaultExpectation.expectationOrigins.originIncludeAvatar = minimock.CallerInfo(1)

	return mmGetModelByUIDAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Inspect(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetModelByUIDAdmin {
	if mmGetModelByUIDAdmin.mock.inspectFuncGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelByUIDAdmin")
	}

	mmGetModelByUIDAdmin.mock.inspectFuncGetModelByUIDAdmin = f

	return mmGetModelByUIDAdmin
}

// Return sets up results that will be returned by Repository.GetModelByUIDAdmin
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	if mmGetModelByUIDAdmin.defaultExpectation == nil {
		mmGetModelByUIDAdmin.defaultExpectation = &RepositoryMockGetModelByUIDAdminExpectation{mock: mmGetModelByUIDAdmin.mock}
	}
	mmGetModelByUIDAdmin.defaultExpectation.results = &RepositoryMockGetModelByUIDAdminResults{mp1, err}
	mmGetModelByUIDAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelByUIDAdmin.mock
}

// Set uses given function f to mock the Repository.GetModelByUIDAdmin method
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Set(f func(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetModelByUIDAdmin.defaultExpectation != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelByUIDAdmin method")
	}

	if len(mmGetModelByUIDAdmin.expectations) > 0 {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelByUIDAdmin method")
	}

	mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin = f
	mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdminOrigin = minimock.CallerInfo(1)
	return mmGetModelByUIDAdmin.mock
}

// When sets expectation for the Repository.GetModelByUIDAdmin which will trigger the result defined by the following
// Then helper
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) When(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) *RepositoryMockGetModelByUIDAdminExpectation {
	if mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.mock.t.Fatalf("RepositoryMock.GetModelByUIDAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelByUIDAdminExpectation{
		mock:               mmGetModelByUIDAdmin.mock,
		params:             &RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar},
		expectationOrigins: RepositoryMockGetModelByUIDAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelByUIDAdmin.expectations = append(mmGetModelByUIDAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelByUIDAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelByUIDAdminExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelByUIDAdminResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelByUIDAdmin should be invoked
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Times(n uint64) *mRepositoryMockGetModelByUIDAdmin {
	if n == 0 {
		mmGetModelByUIDAdmin.mock.t.Fatalf("Times of RepositoryMock.GetModelByUIDAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelByUIDAdmin.expectedInvocations, n)
	mmGetModelByUIDAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelByUIDAdmin
}

func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) invocationsDone() bool {
	if len(mmGetModelByUIDAdmin.expectations) == 0 && mmGetModelByUIDAdmin.defaultExpectation == nil && mmGetModelByUIDAdmin.mock.funcGetModelByUIDAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.mock.afterGetModelByUIDAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelByUIDAdmin implements mm_repository.Repository
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdmin(ctx context.Context, uid uuid.UUID, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetModelByUIDAdmin.beforeGetModelByUIDAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelByUIDAdmin.afterGetModelByUIDAdminCounter, 1)

	mmGetModelByUIDAdmin.t.Helper()

	if mmGetModelByUIDAdmin.inspectFuncGetModelByUIDAdmin != nil {
		mmGetModelByUIDAdmin.inspectFuncGetModelByUIDAdmin(ctx, uid, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}

	// Record call args
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.mutex.Lock()
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.callArgs = append(mmGetModelByUIDAdmin.GetModelByUIDAdminMock.callArgs, &mm_params)
	mmGetModelByUIDAdmin.GetModelByUIDAdminMock.mutex.Unlock()

	for _, e := range mmGetModelByUIDAdmin.GetModelByUIDAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelByUIDAdminParams{ctx, uid, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameter includeAvatar, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.originIncludeAvatar, *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelByUIDAdmin.t.Errorf("RepositoryMock.GetModelByUIDAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelByUIDAdmin.GetModelByUIDAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelByUIDAdmin.t.Fatal("No results are set for the RepositoryMock.GetModelByUIDAdmin")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelByUIDAdmin.funcGetModelByUIDAdmin != nil {
		return mmGetModelByUIDAdmin.funcGetModelByUIDAdmin(ctx, uid, isBasicView, includeAvatar)
	}
	mmGetModelByUIDAdmin.t.Fatalf("Unexpected call to RepositoryMock.GetModelByUIDAdmin. %v %v %v %v", ctx, uid, isBasicView, includeAvatar)
	return
}

// GetModelByUIDAdminAfterCounter returns a count of finished RepositoryMock.GetModelByUIDAdmin invocations
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.afterGetModelByUIDAdminCounter)
}

// GetModelByUIDAdminBeforeCounter returns a count of RepositoryMock.GetModelByUIDAdmin invocations
func (mmGetModelByUIDAdmin *RepositoryMock) GetModelByUIDAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelByUIDAdmin.beforeGetModelByUIDAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelByUIDAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelByUIDAdmin *mRepositoryMockGetModelByUIDAdmin) Calls() []*RepositoryMockGetModelByUIDAdminParams {
	mmGetModelByUIDAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelByUIDAdminParams, len(mmGetModelByUIDAdmin.callArgs))
	copy(argCopy, mmGetModelByUIDAdmin.callArgs)

	mmGetModelByUIDAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelByUIDAdminDone returns true if the count of the GetModelByUIDAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelByUIDAdminDone() bool {
	if m.GetModelByUIDAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelByUIDAdminMock.invocationsDone()
}

// MinimockGetModelByUIDAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelByUIDAdminInspect() {
	for _, e := range m.GetModelByUIDAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelByUIDAdminCounter := mm_atomic.LoadUint64(&m.afterGetModelByUIDAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelByUIDAdminMock.defaultExpectation != nil && afterGetModelByUIDAdminCounter < 1 {
		if m.GetModelByUIDAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin at\n%s", m.GetModelByUIDAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin at\n%s with params: %#v", m.GetModelByUIDAdminMock.defaultExpectation.expectationOrigins.origin, *m.GetModelByUIDAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelByUIDAdmin != nil && afterGetModelByUIDAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelByUIDAdmin at\n%s", m.funcGetModelByUIDAdminOrigin)
	}

	if !m.GetModelByUIDAdminMock.invocationsDone() && afterGetModelByUIDAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelByUIDAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelByUIDAdminMock.expectedInvocations), m.GetModelByUIDAdminMock.expectedInvocationsOrigin, afterGetModelByUIDAdminCounter)
	}
}

type mRepositoryMockGetModelDefinition struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelDefinitionExpectation
	expectations       []*RepositoryMockGetModelDefinitionExpectation

	callArgs []*RepositoryMockGetModelDefinitionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelDefinitionExpectation specifies expectation struct of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelDefinitionParams
	paramPtrs          *RepositoryMockGetModelDefinitionParamPtrs
	expectationOrigins RepositoryMockGetModelDefinitionExpectationOrigins
	results            *RepositoryMockGetModelDefinitionResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelDefinitionParams contains parameters of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionParams struct {
	id string
}

// RepositoryMockGetModelDefinitionParamPtrs contains pointers to parameters of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionParamPtrs struct {
	id *string
}

// RepositoryMockGetModelDefinitionResults contains results of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionResults struct {
	mp1 *datamodel.ModelDefinition
	err error
}

// RepositoryMockGetModelDefinitionOrigins contains origins of expectations of the Repository.GetModelDefinition
type RepositoryMockGetModelDefinitionExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Optional() *mRepositoryMockGetModelDefinition {
	mmGetModelDefinition.optional = true
	return mmGetModelDefinition
}

// Expect sets up expected params for Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Expect(id string) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by ExpectParams functions")
	}

	mmGetModelDefinition.defaultExpectation.params = &RepositoryMockGetModelDefinitionParams{id}
	mmGetModelDefinition.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelDefinition.expectations {
		if minimock.Equal(e.params, mmGetModelDefinition.defaultExpectation.params) {
			mmGetModelDefinition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelDefinition.defaultExpectation.params)
		}
	}

	return mmGetModelDefinition
}

// ExpectIdParam1 sets up expected param id for Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) ExpectIdParam1(id string) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{}
	}

	if mmGetModelDefinition.defaultExpectation.params != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Expect")
	}

	if mmGetModelDefinition.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinition.defaultExpectation.paramPtrs = &RepositoryMockGetModelDefinitionParamPtrs{}
	}
	mmGetModelDefinition.defaultExpectation.paramPtrs.id = &id
	mmGetModelDefinition.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetModelDefinition
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Inspect(f func(id string)) *mRepositoryMockGetModelDefinition {
	if mmGetModelDefinition.mock.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelDefinition")
	}

	mmGetModelDefinition.mock.inspectFuncGetModelDefinition = f

	return mmGetModelDefinition
}

// Return sets up results that will be returned by Repository.GetModelDefinition
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Return(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	if mmGetModelDefinition.defaultExpectation == nil {
		mmGetModelDefinition.defaultExpectation = &RepositoryMockGetModelDefinitionExpectation{mock: mmGetModelDefinition.mock}
	}
	mmGetModelDefinition.defaultExpectation.results = &RepositoryMockGetModelDefinitionResults{mp1, err}
	mmGetModelDefinition.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition.mock
}

// Set uses given function f to mock the Repository.GetModelDefinition method
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Set(f func(id string) (mp1 *datamodel.ModelDefinition, err error)) *RepositoryMock {
	if mmGetModelDefinition.defaultExpectation != nil {
		mmGetModelDefinition.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelDefinition method")
	}

	if len(mmGetModelDefinition.expectations) > 0 {
		mmGetModelDefinition.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelDefinition method")
	}

	mmGetModelDefinition.mock.funcGetModelDefinition = f
	mmGetModelDefinition.mock.funcGetModelDefinitionOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition.mock
}

// When sets expectation for the Repository.GetModelDefinition which will trigger the result defined by the following
// Then helper
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) When(id string) *RepositoryMockGetModelDefinitionExpectation {
	if mmGetModelDefinition.mock.funcGetModelDefinition != nil {
		mmGetModelDefinition.mock.t.Fatalf("RepositoryMock.GetModelDefinition mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelDefinitionExpectation{
		mock:               mmGetModelDefinition.mock,
		params:             &RepositoryMockGetModelDefinitionParams{id},
		expectationOrigins: RepositoryMockGetModelDefinitionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelDefinition.expectations = append(mmGetModelDefinition.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelDefinition return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelDefinitionExpectation) Then(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelDefinitionResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelDefinition should be invoked
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Times(n uint64) *mRepositoryMockGetModelDefinition {
	if n == 0 {
		mmGetModelDefinition.mock.t.Fatalf("Times of RepositoryMock.GetModelDefinition mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelDefinition.expectedInvocations, n)
	mmGetModelDefinition.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinition
}

func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) invocationsDone() bool {
	if len(mmGetModelDefinition.expectations) == 0 && mmGetModelDefinition.defaultExpectation == nil && mmGetModelDefinition.mock.funcGetModelDefinition == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.mock.afterGetModelDefinitionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelDefinition.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelDefinition implements mm_repository.Repository
func (mmGetModelDefinition *RepositoryMock) GetModelDefinition(id string) (mp1 *datamodel.ModelDefinition, err error) {
	mm_atomic.AddUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter, 1)

	mmGetModelDefinition.t.Helper()

	if mmGetModelDefinition.inspectFuncGetModelDefinition != nil {
		mmGetModelDefinition.inspectFuncGetModelDefinition(id)
	}

	mm_params := RepositoryMockGetModelDefinitionParams{id}

	// Record call args
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Lock()
	mmGetModelDefinition.GetModelDefinitionMock.callArgs = append(mmGetModelDefinition.GetModelDefinitionMock.callArgs, &mm_params)
	mmGetModelDefinition.GetModelDefinitionMock.mutex.Unlock()

	for _, e := range mmGetModelDefinition.GetModelDefinitionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelDefinitionParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetModelDefinition.t.Errorf("RepositoryMock.GetModelDefinition got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelDefinition.t.Errorf("RepositoryMock.GetModelDefinition got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelDefinition.GetModelDefinitionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelDefinition.t.Fatal("No results are set for the RepositoryMock.GetModelDefinition")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelDefinition.funcGetModelDefinition != nil {
		return mmGetModelDefinition.funcGetModelDefinition(id)
	}
	mmGetModelDefinition.t.Fatalf("Unexpected call to RepositoryMock.GetModelDefinition. %v", id)
	return
}

// GetModelDefinitionAfterCounter returns a count of finished RepositoryMock.GetModelDefinition invocations
func (mmGetModelDefinition *RepositoryMock) GetModelDefinitionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.afterGetModelDefinitionCounter)
}

// GetModelDefinitionBeforeCounter returns a count of RepositoryMock.GetModelDefinition invocations
func (mmGetModelDefinition *RepositoryMock) GetModelDefinitionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinition.beforeGetModelDefinitionCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelDefinition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelDefinition *mRepositoryMockGetModelDefinition) Calls() []*RepositoryMockGetModelDefinitionParams {
	mmGetModelDefinition.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelDefinitionParams, len(mmGetModelDefinition.callArgs))
	copy(argCopy, mmGetModelDefinition.callArgs)

	mmGetModelDefinition.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelDefinitionDone returns true if the count of the GetModelDefinition invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelDefinitionDone() bool {
	if m.GetModelDefinitionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelDefinitionMock.invocationsDone()
}

// MinimockGetModelDefinitionInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelDefinitionInspect() {
	for _, e := range m.GetModelDefinitionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelDefinitionCounter := mm_atomic.LoadUint64(&m.afterGetModelDefinitionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelDefinitionMock.defaultExpectation != nil && afterGetModelDefinitionCounter < 1 {
		if m.GetModelDefinitionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition at\n%s", m.GetModelDefinitionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition at\n%s with params: %#v", m.GetModelDefinitionMock.defaultExpectation.expectationOrigins.origin, *m.GetModelDefinitionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelDefinition != nil && afterGetModelDefinitionCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelDefinition at\n%s", m.funcGetModelDefinitionOrigin)
	}

	if !m.GetModelDefinitionMock.invocationsDone() && afterGetModelDefinitionCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelDefinition at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelDefinitionMock.expectedInvocations), m.GetModelDefinitionMock.expectedInvocationsOrigin, afterGetModelDefinitionCounter)
	}
}

type mRepositoryMockGetModelDefinitionByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelDefinitionByUIDExpectation
	expectations       []*RepositoryMockGetModelDefinitionByUIDExpectation

	callArgs []*RepositoryMockGetModelDefinitionByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelDefinitionByUIDExpectation specifies expectation struct of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelDefinitionByUIDParams
	paramPtrs          *RepositoryMockGetModelDefinitionByUIDParamPtrs
	expectationOrigins RepositoryMockGetModelDefinitionByUIDExpectationOrigins
	results            *RepositoryMockGetModelDefinitionByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelDefinitionByUIDParams contains parameters of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDParams struct {
	uid uuid.UUID
}

// RepositoryMockGetModelDefinitionByUIDParamPtrs contains pointers to parameters of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDParamPtrs struct {
	uid *uuid.UUID
}

// RepositoryMockGetModelDefinitionByUIDResults contains results of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDResults struct {
	mp1 *datamodel.ModelDefinition
	err error
}

// RepositoryMockGetModelDefinitionByUIDOrigins contains origins of expectations of the Repository.GetModelDefinitionByUID
type RepositoryMockGetModelDefinitionByUIDExpectationOrigins struct {
	origin    string
	originUid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Optional() *mRepositoryMockGetModelDefinitionByUID {
	mmGetModelDefinitionByUID.optional = true
	return mmGetModelDefinitionByUID
}

// Expect sets up expected params for Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Expect(uid uuid.UUID) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{}
	}

	if mmGetModelDefinitionByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by ExpectParams functions")
	}

	mmGetModelDefinitionByUID.defaultExpectation.params = &RepositoryMockGetModelDefinitionByUIDParams{uid}
	mmGetModelDefinitionByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelDefinitionByUID.expectations {
		if minimock.Equal(e.params, mmGetModelDefinitionByUID.defaultExpectation.params) {
			mmGetModelDefinitionByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelDefinitionByUID.defaultExpectation.params)
		}
	}

	return mmGetModelDefinitionByUID
}

// ExpectUidParam1 sets up expected param uid for Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) ExpectUidParam1(uid uuid.UUID) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{}
	}

	if mmGetModelDefinitionByUID.defaultExpectation.params != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Expect")
	}

	if mmGetModelDefinitionByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelDefinitionByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelDefinitionByUIDParamPtrs{}
	}
	mmGetModelDefinitionByUID.defaultExpectation.paramPtrs.uid = &uid
	mmGetModelDefinitionByUID.defaultExpectation.expectationOrigins.originUid = minimock.CallerInfo(1)

	return mmGetModelDefinitionByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Inspect(f func(uid uuid.UUID)) *mRepositoryMockGetModelDefinitionByUID {
	if mmGetModelDefinitionByUID.mock.inspectFuncGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelDefinitionByUID")
	}

	mmGetModelDefinitionByUID.mock.inspectFuncGetModelDefinitionByUID = f

	return mmGetModelDefinitionByUID
}

// Return sets up results that will be returned by Repository.GetModelDefinitionByUID
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Return(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	if mmGetModelDefinitionByUID.defaultExpectation == nil {
		mmGetModelDefinitionByUID.defaultExpectation = &RepositoryMockGetModelDefinitionByUIDExpectation{mock: mmGetModelDefinitionByUID.mock}
	}
	mmGetModelDefinitionByUID.defaultExpectation.results = &RepositoryMockGetModelDefinitionByUIDResults{mp1, err}
	mmGetModelDefinitionByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinitionByUID.mock
}

// Set uses given function f to mock the Repository.GetModelDefinitionByUID method
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Set(f func(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error)) *RepositoryMock {
	if mmGetModelDefinitionByUID.defaultExpectation != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelDefinitionByUID method")
	}

	if len(mmGetModelDefinitionByUID.expectations) > 0 {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelDefinitionByUID method")
	}

	mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID = f
	mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUIDOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinitionByUID.mock
}

// When sets expectation for the Repository.GetModelDefinitionByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) When(uid uuid.UUID) *RepositoryMockGetModelDefinitionByUIDExpectation {
	if mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.mock.t.Fatalf("RepositoryMock.GetModelDefinitionByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelDefinitionByUIDExpectation{
		mock:               mmGetModelDefinitionByUID.mock,
		params:             &RepositoryMockGetModelDefinitionByUIDParams{uid},
		expectationOrigins: RepositoryMockGetModelDefinitionByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelDefinitionByUID.expectations = append(mmGetModelDefinitionByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelDefinitionByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelDefinitionByUIDExpectation) Then(mp1 *datamodel.ModelDefinition, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelDefinitionByUIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetModelDefinitionByUID should be invoked
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Times(n uint64) *mRepositoryMockGetModelDefinitionByUID {
	if n == 0 {
		mmGetModelDefinitionByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelDefinitionByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelDefinitionByUID.expectedInvocations, n)
	mmGetModelDefinitionByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelDefinitionByUID
}

func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) invocationsDone() bool {
	if len(mmGetModelDefinitionByUID.expectations) == 0 && mmGetModelDefinitionByUID.defaultExpectation == nil && mmGetModelDefinitionByUID.mock.funcGetModelDefinitionByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.mock.afterGetModelDefinitionByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelDefinitionByUID implements mm_repository.Repository
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUID(uid uuid.UUID) (mp1 *datamodel.ModelDefinition, err error) {
	mm_atomic.AddUint64(&mmGetModelDefinitionByUID.beforeGetModelDefinitionByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelDefinitionByUID.afterGetModelDefinitionByUIDCounter, 1)

	mmGetModelDefinitionByUID.t.Helper()

	if mmGetModelDefinitionByUID.inspectFuncGetModelDefinitionByUID != nil {
		mmGetModelDefinitionByUID.inspectFuncGetModelDefinitionByUID(uid)
	}

	mm_params := RepositoryMockGetModelDefinitionByUIDParams{uid}

	// Record call args
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.mutex.Lock()
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.callArgs = append(mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.callArgs, &mm_params)
	mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelDefinitionByUIDParams{uid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.uid != nil && !minimock.Equal(*mm_want_ptrs.uid, mm_got.uid) {
				mmGetModelDefinitionByUID.t.Errorf("RepositoryMock.GetModelDefinitionByUID got unexpected parameter uid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.expectationOrigins.originUid, *mm_want_ptrs.uid, mm_got.uid, minimock.Diff(*mm_want_ptrs.uid, mm_got.uid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelDefinitionByUID.t.Errorf("RepositoryMock.GetModelDefinitionByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelDefinitionByUID.GetModelDefinitionByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelDefinitionByUID.t.Fatal("No results are set for the RepositoryMock.GetModelDefinitionByUID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetModelDefinitionByUID.funcGetModelDefinitionByUID != nil {
		return mmGetModelDefinitionByUID.funcGetModelDefinitionByUID(uid)
	}
	mmGetModelDefinitionByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelDefinitionByUID. %v", uid)
	return
}

// GetModelDefinitionByUIDAfterCounter returns a count of finished RepositoryMock.GetModelDefinitionByUID invocations
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.afterGetModelDefinitionByUIDCounter)
}

// GetModelDefinitionByUIDBeforeCounter returns a count of RepositoryMock.GetModelDefinitionByUID invocations
func (mmGetModelDefinitionByUID *RepositoryMock) GetModelDefinitionByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelDefinitionByUID.beforeGetModelDefinitionByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelDefinitionByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelDefinitionByUID *mRepositoryMockGetModelDefinitionByUID) Calls() []*RepositoryMockGetModelDefinitionByUIDParams {
	mmGetModelDefinitionByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelDefinitionByUIDParams, len(mmGetModelDefinitionByUID.callArgs))
	copy(argCopy, mmGetModelDefinitionByUID.callArgs)

	mmGetModelDefinitionByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelDefinitionByUIDDone returns true if the count of the GetModelDefinitionByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelDefinitionByUIDDone() bool {
	if m.GetModelDefinitionByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelDefinitionByUIDMock.invocationsDone()
}

// MinimockGetModelDefinitionByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelDefinitionByUIDInspect() {
	for _, e := range m.GetModelDefinitionByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelDefinitionByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelDefinitionByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelDefinitionByUIDMock.defaultExpectation != nil && afterGetModelDefinitionByUIDCounter < 1 {
		if m.GetModelDefinitionByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID at\n%s", m.GetModelDefinitionByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID at\n%s with params: %#v", m.GetModelDefinitionByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetModelDefinitionByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelDefinitionByUID != nil && afterGetModelDefinitionByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelDefinitionByUID at\n%s", m.funcGetModelDefinitionByUIDOrigin)
	}

	if !m.GetModelDefinitionByUIDMock.invocationsDone() && afterGetModelDefinitionByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelDefinitionByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelDefinitionByUIDMock.expectedInvocations), m.GetModelDefinitionByUIDMock.expectedInvocationsOrigin, afterGetModelDefinitionByUIDCounter)
	}
}

type mRepositoryMockGetModelRunByUID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelRunByUIDExpectation
	expectations       []*RepositoryMockGetModelRunByUIDExpectation

	callArgs []*RepositoryMockGetModelRunByUIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelRunByUIDExpectation specifies expectation struct of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelRunByUIDParams
	paramPtrs          *RepositoryMockGetModelRunByUIDParamPtrs
	expectationOrigins RepositoryMockGetModelRunByUIDExpectationOrigins
	results            *RepositoryMockGetModelRunByUIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelRunByUIDParams contains parameters of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDParams struct {
	ctx        context.Context
	triggerUID string
}

// RepositoryMockGetModelRunByUIDParamPtrs contains pointers to parameters of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDParamPtrs struct {
	ctx        *context.Context
	triggerUID *string
}

// RepositoryMockGetModelRunByUIDResults contains results of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDResults struct {
	modelRun *datamodel.ModelRun
	err      error
}

// RepositoryMockGetModelRunByUIDOrigins contains origins of expectations of the Repository.GetModelRunByUID
type RepositoryMockGetModelRunByUIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originTriggerUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Optional() *mRepositoryMockGetModelRunByUID {
	mmGetModelRunByUID.optional = true
	return mmGetModelRunByUID
}

// Expect sets up expected params for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Expect(ctx context.Context, triggerUID string) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by ExpectParams functions")
	}

	mmGetModelRunByUID.defaultExpectation.params = &RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}
	mmGetModelRunByUID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelRunByUID.expectations {
		if minimock.Equal(e.params, mmGetModelRunByUID.defaultExpectation.params) {
			mmGetModelRunByUID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelRunByUID.defaultExpectation.params)
		}
	}

	return mmGetModelRunByUID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.params != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Expect")
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelRunByUIDParamPtrs{}
	}
	mmGetModelRunByUID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelRunByUID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelRunByUID
}

// ExpectTriggerUIDParam2 sets up expected param triggerUID for Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) ExpectTriggerUIDParam2(triggerUID string) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{}
	}

	if mmGetModelRunByUID.defaultExpectation.params != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Expect")
	}

	if mmGetModelRunByUID.defaultExpectation.paramPtrs == nil {
		mmGetModelRunByUID.defaultExpectation.paramPtrs = &RepositoryMockGetModelRunByUIDParamPtrs{}
	}
	mmGetModelRunByUID.defaultExpectation.paramPtrs.triggerUID = &triggerUID
	mmGetModelRunByUID.defaultExpectation.expectationOrigins.originTriggerUID = minimock.CallerInfo(1)

	return mmGetModelRunByUID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Inspect(f func(ctx context.Context, triggerUID string)) *mRepositoryMockGetModelRunByUID {
	if mmGetModelRunByUID.mock.inspectFuncGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelRunByUID")
	}

	mmGetModelRunByUID.mock.inspectFuncGetModelRunByUID = f

	return mmGetModelRunByUID
}

// Return sets up results that will be returned by Repository.GetModelRunByUID
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Return(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	if mmGetModelRunByUID.defaultExpectation == nil {
		mmGetModelRunByUID.defaultExpectation = &RepositoryMockGetModelRunByUIDExpectation{mock: mmGetModelRunByUID.mock}
	}
	mmGetModelRunByUID.defaultExpectation.results = &RepositoryMockGetModelRunByUIDResults{modelRun, err}
	mmGetModelRunByUID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelRunByUID.mock
}

// Set uses given function f to mock the Repository.GetModelRunByUID method
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Set(f func(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error)) *RepositoryMock {
	if mmGetModelRunByUID.defaultExpectation != nil {
		mmGetModelRunByUID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelRunByUID method")
	}

	if len(mmGetModelRunByUID.expectations) > 0 {
		mmGetModelRunByUID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelRunByUID method")
	}

	mmGetModelRunByUID.mock.funcGetModelRunByUID = f
	mmGetModelRunByUID.mock.funcGetModelRunByUIDOrigin = minimock.CallerInfo(1)
	return mmGetModelRunByUID.mock
}

// When sets expectation for the Repository.GetModelRunByUID which will trigger the result defined by the following
// Then helper
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) When(ctx context.Context, triggerUID string) *RepositoryMockGetModelRunByUIDExpectation {
	if mmGetModelRunByUID.mock.funcGetModelRunByUID != nil {
		mmGetModelRunByUID.mock.t.Fatalf("RepositoryMock.GetModelRunByUID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelRunByUIDExpectation{
		mock:               mmGetModelRunByUID.mock,
		params:             &RepositoryMockGetModelRunByUIDParams{ctx, triggerUID},
		expectationOrigins: RepositoryMockGetModelRunByUIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelRunByUID.expectations = append(mmGetModelRunByUID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelRunByUID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelRunByUIDExpectation) Then(modelRun *datamodel.ModelRun, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelRunByUIDResults{modelRun, err}
	return e.mock
}

// Times sets number of times Repository.GetModelRunByUID should be invoked
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Times(n uint64) *mRepositoryMockGetModelRunByUID {
	if n == 0 {
		mmGetModelRunByUID.mock.t.Fatalf("Times of RepositoryMock.GetModelRunByUID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelRunByUID.expectedInvocations, n)
	mmGetModelRunByUID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelRunByUID
}

func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) invocationsDone() bool {
	if len(mmGetModelRunByUID.expectations) == 0 && mmGetModelRunByUID.defaultExpectation == nil && mmGetModelRunByUID.mock.funcGetModelRunByUID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelRunByUID.mock.afterGetModelRunByUIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelRunByUID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelRunByUID implements mm_repository.Repository
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUID(ctx context.Context, triggerUID string) (modelRun *datamodel.ModelRun, err error) {
	mm_atomic.AddUint64(&mmGetModelRunByUID.beforeGetModelRunByUIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelRunByUID.afterGetModelRunByUIDCounter, 1)

	mmGetModelRunByUID.t.Helper()

	if mmGetModelRunByUID.inspectFuncGetModelRunByUID != nil {
		mmGetModelRunByUID.inspectFuncGetModelRunByUID(ctx, triggerUID)
	}

	mm_params := RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}

	// Record call args
	mmGetModelRunByUID.GetModelRunByUIDMock.mutex.Lock()
	mmGetModelRunByUID.GetModelRunByUIDMock.callArgs = append(mmGetModelRunByUID.GetModelRunByUIDMock.callArgs, &mm_params)
	mmGetModelRunByUID.GetModelRunByUIDMock.mutex.Unlock()

	for _, e := range mmGetModelRunByUID.GetModelRunByUIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRun, e.results.err
		}
	}

	if mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelRunByUIDParams{ctx, triggerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.triggerUID != nil && !minimock.Equal(*mm_want_ptrs.triggerUID, mm_got.triggerUID) {
				mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameter triggerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.expectationOrigins.originTriggerUID, *mm_want_ptrs.triggerUID, mm_got.triggerUID, minimock.Diff(*mm_want_ptrs.triggerUID, mm_got.triggerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelRunByUID.t.Errorf("RepositoryMock.GetModelRunByUID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelRunByUID.GetModelRunByUIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelRunByUID.t.Fatal("No results are set for the RepositoryMock.GetModelRunByUID")
		}
		return (*mm_results).modelRun, (*mm_results).err
	}
	if mmGetModelRunByUID.funcGetModelRunByUID != nil {
		return mmGetModelRunByUID.funcGetModelRunByUID(ctx, triggerUID)
	}
	mmGetModelRunByUID.t.Fatalf("Unexpected call to RepositoryMock.GetModelRunByUID. %v %v", ctx, triggerUID)
	return
}

// GetModelRunByUIDAfterCounter returns a count of finished RepositoryMock.GetModelRunByUID invocations
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelRunByUID.afterGetModelRunByUIDCounter)
}

// GetModelRunByUIDBeforeCounter returns a count of RepositoryMock.GetModelRunByUID invocations
func (mmGetModelRunByUID *RepositoryMock) GetModelRunByUIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelRunByUID.beforeGetModelRunByUIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelRunByUID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelRunByUID *mRepositoryMockGetModelRunByUID) Calls() []*RepositoryMockGetModelRunByUIDParams {
	mmGetModelRunByUID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelRunByUIDParams, len(mmGetModelRunByUID.callArgs))
	copy(argCopy, mmGetModelRunByUID.callArgs)

	mmGetModelRunByUID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelRunByUIDDone returns true if the count of the GetModelRunByUID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelRunByUIDDone() bool {
	if m.GetModelRunByUIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelRunByUIDMock.invocationsDone()
}

// MinimockGetModelRunByUIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelRunByUIDInspect() {
	for _, e := range m.GetModelRunByUIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelRunByUIDCounter := mm_atomic.LoadUint64(&m.afterGetModelRunByUIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelRunByUIDMock.defaultExpectation != nil && afterGetModelRunByUIDCounter < 1 {
		if m.GetModelRunByUIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID at\n%s", m.GetModelRunByUIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID at\n%s with params: %#v", m.GetModelRunByUIDMock.defaultExpectation.expectationOrigins.origin, *m.GetModelRunByUIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelRunByUID != nil && afterGetModelRunByUIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelRunByUID at\n%s", m.funcGetModelRunByUIDOrigin)
	}

	if !m.GetModelRunByUIDMock.invocationsDone() && afterGetModelRunByUIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelRunByUID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelRunByUIDMock.expectedInvocations), m.GetModelRunByUIDMock.expectedInvocationsOrigin, afterGetModelRunByUIDCounter)
	}
}

type mRepositoryMockGetModelVersionByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetModelVersionByIDExpectation
	expectations       []*RepositoryMockGetModelVersionByIDExpectation

	callArgs []*RepositoryMockGetModelVersionByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetModelVersionByIDExpectation specifies expectation struct of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetModelVersionByIDParams
	paramPtrs          *RepositoryMockGetModelVersionByIDParamPtrs
	expectationOrigins RepositoryMockGetModelVersionByIDExpectationOrigins
	results            *RepositoryMockGetModelVersionByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetModelVersionByIDParams contains parameters of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
}

// RepositoryMockGetModelVersionByIDParamPtrs contains pointers to parameters of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
}

// RepositoryMockGetModelVersionByIDResults contains results of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDResults struct {
	version *datamodel.ModelVersion
	err     error
}

// RepositoryMockGetModelVersionByIDOrigins contains origins of expectations of the Repository.GetModelVersionByID
type RepositoryMockGetModelVersionByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelUID  string
	originVersionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Optional() *mRepositoryMockGetModelVersionByID {
	mmGetModelVersionByID.optional = true
	return mmGetModelVersionByID
}

// Expect sets up expected params for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by ExpectParams functions")
	}

	mmGetModelVersionByID.defaultExpectation.params = &RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}
	mmGetModelVersionByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetModelVersionByID.expectations {
		if minimock.Equal(e.params, mmGetModelVersionByID.defaultExpectation.params) {
			mmGetModelVersionByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetModelVersionByID.defaultExpectation.params)
		}
	}

	return mmGetModelVersionByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetModelVersionByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetModelVersionByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmGetModelVersionByID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmGetModelVersionByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{}
	}

	if mmGetModelVersionByID.defaultExpectation.params != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Expect")
	}

	if mmGetModelVersionByID.defaultExpectation.paramPtrs == nil {
		mmGetModelVersionByID.defaultExpectation.paramPtrs = &RepositoryMockGetModelVersionByIDParamPtrs{}
	}
	mmGetModelVersionByID.defaultExpectation.paramPtrs.versionID = &versionID
	mmGetModelVersionByID.defaultExpectation.expectationOrigins.originVersionID = minimock.CallerInfo(1)

	return mmGetModelVersionByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string)) *mRepositoryMockGetModelVersionByID {
	if mmGetModelVersionByID.mock.inspectFuncGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetModelVersionByID")
	}

	mmGetModelVersionByID.mock.inspectFuncGetModelVersionByID = f

	return mmGetModelVersionByID
}

// Return sets up results that will be returned by Repository.GetModelVersionByID
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Return(version *datamodel.ModelVersion, err error) *RepositoryMock {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	if mmGetModelVersionByID.defaultExpectation == nil {
		mmGetModelVersionByID.defaultExpectation = &RepositoryMockGetModelVersionByIDExpectation{mock: mmGetModelVersionByID.mock}
	}
	mmGetModelVersionByID.defaultExpectation.results = &RepositoryMockGetModelVersionByIDResults{version, err}
	mmGetModelVersionByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetModelVersionByID.mock
}

// Set uses given function f to mock the Repository.GetModelVersionByID method
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmGetModelVersionByID.defaultExpectation != nil {
		mmGetModelVersionByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetModelVersionByID method")
	}

	if len(mmGetModelVersionByID.expectations) > 0 {
		mmGetModelVersionByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetModelVersionByID method")
	}

	mmGetModelVersionByID.mock.funcGetModelVersionByID = f
	mmGetModelVersionByID.mock.funcGetModelVersionByIDOrigin = minimock.CallerInfo(1)
	return mmGetModelVersionByID.mock
}

// When sets expectation for the Repository.GetModelVersionByID which will trigger the result defined by the following
// Then helper
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) When(ctx context.Context, modelUID uuid.UUID, versionID string) *RepositoryMockGetModelVersionByIDExpectation {
	if mmGetModelVersionByID.mock.funcGetModelVersionByID != nil {
		mmGetModelVersionByID.mock.t.Fatalf("RepositoryMock.GetModelVersionByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetModelVersionByIDExpectation{
		mock:               mmGetModelVersionByID.mock,
		params:             &RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID},
		expectationOrigins: RepositoryMockGetModelVersionByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetModelVersionByID.expectations = append(mmGetModelVersionByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetModelVersionByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetModelVersionByIDExpectation) Then(version *datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockGetModelVersionByIDResults{version, err}
	return e.mock
}

// Times sets number of times Repository.GetModelVersionByID should be invoked
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Times(n uint64) *mRepositoryMockGetModelVersionByID {
	if n == 0 {
		mmGetModelVersionByID.mock.t.Fatalf("Times of RepositoryMock.GetModelVersionByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetModelVersionByID.expectedInvocations, n)
	mmGetModelVersionByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetModelVersionByID
}

func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) invocationsDone() bool {
	if len(mmGetModelVersionByID.expectations) == 0 && mmGetModelVersionByID.defaultExpectation == nil && mmGetModelVersionByID.mock.funcGetModelVersionByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetModelVersionByID.mock.afterGetModelVersionByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetModelVersionByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetModelVersionByID implements mm_repository.Repository
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByID(ctx context.Context, modelUID uuid.UUID, versionID string) (version *datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmGetModelVersionByID.beforeGetModelVersionByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetModelVersionByID.afterGetModelVersionByIDCounter, 1)

	mmGetModelVersionByID.t.Helper()

	if mmGetModelVersionByID.inspectFuncGetModelVersionByID != nil {
		mmGetModelVersionByID.inspectFuncGetModelVersionByID(ctx, modelUID, versionID)
	}

	mm_params := RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}

	// Record call args
	mmGetModelVersionByID.GetModelVersionByIDMock.mutex.Lock()
	mmGetModelVersionByID.GetModelVersionByIDMock.callArgs = append(mmGetModelVersionByID.GetModelVersionByIDMock.callArgs, &mm_params)
	mmGetModelVersionByID.GetModelVersionByIDMock.mutex.Unlock()

	for _, e := range mmGetModelVersionByID.GetModelVersionByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.version, e.results.err
		}
	}

	if mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetModelVersionByIDParams{ctx, modelUID, versionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameter versionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.expectationOrigins.originVersionID, *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetModelVersionByID.t.Errorf("RepositoryMock.GetModelVersionByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetModelVersionByID.GetModelVersionByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetModelVersionByID.t.Fatal("No results are set for the RepositoryMock.GetModelVersionByID")
		}
		return (*mm_results).version, (*mm_results).err
	}
	if mmGetModelVersionByID.funcGetModelVersionByID != nil {
		return mmGetModelVersionByID.funcGetModelVersionByID(ctx, modelUID, versionID)
	}
	mmGetModelVersionByID.t.Fatalf("Unexpected call to RepositoryMock.GetModelVersionByID. %v %v %v", ctx, modelUID, versionID)
	return
}

// GetModelVersionByIDAfterCounter returns a count of finished RepositoryMock.GetModelVersionByID invocations
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelVersionByID.afterGetModelVersionByIDCounter)
}

// GetModelVersionByIDBeforeCounter returns a count of RepositoryMock.GetModelVersionByID invocations
func (mmGetModelVersionByID *RepositoryMock) GetModelVersionByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetModelVersionByID.beforeGetModelVersionByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetModelVersionByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetModelVersionByID *mRepositoryMockGetModelVersionByID) Calls() []*RepositoryMockGetModelVersionByIDParams {
	mmGetModelVersionByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetModelVersionByIDParams, len(mmGetModelVersionByID.callArgs))
	copy(argCopy, mmGetModelVersionByID.callArgs)

	mmGetModelVersionByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetModelVersionByIDDone returns true if the count of the GetModelVersionByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetModelVersionByIDDone() bool {
	if m.GetModelVersionByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetModelVersionByIDMock.invocationsDone()
}

// MinimockGetModelVersionByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetModelVersionByIDInspect() {
	for _, e := range m.GetModelVersionByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetModelVersionByIDCounter := mm_atomic.LoadUint64(&m.afterGetModelVersionByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetModelVersionByIDMock.defaultExpectation != nil && afterGetModelVersionByIDCounter < 1 {
		if m.GetModelVersionByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID at\n%s", m.GetModelVersionByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID at\n%s with params: %#v", m.GetModelVersionByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetModelVersionByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetModelVersionByID != nil && afterGetModelVersionByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetModelVersionByID at\n%s", m.funcGetModelVersionByIDOrigin)
	}

	if !m.GetModelVersionByIDMock.invocationsDone() && afterGetModelVersionByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetModelVersionByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetModelVersionByIDMock.expectedInvocations), m.GetModelVersionByIDMock.expectedInvocationsOrigin, afterGetModelVersionByIDCounter)
	}
}

type mRepositoryMockGetNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetNamespaceModelByIDExpectation
	expectations       []*RepositoryMockGetNamespaceModelByIDExpectation

	callArgs []*RepositoryMockGetNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetNamespaceModelByIDExpectation specifies expectation struct of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetNamespaceModelByIDParams
	paramPtrs          *RepositoryMockGetNamespaceModelByIDParamPtrs
	expectationOrigins RepositoryMockGetNamespaceModelByIDExpectationOrigins
	results            *RepositoryMockGetNamespaceModelByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetNamespaceModelByIDParams contains parameters of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	isBasicView    bool
	includeAvatar  bool
}

// RepositoryMockGetNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	isBasicView    *bool
	includeAvatar  *bool
}

// RepositoryMockGetNamespaceModelByIDResults contains results of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDResults struct {
	mp1 *datamodel.Model
	err error
}

// RepositoryMockGetNamespaceModelByIDOrigins contains origins of expectations of the Repository.GetNamespaceModelByID
type RepositoryMockGetNamespaceModelByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originIsBasicView    string
	originIncludeAvatar  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Optional() *mRepositoryMockGetNamespaceModelByID {
	mmGetNamespaceModelByID.optional = true
	return mmGetNamespaceModelByID
}

// Expect sets up expected params for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmGetNamespaceModelByID.defaultExpectation.params = &RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmGetNamespaceModelByID.defaultExpectation.params) {
			mmGetNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmGetNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmGetNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.id = &id
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetNamespaceModelByID
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmGetNamespaceModelByID
}

// ExpectIncludeAvatarParam5 sets up expected param includeAvatar for Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) ExpectIncludeAvatarParam5(includeAvatar bool) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{}
	}

	if mmGetNamespaceModelByID.defaultExpectation.params != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Expect")
	}

	if mmGetNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmGetNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockGetNamespaceModelByIDParamPtrs{}
	}
	mmGetNamespaceModelByID.defaultExpectation.paramPtrs.includeAvatar = &includeAvatar
	mmGetNamespaceModelByID.defaultExpectation.expectationOrigins.originIncludeAvatar = minimock.CallerInfo(1)

	return mmGetNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool)) *mRepositoryMockGetNamespaceModelByID {
	if mmGetNamespaceModelByID.mock.inspectFuncGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetNamespaceModelByID")
	}

	mmGetNamespaceModelByID.mock.inspectFuncGetNamespaceModelByID = f

	return mmGetNamespaceModelByID
}

// Return sets up results that will be returned by Repository.GetNamespaceModelByID
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Return(mp1 *datamodel.Model, err error) *RepositoryMock {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	if mmGetNamespaceModelByID.defaultExpectation == nil {
		mmGetNamespaceModelByID.defaultExpectation = &RepositoryMockGetNamespaceModelByIDExpectation{mock: mmGetNamespaceModelByID.mock}
	}
	mmGetNamespaceModelByID.defaultExpectation.results = &RepositoryMockGetNamespaceModelByIDResults{mp1, err}
	mmGetNamespaceModelByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.GetNamespaceModelByID method
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error)) *RepositoryMock {
	if mmGetNamespaceModelByID.defaultExpectation != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.GetNamespaceModelByID method")
	}

	if len(mmGetNamespaceModelByID.expectations) > 0 {
		mmGetNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.GetNamespaceModelByID method")
	}

	mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID = f
	mmGetNamespaceModelByID.mock.funcGetNamespaceModelByIDOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelByID.mock
}

// When sets expectation for the Repository.GetNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) *RepositoryMockGetNamespaceModelByIDExpectation {
	if mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.mock.t.Fatalf("RepositoryMock.GetNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetNamespaceModelByIDExpectation{
		mock:               mmGetNamespaceModelByID.mock,
		params:             &RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar},
		expectationOrigins: RepositoryMockGetNamespaceModelByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetNamespaceModelByID.expectations = append(mmGetNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetNamespaceModelByIDExpectation) Then(mp1 *datamodel.Model, err error) *RepositoryMock {
	e.results = &RepositoryMockGetNamespaceModelByIDResults{mp1, err}
	return e.mock
}

// Times sets number of times Repository.GetNamespaceModelByID should be invoked
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Times(n uint64) *mRepositoryMockGetNamespaceModelByID {
	if n == 0 {
		mmGetNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.GetNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetNamespaceModelByID.expectedInvocations, n)
	mmGetNamespaceModelByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetNamespaceModelByID
}

func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) invocationsDone() bool {
	if len(mmGetNamespaceModelByID.expectations) == 0 && mmGetNamespaceModelByID.defaultExpectation == nil && mmGetNamespaceModelByID.mock.funcGetNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelByID.mock.afterGetNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetNamespaceModelByID implements mm_repository.Repository
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByID(ctx context.Context, ownerPermalink string, id string, isBasicView bool, includeAvatar bool) (mp1 *datamodel.Model, err error) {
	mm_atomic.AddUint64(&mmGetNamespaceModelByID.beforeGetNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetNamespaceModelByID.afterGetNamespaceModelByIDCounter, 1)

	mmGetNamespaceModelByID.t.Helper()

	if mmGetNamespaceModelByID.inspectFuncGetNamespaceModelByID != nil {
		mmGetNamespaceModelByID.inspectFuncGetNamespaceModelByID(ctx, ownerPermalink, id, isBasicView, includeAvatar)
	}

	mm_params := RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}

	// Record call args
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.mutex.Lock()
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.callArgs = append(mmGetNamespaceModelByID.GetNamespaceModelByIDMock.callArgs, &mm_params)
	mmGetNamespaceModelByID.GetNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmGetNamespaceModelByID.GetNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetNamespaceModelByIDParams{ctx, ownerPermalink, id, isBasicView, includeAvatar}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.includeAvatar != nil && !minimock.Equal(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar) {
				mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameter includeAvatar, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originIncludeAvatar, *mm_want_ptrs.includeAvatar, mm_got.includeAvatar, minimock.Diff(*mm_want_ptrs.includeAvatar, mm_got.includeAvatar))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetNamespaceModelByID.t.Errorf("RepositoryMock.GetNamespaceModelByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetNamespaceModelByID.GetNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.GetNamespaceModelByID")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmGetNamespaceModelByID.funcGetNamespaceModelByID != nil {
		return mmGetNamespaceModelByID.funcGetNamespaceModelByID(ctx, ownerPermalink, id, isBasicView, includeAvatar)
	}
	mmGetNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.GetNamespaceModelByID. %v %v %v %v %v", ctx, ownerPermalink, id, isBasicView, includeAvatar)
	return
}

// GetNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.GetNamespaceModelByID invocations
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelByID.afterGetNamespaceModelByIDCounter)
}

// GetNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.GetNamespaceModelByID invocations
func (mmGetNamespaceModelByID *RepositoryMock) GetNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetNamespaceModelByID.beforeGetNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetNamespaceModelByID *mRepositoryMockGetNamespaceModelByID) Calls() []*RepositoryMockGetNamespaceModelByIDParams {
	mmGetNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetNamespaceModelByIDParams, len(mmGetNamespaceModelByID.callArgs))
	copy(argCopy, mmGetNamespaceModelByID.callArgs)

	mmGetNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetNamespaceModelByIDDone returns true if the count of the GetNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetNamespaceModelByIDDone() bool {
	if m.GetNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetNamespaceModelByIDMock.invocationsDone()
}

// MinimockGetNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetNamespaceModelByIDInspect() {
	for _, e := range m.GetNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterGetNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetNamespaceModelByIDMock.defaultExpectation != nil && afterGetNamespaceModelByIDCounter < 1 {
		if m.GetNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID at\n%s", m.GetNamespaceModelByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID at\n%s with params: %#v", m.GetNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetNamespaceModelByID != nil && afterGetNamespaceModelByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetNamespaceModelByID at\n%s", m.funcGetNamespaceModelByIDOrigin)
	}

	if !m.GetNamespaceModelByIDMock.invocationsDone() && afterGetNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetNamespaceModelByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetNamespaceModelByIDMock.expectedInvocations), m.GetNamespaceModelByIDMock.expectedInvocationsOrigin, afterGetNamespaceModelByIDCounter)
	}
}

type mRepositoryMockGetRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRepositoryTagExpectation
	expectations       []*RepositoryMockGetRepositoryTagExpectation

	callArgs []*RepositoryMockGetRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetRepositoryTagExpectation specifies expectation struct of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetRepositoryTagParams
	paramPtrs          *RepositoryMockGetRepositoryTagParamPtrs
	expectationOrigins RepositoryMockGetRepositoryTagExpectationOrigins
	results            *RepositoryMockGetRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetRepositoryTagParams contains parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParams struct {
	ctx  context.Context
	name utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagParamPtrs contains pointers to parameters of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagParamPtrs struct {
	ctx  *context.Context
	name *utils.RepositoryTagName
}

// RepositoryMockGetRepositoryTagResults contains results of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagResults struct {
	tp1 *datamodel.Tag
	err error
}

// RepositoryMockGetRepositoryTagOrigins contains origins of expectations of the Repository.GetRepositoryTag
type RepositoryMockGetRepositoryTagExpectationOrigins struct {
	origin     string
	originCtx  string
	originName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Optional() *mRepositoryMockGetRepositoryTag {
	mmGetRepositoryTag.optional = true
	return mmGetRepositoryTag
}

// Expect sets up expected params for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Expect(ctx context.Context, name utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by ExpectParams functions")
	}

	mmGetRepositoryTag.defaultExpectation.params = &RepositoryMockGetRepositoryTagParams{ctx, name}
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRepositoryTag.expectations {
		if minimock.Equal(e.params, mmGetRepositoryTag.defaultExpectation.params) {
			mmGetRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRepositoryTag.defaultExpectation.params)
		}
	}

	return mmGetRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// ExpectNameParam2 sets up expected param name for Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) ExpectNameParam2(name utils.RepositoryTagName) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{}
	}

	if mmGetRepositoryTag.defaultExpectation.params != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Expect")
	}

	if mmGetRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmGetRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockGetRepositoryTagParamPtrs{}
	}
	mmGetRepositoryTag.defaultExpectation.paramPtrs.name = &name
	mmGetRepositoryTag.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Inspect(f func(ctx context.Context, name utils.RepositoryTagName)) *mRepositoryMockGetRepositoryTag {
	if mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRepositoryTag")
	}

	mmGetRepositoryTag.mock.inspectFuncGetRepositoryTag = f

	return mmGetRepositoryTag
}

// Return sets up results that will be returned by Repository.GetRepositoryTag
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Return(tp1 *datamodel.Tag, err error) *RepositoryMock {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	if mmGetRepositoryTag.defaultExpectation == nil {
		mmGetRepositoryTag.defaultExpectation = &RepositoryMockGetRepositoryTagExpectation{mock: mmGetRepositoryTag.mock}
	}
	mmGetRepositoryTag.defaultExpectation.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	mmGetRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// Set uses given function f to mock the Repository.GetRepositoryTag method
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Set(f func(ctx context.Context, name utils.RepositoryTagName) (tp1 *datamodel.Tag, err error)) *RepositoryMock {
	if mmGetRepositoryTag.defaultExpectation != nil {
		mmGetRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.GetRepositoryTag method")
	}

	if len(mmGetRepositoryTag.expectations) > 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.GetRepositoryTag method")
	}

	mmGetRepositoryTag.mock.funcGetRepositoryTag = f
	mmGetRepositoryTag.mock.funcGetRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag.mock
}

// When sets expectation for the Repository.GetRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) When(ctx context.Context, name utils.RepositoryTagName) *RepositoryMockGetRepositoryTagExpectation {
	if mmGetRepositoryTag.mock.funcGetRepositoryTag != nil {
		mmGetRepositoryTag.mock.t.Fatalf("RepositoryMock.GetRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockGetRepositoryTagExpectation{
		mock:               mmGetRepositoryTag.mock,
		params:             &RepositoryMockGetRepositoryTagParams{ctx, name},
		expectationOrigins: RepositoryMockGetRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRepositoryTag.expectations = append(mmGetRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRepositoryTagExpectation) Then(tp1 *datamodel.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRepositoryTagResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.GetRepositoryTag should be invoked
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Times(n uint64) *mRepositoryMockGetRepositoryTag {
	if n == 0 {
		mmGetRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.GetRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRepositoryTag.expectedInvocations, n)
	mmGetRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRepositoryTag
}

func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) invocationsDone() bool {
	if len(mmGetRepositoryTag.expectations) == 0 && mmGetRepositoryTag.defaultExpectation == nil && mmGetRepositoryTag.mock.funcGetRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.mock.afterGetRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRepositoryTag implements mm_repository.Repository
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTag(ctx context.Context, name utils.RepositoryTagName) (tp1 *datamodel.Tag, err error) {
	mm_atomic.AddUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter, 1)

	mmGetRepositoryTag.t.Helper()

	if mmGetRepositoryTag.inspectFuncGetRepositoryTag != nil {
		mmGetRepositoryTag.inspectFuncGetRepositoryTag(ctx, name)
	}

	mm_params := RepositoryMockGetRepositoryTagParams{ctx, name}

	// Record call args
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Lock()
	mmGetRepositoryTag.GetRepositoryTagMock.callArgs = append(mmGetRepositoryTag.GetRepositoryTagMock.callArgs, &mm_params)
	mmGetRepositoryTag.GetRepositoryTagMock.mutex.Unlock()

	for _, e := range mmGetRepositoryTag.GetRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRepositoryTagParams{ctx, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRepositoryTag.t.Errorf("RepositoryMock.GetRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRepositoryTag.GetRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRepositoryTag.t.Fatal("No results are set for the RepositoryMock.GetRepositoryTag")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmGetRepositoryTag.funcGetRepositoryTag != nil {
		return mmGetRepositoryTag.funcGetRepositoryTag(ctx, name)
	}
	mmGetRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.GetRepositoryTag. %v %v", ctx, name)
	return
}

// GetRepositoryTagAfterCounter returns a count of finished RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.afterGetRepositoryTagCounter)
}

// GetRepositoryTagBeforeCounter returns a count of RepositoryMock.GetRepositoryTag invocations
func (mmGetRepositoryTag *RepositoryMock) GetRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRepositoryTag.beforeGetRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRepositoryTag *mRepositoryMockGetRepositoryTag) Calls() []*RepositoryMockGetRepositoryTagParams {
	mmGetRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRepositoryTagParams, len(mmGetRepositoryTag.callArgs))
	copy(argCopy, mmGetRepositoryTag.callArgs)

	mmGetRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockGetRepositoryTagDone returns true if the count of the GetRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRepositoryTagDone() bool {
	if m.GetRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRepositoryTagMock.invocationsDone()
}

// MinimockGetRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRepositoryTagInspect() {
	for _, e := range m.GetRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterGetRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRepositoryTagMock.defaultExpectation != nil && afterGetRepositoryTagCounter < 1 {
		if m.GetRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.GetRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s with params: %#v", m.GetRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.GetRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRepositoryTag != nil && afterGetRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetRepositoryTag at\n%s", m.funcGetRepositoryTagOrigin)
	}

	if !m.GetRepositoryTagMock.invocationsDone() && afterGetRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRepositoryTagMock.expectedInvocations), m.GetRepositoryTagMock.expectedInvocationsOrigin, afterGetRepositoryTagCounter)
	}
}

type mRepositoryMockListModelDefinitions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelDefinitionsExpectation
	expectations       []*RepositoryMockListModelDefinitionsExpectation

	callArgs []*RepositoryMockListModelDefinitionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelDefinitionsExpectation specifies expectation struct of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelDefinitionsParams
	paramPtrs          *RepositoryMockListModelDefinitionsParamPtrs
	expectationOrigins RepositoryMockListModelDefinitionsExpectationOrigins
	results            *RepositoryMockListModelDefinitionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelDefinitionsParams contains parameters of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsParams struct {
	view      modelpb.View
	pageSize  int64
	pageToken string
}

// RepositoryMockListModelDefinitionsParamPtrs contains pointers to parameters of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsParamPtrs struct {
	view      *modelpb.View
	pageSize  *int64
	pageToken *string
}

// RepositoryMockListModelDefinitionsResults contains results of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsResults struct {
	definitions   []*datamodel.ModelDefinition
	nextPageToken string
	totalSize     int64
	err           error
}

// RepositoryMockListModelDefinitionsOrigins contains origins of expectations of the Repository.ListModelDefinitions
type RepositoryMockListModelDefinitionsExpectationOrigins struct {
	origin          string
	originView      string
	originPageSize  string
	originPageToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Optional() *mRepositoryMockListModelDefinitions {
	mmListModelDefinitions.optional = true
	return mmListModelDefinitions
}

// Expect sets up expected params for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Expect(view modelpb.View, pageSize int64, pageToken string) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by ExpectParams functions")
	}

	mmListModelDefinitions.defaultExpectation.params = &RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}
	mmListModelDefinitions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelDefinitions.expectations {
		if minimock.Equal(e.params, mmListModelDefinitions.defaultExpectation.params) {
			mmListModelDefinitions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelDefinitions.defaultExpectation.params)
		}
	}

	return mmListModelDefinitions
}

// ExpectViewParam1 sets up expected param view for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectViewParam1(view modelpb.View) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.view = &view
	mmListModelDefinitions.defaultExpectation.expectationOrigins.originView = minimock.CallerInfo(1)

	return mmListModelDefinitions
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListModelDefinitions.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListModelDefinitions
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{}
	}

	if mmListModelDefinitions.defaultExpectation.params != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Expect")
	}

	if mmListModelDefinitions.defaultExpectation.paramPtrs == nil {
		mmListModelDefinitions.defaultExpectation.paramPtrs = &RepositoryMockListModelDefinitionsParamPtrs{}
	}
	mmListModelDefinitions.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListModelDefinitions.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListModelDefinitions
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Inspect(f func(view modelpb.View, pageSize int64, pageToken string)) *mRepositoryMockListModelDefinitions {
	if mmListModelDefinitions.mock.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelDefinitions")
	}

	mmListModelDefinitions.mock.inspectFuncListModelDefinitions = f

	return mmListModelDefinitions
}

// Return sets up results that will be returned by Repository.ListModelDefinitions
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Return(definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) *RepositoryMock {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	if mmListModelDefinitions.defaultExpectation == nil {
		mmListModelDefinitions.defaultExpectation = &RepositoryMockListModelDefinitionsExpectation{mock: mmListModelDefinitions.mock}
	}
	mmListModelDefinitions.defaultExpectation.results = &RepositoryMockListModelDefinitionsResults{definitions, nextPageToken, totalSize, err}
	mmListModelDefinitions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions.mock
}

// Set uses given function f to mock the Repository.ListModelDefinitions method
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Set(f func(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error)) *RepositoryMock {
	if mmListModelDefinitions.defaultExpectation != nil {
		mmListModelDefinitions.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelDefinitions method")
	}

	if len(mmListModelDefinitions.expectations) > 0 {
		mmListModelDefinitions.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelDefinitions method")
	}

	mmListModelDefinitions.mock.funcListModelDefinitions = f
	mmListModelDefinitions.mock.funcListModelDefinitionsOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions.mock
}

// When sets expectation for the Repository.ListModelDefinitions which will trigger the result defined by the following
// Then helper
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) When(view modelpb.View, pageSize int64, pageToken string) *RepositoryMockListModelDefinitionsExpectation {
	if mmListModelDefinitions.mock.funcListModelDefinitions != nil {
		mmListModelDefinitions.mock.t.Fatalf("RepositoryMock.ListModelDefinitions mock is already set by Set")
	}

	expectation := &RepositoryMockListModelDefinitionsExpectation{
		mock:               mmListModelDefinitions.mock,
		params:             &RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken},
		expectationOrigins: RepositoryMockListModelDefinitionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelDefinitions.expectations = append(mmListModelDefinitions.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelDefinitions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelDefinitionsExpectation) Then(definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelDefinitionsResults{definitions, nextPageToken, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListModelDefinitions should be invoked
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Times(n uint64) *mRepositoryMockListModelDefinitions {
	if n == 0 {
		mmListModelDefinitions.mock.t.Fatalf("Times of RepositoryMock.ListModelDefinitions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelDefinitions.expectedInvocations, n)
	mmListModelDefinitions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelDefinitions
}

func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) invocationsDone() bool {
	if len(mmListModelDefinitions.expectations) == 0 && mmListModelDefinitions.defaultExpectation == nil && mmListModelDefinitions.mock.funcListModelDefinitions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.mock.afterListModelDefinitionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelDefinitions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelDefinitions implements mm_repository.Repository
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitions(view modelpb.View, pageSize int64, pageToken string) (definitions []*datamodel.ModelDefinition, nextPageToken string, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter, 1)

	mmListModelDefinitions.t.Helper()

	if mmListModelDefinitions.inspectFuncListModelDefinitions != nil {
		mmListModelDefinitions.inspectFuncListModelDefinitions(view, pageSize, pageToken)
	}

	mm_params := RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}

	// Record call args
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Lock()
	mmListModelDefinitions.ListModelDefinitionsMock.callArgs = append(mmListModelDefinitions.ListModelDefinitionsMock.callArgs, &mm_params)
	mmListModelDefinitions.ListModelDefinitionsMock.mutex.Unlock()

	for _, e := range mmListModelDefinitions.ListModelDefinitionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.definitions, e.results.nextPageToken, e.results.totalSize, e.results.err
		}
	}

	if mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelDefinitionsParams{view, pageSize, pageToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.view != nil && !minimock.Equal(*mm_want_ptrs.view, mm_got.view) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter view, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.originView, *mm_want_ptrs.view, mm_got.view, minimock.Diff(*mm_want_ptrs.view, mm_got.view))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelDefinitions.t.Errorf("RepositoryMock.ListModelDefinitions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelDefinitions.ListModelDefinitionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelDefinitions.t.Fatal("No results are set for the RepositoryMock.ListModelDefinitions")
		}
		return (*mm_results).definitions, (*mm_results).nextPageToken, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListModelDefinitions.funcListModelDefinitions != nil {
		return mmListModelDefinitions.funcListModelDefinitions(view, pageSize, pageToken)
	}
	mmListModelDefinitions.t.Fatalf("Unexpected call to RepositoryMock.ListModelDefinitions. %v %v %v", view, pageSize, pageToken)
	return
}

// ListModelDefinitionsAfterCounter returns a count of finished RepositoryMock.ListModelDefinitions invocations
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.afterListModelDefinitionsCounter)
}

// ListModelDefinitionsBeforeCounter returns a count of RepositoryMock.ListModelDefinitions invocations
func (mmListModelDefinitions *RepositoryMock) ListModelDefinitionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelDefinitions.beforeListModelDefinitionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelDefinitions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelDefinitions *mRepositoryMockListModelDefinitions) Calls() []*RepositoryMockListModelDefinitionsParams {
	mmListModelDefinitions.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelDefinitionsParams, len(mmListModelDefinitions.callArgs))
	copy(argCopy, mmListModelDefinitions.callArgs)

	mmListModelDefinitions.mutex.RUnlock()

	return argCopy
}

// MinimockListModelDefinitionsDone returns true if the count of the ListModelDefinitions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelDefinitionsDone() bool {
	if m.ListModelDefinitionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelDefinitionsMock.invocationsDone()
}

// MinimockListModelDefinitionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelDefinitionsInspect() {
	for _, e := range m.ListModelDefinitionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelDefinitionsCounter := mm_atomic.LoadUint64(&m.afterListModelDefinitionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelDefinitionsMock.defaultExpectation != nil && afterListModelDefinitionsCounter < 1 {
		if m.ListModelDefinitionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions at\n%s", m.ListModelDefinitionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions at\n%s with params: %#v", m.ListModelDefinitionsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelDefinitionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelDefinitions != nil && afterListModelDefinitionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelDefinitions at\n%s", m.funcListModelDefinitionsOrigin)
	}

	if !m.ListModelDefinitionsMock.invocationsDone() && afterListModelDefinitionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelDefinitions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelDefinitionsMock.expectedInvocations), m.ListModelDefinitionsMock.expectedInvocationsOrigin, afterListModelDefinitionsCounter)
	}
}

type mRepositoryMockListModelRuns struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelRunsExpectation
	expectations       []*RepositoryMockListModelRunsExpectation

	callArgs []*RepositoryMockListModelRunsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelRunsExpectation specifies expectation struct of the Repository.ListModelRuns
type RepositoryMockListModelRunsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelRunsParams
	paramPtrs          *RepositoryMockListModelRunsParamPtrs
	expectationOrigins RepositoryMockListModelRunsExpectationOrigins
	results            *RepositoryMockListModelRunsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelRunsParams contains parameters of the Repository.ListModelRuns
type RepositoryMockListModelRunsParams struct {
	ctx          context.Context
	pageSize     int64
	page         int64
	filter       filtering.Filter
	order        ordering.OrderBy
	requesterUID string
	isOwner      bool
	modelUID     string
}

// RepositoryMockListModelRunsParamPtrs contains pointers to parameters of the Repository.ListModelRuns
type RepositoryMockListModelRunsParamPtrs struct {
	ctx          *context.Context
	pageSize     *int64
	page         *int64
	filter       *filtering.Filter
	order        *ordering.OrderBy
	requesterUID *string
	isOwner      *bool
	modelUID     *string
}

// RepositoryMockListModelRunsResults contains results of the Repository.ListModelRuns
type RepositoryMockListModelRunsResults struct {
	modelRuns []*datamodel.ModelRun
	totalSize int64
	err       error
}

// RepositoryMockListModelRunsOrigins contains origins of expectations of the Repository.ListModelRuns
type RepositoryMockListModelRunsExpectationOrigins struct {
	origin             string
	originCtx          string
	originPageSize     string
	originPage         string
	originFilter       string
	originOrder        string
	originRequesterUID string
	originIsOwner      string
	originModelUID     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelRuns *mRepositoryMockListModelRuns) Optional() *mRepositoryMockListModelRuns {
	mmListModelRuns.optional = true
	return mmListModelRuns
}

// Expect sets up expected params for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Expect(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.paramPtrs != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by ExpectParams functions")
	}

	mmListModelRuns.defaultExpectation.params = &RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}
	mmListModelRuns.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelRuns.expectations {
		if minimock.Equal(e.params, mmListModelRuns.defaultExpectation.params) {
			mmListModelRuns.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelRuns.defaultExpectation.params)
		}
	}

	return mmListModelRuns
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelRuns.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListModelRuns.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectPageParam3 sets up expected param page for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectPageParam3(page int64) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.page = &page
	mmListModelRuns.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectFilterParam4 sets up expected param filter for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectFilterParam4(filter filtering.Filter) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.filter = &filter
	mmListModelRuns.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectOrderParam5 sets up expected param order for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectOrderParam5(order ordering.OrderBy) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.order = &order
	mmListModelRuns.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectRequesterUIDParam6 sets up expected param requesterUID for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectRequesterUIDParam6(requesterUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.requesterUID = &requesterUID
	mmListModelRuns.defaultExpectation.expectationOrigins.originRequesterUID = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectIsOwnerParam7 sets up expected param isOwner for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectIsOwnerParam7(isOwner bool) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.isOwner = &isOwner
	mmListModelRuns.defaultExpectation.expectationOrigins.originIsOwner = minimock.CallerInfo(1)

	return mmListModelRuns
}

// ExpectModelUIDParam8 sets up expected param modelUID for Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) ExpectModelUIDParam8(modelUID string) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{}
	}

	if mmListModelRuns.defaultExpectation.params != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Expect")
	}

	if mmListModelRuns.defaultExpectation.paramPtrs == nil {
		mmListModelRuns.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsParamPtrs{}
	}
	mmListModelRuns.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmListModelRuns.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmListModelRuns
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Inspect(f func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string)) *mRepositoryMockListModelRuns {
	if mmListModelRuns.mock.inspectFuncListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelRuns")
	}

	mmListModelRuns.mock.inspectFuncListModelRuns = f

	return mmListModelRuns
}

// Return sets up results that will be returned by Repository.ListModelRuns
func (mmListModelRuns *mRepositoryMockListModelRuns) Return(modelRuns []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	if mmListModelRuns.defaultExpectation == nil {
		mmListModelRuns.defaultExpectation = &RepositoryMockListModelRunsExpectation{mock: mmListModelRuns.mock}
	}
	mmListModelRuns.defaultExpectation.results = &RepositoryMockListModelRunsResults{modelRuns, totalSize, err}
	mmListModelRuns.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelRuns.mock
}

// Set uses given function f to mock the Repository.ListModelRuns method
func (mmListModelRuns *mRepositoryMockListModelRuns) Set(f func(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelRuns []*datamodel.ModelRun, totalSize int64, err error)) *RepositoryMock {
	if mmListModelRuns.defaultExpectation != nil {
		mmListModelRuns.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelRuns method")
	}

	if len(mmListModelRuns.expectations) > 0 {
		mmListModelRuns.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelRuns method")
	}

	mmListModelRuns.mock.funcListModelRuns = f
	mmListModelRuns.mock.funcListModelRunsOrigin = minimock.CallerInfo(1)
	return mmListModelRuns.mock
}

// When sets expectation for the Repository.ListModelRuns which will trigger the result defined by the following
// Then helper
func (mmListModelRuns *mRepositoryMockListModelRuns) When(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) *RepositoryMockListModelRunsExpectation {
	if mmListModelRuns.mock.funcListModelRuns != nil {
		mmListModelRuns.mock.t.Fatalf("RepositoryMock.ListModelRuns mock is already set by Set")
	}

	expectation := &RepositoryMockListModelRunsExpectation{
		mock:               mmListModelRuns.mock,
		params:             &RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID},
		expectationOrigins: RepositoryMockListModelRunsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelRuns.expectations = append(mmListModelRuns.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelRuns return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelRunsExpectation) Then(modelRuns []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelRunsResults{modelRuns, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListModelRuns should be invoked
func (mmListModelRuns *mRepositoryMockListModelRuns) Times(n uint64) *mRepositoryMockListModelRuns {
	if n == 0 {
		mmListModelRuns.mock.t.Fatalf("Times of RepositoryMock.ListModelRuns mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelRuns.expectedInvocations, n)
	mmListModelRuns.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelRuns
}

func (mmListModelRuns *mRepositoryMockListModelRuns) invocationsDone() bool {
	if len(mmListModelRuns.expectations) == 0 && mmListModelRuns.defaultExpectation == nil && mmListModelRuns.mock.funcListModelRuns == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelRuns.mock.afterListModelRunsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelRuns.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelRuns implements mm_repository.Repository
func (mmListModelRuns *RepositoryMock) ListModelRuns(ctx context.Context, pageSize int64, page int64, filter filtering.Filter, order ordering.OrderBy, requesterUID string, isOwner bool, modelUID string) (modelRuns []*datamodel.ModelRun, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListModelRuns.beforeListModelRunsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelRuns.afterListModelRunsCounter, 1)

	mmListModelRuns.t.Helper()

	if mmListModelRuns.inspectFuncListModelRuns != nil {
		mmListModelRuns.inspectFuncListModelRuns(ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	}

	mm_params := RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}

	// Record call args
	mmListModelRuns.ListModelRunsMock.mutex.Lock()
	mmListModelRuns.ListModelRunsMock.callArgs = append(mmListModelRuns.ListModelRunsMock.callArgs, &mm_params)
	mmListModelRuns.ListModelRunsMock.mutex.Unlock()

	for _, e := range mmListModelRuns.ListModelRunsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelRuns, e.results.totalSize, e.results.err
		}
	}

	if mmListModelRuns.ListModelRunsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelRuns.ListModelRunsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelRuns.ListModelRunsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelRuns.ListModelRunsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelRunsParams{ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.requesterUID != nil && !minimock.Equal(*mm_want_ptrs.requesterUID, mm_got.requesterUID) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter requesterUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originRequesterUID, *mm_want_ptrs.requesterUID, mm_got.requesterUID, minimock.Diff(*mm_want_ptrs.requesterUID, mm_got.requesterUID))
			}

			if mm_want_ptrs.isOwner != nil && !minimock.Equal(*mm_want_ptrs.isOwner, mm_got.isOwner) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter isOwner, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originIsOwner, *mm_want_ptrs.isOwner, mm_got.isOwner, minimock.Diff(*mm_want_ptrs.isOwner, mm_got.isOwner))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelRuns.t.Errorf("RepositoryMock.ListModelRuns got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelRuns.ListModelRunsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelRuns.ListModelRunsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelRuns.t.Fatal("No results are set for the RepositoryMock.ListModelRuns")
		}
		return (*mm_results).modelRuns, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListModelRuns.funcListModelRuns != nil {
		return mmListModelRuns.funcListModelRuns(ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	}
	mmListModelRuns.t.Fatalf("Unexpected call to RepositoryMock.ListModelRuns. %v %v %v %v %v %v %v %v", ctx, pageSize, page, filter, order, requesterUID, isOwner, modelUID)
	return
}

// ListModelRunsAfterCounter returns a count of finished RepositoryMock.ListModelRuns invocations
func (mmListModelRuns *RepositoryMock) ListModelRunsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.afterListModelRunsCounter)
}

// ListModelRunsBeforeCounter returns a count of RepositoryMock.ListModelRuns invocations
func (mmListModelRuns *RepositoryMock) ListModelRunsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRuns.beforeListModelRunsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelRuns.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelRuns *mRepositoryMockListModelRuns) Calls() []*RepositoryMockListModelRunsParams {
	mmListModelRuns.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelRunsParams, len(mmListModelRuns.callArgs))
	copy(argCopy, mmListModelRuns.callArgs)

	mmListModelRuns.mutex.RUnlock()

	return argCopy
}

// MinimockListModelRunsDone returns true if the count of the ListModelRuns invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelRunsDone() bool {
	if m.ListModelRunsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelRunsMock.invocationsDone()
}

// MinimockListModelRunsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelRunsInspect() {
	for _, e := range m.ListModelRunsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRuns at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelRunsCounter := mm_atomic.LoadUint64(&m.afterListModelRunsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelRunsMock.defaultExpectation != nil && afterListModelRunsCounter < 1 {
		if m.ListModelRunsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRuns at\n%s", m.ListModelRunsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRuns at\n%s with params: %#v", m.ListModelRunsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelRunsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelRuns != nil && afterListModelRunsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelRuns at\n%s", m.funcListModelRunsOrigin)
	}

	if !m.ListModelRunsMock.invocationsDone() && afterListModelRunsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelRuns at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelRunsMock.expectedInvocations), m.ListModelRunsMock.expectedInvocationsOrigin, afterListModelRunsCounter)
	}
}

type mRepositoryMockListModelRunsByRequester struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelRunsByRequesterExpectation
	expectations       []*RepositoryMockListModelRunsByRequesterExpectation

	callArgs []*RepositoryMockListModelRunsByRequesterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelRunsByRequesterExpectation specifies expectation struct of the Repository.ListModelRunsByRequester
type RepositoryMockListModelRunsByRequesterExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelRunsByRequesterParams
	paramPtrs          *RepositoryMockListModelRunsByRequesterParamPtrs
	expectationOrigins RepositoryMockListModelRunsByRequesterExpectationOrigins
	results            *RepositoryMockListModelRunsByRequesterResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelRunsByRequesterParams contains parameters of the Repository.ListModelRunsByRequester
type RepositoryMockListModelRunsByRequesterParams struct {
	ctx    context.Context
	params *mm_repository.ListModelRunsByRequesterParams
}

// RepositoryMockListModelRunsByRequesterParamPtrs contains pointers to parameters of the Repository.ListModelRunsByRequester
type RepositoryMockListModelRunsByRequesterParamPtrs struct {
	ctx    *context.Context
	params **mm_repository.ListModelRunsByRequesterParams
}

// RepositoryMockListModelRunsByRequesterResults contains results of the Repository.ListModelRunsByRequester
type RepositoryMockListModelRunsByRequesterResults struct {
	modelTriggers []*datamodel.ModelRun
	totalSize     int64
	err           error
}

// RepositoryMockListModelRunsByRequesterOrigins contains origins of expectations of the Repository.ListModelRunsByRequester
type RepositoryMockListModelRunsByRequesterExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Optional() *mRepositoryMockListModelRunsByRequester {
	mmListModelRunsByRequester.optional = true
	return mmListModelRunsByRequester
}

// Expect sets up expected params for Repository.ListModelRunsByRequester
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Expect(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams) *mRepositoryMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &RepositoryMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by ExpectParams functions")
	}

	mmListModelRunsByRequester.defaultExpectation.params = &RepositoryMockListModelRunsByRequesterParams{ctx, params}
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelRunsByRequester.expectations {
		if minimock.Equal(e.params, mmListModelRunsByRequester.defaultExpectation.params) {
			mmListModelRunsByRequester.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelRunsByRequester.defaultExpectation.params)
		}
	}

	return mmListModelRunsByRequester
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelRunsByRequester
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &RepositoryMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.params != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Expect")
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmListModelRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsByRequesterParamPtrs{}
	}
	mmListModelRunsByRequester.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelRunsByRequester
}

// ExpectParamsParam2 sets up expected param params for Repository.ListModelRunsByRequester
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) ExpectParamsParam2(params *mm_repository.ListModelRunsByRequesterParams) *mRepositoryMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &RepositoryMockListModelRunsByRequesterExpectation{}
	}

	if mmListModelRunsByRequester.defaultExpectation.params != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Expect")
	}

	if mmListModelRunsByRequester.defaultExpectation.paramPtrs == nil {
		mmListModelRunsByRequester.defaultExpectation.paramPtrs = &RepositoryMockListModelRunsByRequesterParamPtrs{}
	}
	mmListModelRunsByRequester.defaultExpectation.paramPtrs.params = &params
	mmListModelRunsByRequester.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmListModelRunsByRequester
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelRunsByRequester
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Inspect(f func(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams)) *mRepositoryMockListModelRunsByRequester {
	if mmListModelRunsByRequester.mock.inspectFuncListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelRunsByRequester")
	}

	mmListModelRunsByRequester.mock.inspectFuncListModelRunsByRequester = f

	return mmListModelRunsByRequester
}

// Return sets up results that will be returned by Repository.ListModelRunsByRequester
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Return(modelTriggers []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Set")
	}

	if mmListModelRunsByRequester.defaultExpectation == nil {
		mmListModelRunsByRequester.defaultExpectation = &RepositoryMockListModelRunsByRequesterExpectation{mock: mmListModelRunsByRequester.mock}
	}
	mmListModelRunsByRequester.defaultExpectation.results = &RepositoryMockListModelRunsByRequesterResults{modelTriggers, totalSize, err}
	mmListModelRunsByRequester.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester.mock
}

// Set uses given function f to mock the Repository.ListModelRunsByRequester method
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Set(f func(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error)) *RepositoryMock {
	if mmListModelRunsByRequester.defaultExpectation != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelRunsByRequester method")
	}

	if len(mmListModelRunsByRequester.expectations) > 0 {
		mmListModelRunsByRequester.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelRunsByRequester method")
	}

	mmListModelRunsByRequester.mock.funcListModelRunsByRequester = f
	mmListModelRunsByRequester.mock.funcListModelRunsByRequesterOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester.mock
}

// When sets expectation for the Repository.ListModelRunsByRequester which will trigger the result defined by the following
// Then helper
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) When(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams) *RepositoryMockListModelRunsByRequesterExpectation {
	if mmListModelRunsByRequester.mock.funcListModelRunsByRequester != nil {
		mmListModelRunsByRequester.mock.t.Fatalf("RepositoryMock.ListModelRunsByRequester mock is already set by Set")
	}

	expectation := &RepositoryMockListModelRunsByRequesterExpectation{
		mock:               mmListModelRunsByRequester.mock,
		params:             &RepositoryMockListModelRunsByRequesterParams{ctx, params},
		expectationOrigins: RepositoryMockListModelRunsByRequesterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelRunsByRequester.expectations = append(mmListModelRunsByRequester.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelRunsByRequester return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelRunsByRequesterExpectation) Then(modelTriggers []*datamodel.ModelRun, totalSize int64, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelRunsByRequesterResults{modelTriggers, totalSize, err}
	return e.mock
}

// Times sets number of times Repository.ListModelRunsByRequester should be invoked
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Times(n uint64) *mRepositoryMockListModelRunsByRequester {
	if n == 0 {
		mmListModelRunsByRequester.mock.t.Fatalf("Times of RepositoryMock.ListModelRunsByRequester mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelRunsByRequester.expectedInvocations, n)
	mmListModelRunsByRequester.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelRunsByRequester
}

func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) invocationsDone() bool {
	if len(mmListModelRunsByRequester.expectations) == 0 && mmListModelRunsByRequester.defaultExpectation == nil && mmListModelRunsByRequester.mock.funcListModelRunsByRequester == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelRunsByRequester.mock.afterListModelRunsByRequesterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelRunsByRequester.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelRunsByRequester implements mm_repository.Repository
func (mmListModelRunsByRequester *RepositoryMock) ListModelRunsByRequester(ctx context.Context, params *mm_repository.ListModelRunsByRequesterParams) (modelTriggers []*datamodel.ModelRun, totalSize int64, err error) {
	mm_atomic.AddUint64(&mmListModelRunsByRequester.beforeListModelRunsByRequesterCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelRunsByRequester.afterListModelRunsByRequesterCounter, 1)

	mmListModelRunsByRequester.t.Helper()

	if mmListModelRunsByRequester.inspectFuncListModelRunsByRequester != nil {
		mmListModelRunsByRequester.inspectFuncListModelRunsByRequester(ctx, params)
	}

	mm_params := RepositoryMockListModelRunsByRequesterParams{ctx, params}

	// Record call args
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.mutex.Lock()
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.callArgs = append(mmListModelRunsByRequester.ListModelRunsByRequesterMock.callArgs, &mm_params)
	mmListModelRunsByRequester.ListModelRunsByRequesterMock.mutex.Unlock()

	for _, e := range mmListModelRunsByRequester.ListModelRunsByRequesterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.modelTriggers, e.results.totalSize, e.results.err
		}
	}

	if mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.params
		mm_want_ptrs := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelRunsByRequesterParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelRunsByRequester.t.Errorf("RepositoryMock.ListModelRunsByRequester got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmListModelRunsByRequester.t.Errorf("RepositoryMock.ListModelRunsByRequester got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelRunsByRequester.t.Errorf("RepositoryMock.ListModelRunsByRequester got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelRunsByRequester.ListModelRunsByRequesterMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelRunsByRequester.t.Fatal("No results are set for the RepositoryMock.ListModelRunsByRequester")
		}
		return (*mm_results).modelTriggers, (*mm_results).totalSize, (*mm_results).err
	}
	if mmListModelRunsByRequester.funcListModelRunsByRequester != nil {
		return mmListModelRunsByRequester.funcListModelRunsByRequester(ctx, params)
	}
	mmListModelRunsByRequester.t.Fatalf("Unexpected call to RepositoryMock.ListModelRunsByRequester. %v %v", ctx, params)
	return
}

// ListModelRunsByRequesterAfterCounter returns a count of finished RepositoryMock.ListModelRunsByRequester invocations
func (mmListModelRunsByRequester *RepositoryMock) ListModelRunsByRequesterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRunsByRequester.afterListModelRunsByRequesterCounter)
}

// ListModelRunsByRequesterBeforeCounter returns a count of RepositoryMock.ListModelRunsByRequester invocations
func (mmListModelRunsByRequester *RepositoryMock) ListModelRunsByRequesterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelRunsByRequester.beforeListModelRunsByRequesterCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelRunsByRequester.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelRunsByRequester *mRepositoryMockListModelRunsByRequester) Calls() []*RepositoryMockListModelRunsByRequesterParams {
	mmListModelRunsByRequester.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelRunsByRequesterParams, len(mmListModelRunsByRequester.callArgs))
	copy(argCopy, mmListModelRunsByRequester.callArgs)

	mmListModelRunsByRequester.mutex.RUnlock()

	return argCopy
}

// MinimockListModelRunsByRequesterDone returns true if the count of the ListModelRunsByRequester invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelRunsByRequesterDone() bool {
	if m.ListModelRunsByRequesterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelRunsByRequesterMock.invocationsDone()
}

// MinimockListModelRunsByRequesterInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelRunsByRequesterInspect() {
	for _, e := range m.ListModelRunsByRequesterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRunsByRequester at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelRunsByRequesterCounter := mm_atomic.LoadUint64(&m.afterListModelRunsByRequesterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelRunsByRequesterMock.defaultExpectation != nil && afterListModelRunsByRequesterCounter < 1 {
		if m.ListModelRunsByRequesterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRunsByRequester at\n%s", m.ListModelRunsByRequesterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelRunsByRequester at\n%s with params: %#v", m.ListModelRunsByRequesterMock.defaultExpectation.expectationOrigins.origin, *m.ListModelRunsByRequesterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelRunsByRequester != nil && afterListModelRunsByRequesterCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelRunsByRequester at\n%s", m.funcListModelRunsByRequesterOrigin)
	}

	if !m.ListModelRunsByRequesterMock.invocationsDone() && afterListModelRunsByRequesterCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelRunsByRequester at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelRunsByRequesterMock.expectedInvocations), m.ListModelRunsByRequesterMock.expectedInvocationsOrigin, afterListModelRunsByRequesterCounter)
	}
}

type mRepositoryMockListModelTags struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelTagsExpectation
	expectations       []*RepositoryMockListModelTagsExpectation

	callArgs []*RepositoryMockListModelTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelTagsExpectation specifies expectation struct of the Repository.ListModelTags
type RepositoryMockListModelTagsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelTagsParams
	paramPtrs          *RepositoryMockListModelTagsParamPtrs
	expectationOrigins RepositoryMockListModelTagsExpectationOrigins
	results            *RepositoryMockListModelTagsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelTagsParams contains parameters of the Repository.ListModelTags
type RepositoryMockListModelTagsParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// RepositoryMockListModelTagsParamPtrs contains pointers to parameters of the Repository.ListModelTags
type RepositoryMockListModelTagsParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// RepositoryMockListModelTagsResults contains results of the Repository.ListModelTags
type RepositoryMockListModelTagsResults struct {
	ma1 []datamodel.ModelTag
	err error
}

// RepositoryMockListModelTagsOrigins contains origins of expectations of the Repository.ListModelTags
type RepositoryMockListModelTagsExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelTags *mRepositoryMockListModelTags) Optional() *mRepositoryMockListModelTags {
	mmListModelTags.optional = true
	return mmListModelTags
}

// Expect sets up expected params for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Expect(ctx context.Context, modelUID uuid.UUID) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.paramPtrs != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by ExpectParams functions")
	}

	mmListModelTags.defaultExpectation.params = &RepositoryMockListModelTagsParams{ctx, modelUID}
	mmListModelTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelTags.expectations {
		if minimock.Equal(e.params, mmListModelTags.defaultExpectation.params) {
			mmListModelTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelTags.defaultExpectation.params)
		}
	}

	return mmListModelTags
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.params != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Expect")
	}

	if mmListModelTags.defaultExpectation.paramPtrs == nil {
		mmListModelTags.defaultExpectation.paramPtrs = &RepositoryMockListModelTagsParamPtrs{}
	}
	mmListModelTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelTags
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{}
	}

	if mmListModelTags.defaultExpectation.params != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Expect")
	}

	if mmListModelTags.defaultExpectation.paramPtrs == nil {
		mmListModelTags.defaultExpectation.paramPtrs = &RepositoryMockListModelTagsParamPtrs{}
	}
	mmListModelTags.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmListModelTags.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmListModelTags
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mRepositoryMockListModelTags {
	if mmListModelTags.mock.inspectFuncListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelTags")
	}

	mmListModelTags.mock.inspectFuncListModelTags = f

	return mmListModelTags
}

// Return sets up results that will be returned by Repository.ListModelTags
func (mmListModelTags *mRepositoryMockListModelTags) Return(ma1 []datamodel.ModelTag, err error) *RepositoryMock {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	if mmListModelTags.defaultExpectation == nil {
		mmListModelTags.defaultExpectation = &RepositoryMockListModelTagsExpectation{mock: mmListModelTags.mock}
	}
	mmListModelTags.defaultExpectation.results = &RepositoryMockListModelTagsResults{ma1, err}
	mmListModelTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelTags.mock
}

// Set uses given function f to mock the Repository.ListModelTags method
func (mmListModelTags *mRepositoryMockListModelTags) Set(f func(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error)) *RepositoryMock {
	if mmListModelTags.defaultExpectation != nil {
		mmListModelTags.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelTags method")
	}

	if len(mmListModelTags.expectations) > 0 {
		mmListModelTags.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelTags method")
	}

	mmListModelTags.mock.funcListModelTags = f
	mmListModelTags.mock.funcListModelTagsOrigin = minimock.CallerInfo(1)
	return mmListModelTags.mock
}

// When sets expectation for the Repository.ListModelTags which will trigger the result defined by the following
// Then helper
func (mmListModelTags *mRepositoryMockListModelTags) When(ctx context.Context, modelUID uuid.UUID) *RepositoryMockListModelTagsExpectation {
	if mmListModelTags.mock.funcListModelTags != nil {
		mmListModelTags.mock.t.Fatalf("RepositoryMock.ListModelTags mock is already set by Set")
	}

	expectation := &RepositoryMockListModelTagsExpectation{
		mock:               mmListModelTags.mock,
		params:             &RepositoryMockListModelTagsParams{ctx, modelUID},
		expectationOrigins: RepositoryMockListModelTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelTags.expectations = append(mmListModelTags.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelTags return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelTagsExpectation) Then(ma1 []datamodel.ModelTag, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelTagsResults{ma1, err}
	return e.mock
}

// Times sets number of times Repository.ListModelTags should be invoked
func (mmListModelTags *mRepositoryMockListModelTags) Times(n uint64) *mRepositoryMockListModelTags {
	if n == 0 {
		mmListModelTags.mock.t.Fatalf("Times of RepositoryMock.ListModelTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelTags.expectedInvocations, n)
	mmListModelTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelTags
}

func (mmListModelTags *mRepositoryMockListModelTags) invocationsDone() bool {
	if len(mmListModelTags.expectations) == 0 && mmListModelTags.defaultExpectation == nil && mmListModelTags.mock.funcListModelTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelTags.mock.afterListModelTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelTags implements mm_repository.Repository
func (mmListModelTags *RepositoryMock) ListModelTags(ctx context.Context, modelUID uuid.UUID) (ma1 []datamodel.ModelTag, err error) {
	mm_atomic.AddUint64(&mmListModelTags.beforeListModelTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelTags.afterListModelTagsCounter, 1)

	mmListModelTags.t.Helper()

	if mmListModelTags.inspectFuncListModelTags != nil {
		mmListModelTags.inspectFuncListModelTags(ctx, modelUID)
	}

	mm_params := RepositoryMockListModelTagsParams{ctx, modelUID}

	// Record call args
	mmListModelTags.ListModelTagsMock.mutex.Lock()
	mmListModelTags.ListModelTagsMock.callArgs = append(mmListModelTags.ListModelTagsMock.callArgs, &mm_params)
	mmListModelTags.ListModelTagsMock.mutex.Unlock()

	for _, e := range mmListModelTags.ListModelTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmListModelTags.ListModelTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelTags.ListModelTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelTags.ListModelTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelTags.ListModelTagsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelTagsParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelTags.ListModelTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelTags.ListModelTagsMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelTags.t.Errorf("RepositoryMock.ListModelTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelTags.ListModelTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelTags.ListModelTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelTags.t.Fatal("No results are set for the RepositoryMock.ListModelTags")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmListModelTags.funcListModelTags != nil {
		return mmListModelTags.funcListModelTags(ctx, modelUID)
	}
	mmListModelTags.t.Fatalf("Unexpected call to RepositoryMock.ListModelTags. %v %v", ctx, modelUID)
	return
}

// ListModelTagsAfterCounter returns a count of finished RepositoryMock.ListModelTags invocations
func (mmListModelTags *RepositoryMock) ListModelTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelTags.afterListModelTagsCounter)
}

// ListModelTagsBeforeCounter returns a count of RepositoryMock.ListModelTags invocations
func (mmListModelTags *RepositoryMock) ListModelTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelTags.beforeListModelTagsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelTags *mRepositoryMockListModelTags) Calls() []*RepositoryMockListModelTagsParams {
	mmListModelTags.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelTagsParams, len(mmListModelTags.callArgs))
	copy(argCopy, mmListModelTags.callArgs)

	mmListModelTags.mutex.RUnlock()

	return argCopy
}

// MinimockListModelTagsDone returns true if the count of the ListModelTags invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelTagsDone() bool {
	if m.ListModelTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelTagsMock.invocationsDone()
}

// MinimockListModelTagsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelTagsInspect() {
	for _, e := range m.ListModelTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelTagsCounter := mm_atomic.LoadUint64(&m.afterListModelTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelTagsMock.defaultExpectation != nil && afterListModelTagsCounter < 1 {
		if m.ListModelTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelTags at\n%s", m.ListModelTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelTags at\n%s with params: %#v", m.ListModelTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelTags != nil && afterListModelTagsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelTags at\n%s", m.funcListModelTagsOrigin)
	}

	if !m.ListModelTagsMock.invocationsDone() && afterListModelTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelTagsMock.expectedInvocations), m.ListModelTagsMock.expectedInvocationsOrigin, afterListModelTagsCounter)
	}
}

type mRepositoryMockListModelVersions struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelVersionsExpectation
	expectations       []*RepositoryMockListModelVersionsExpectation

	callArgs []*RepositoryMockListModelVersionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelVersionsExpectation specifies expectation struct of the Repository.ListModelVersions
type RepositoryMockListModelVersionsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelVersionsParams
	paramPtrs          *RepositoryMockListModelVersionsParamPtrs
	expectationOrigins RepositoryMockListModelVersionsExpectationOrigins
	results            *RepositoryMockListModelVersionsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelVersionsParams contains parameters of the Repository.ListModelVersions
type RepositoryMockListModelVersionsParams struct {
	ctx         context.Context
	modelUID    uuid.UUID
	groupDigest bool
}

// RepositoryMockListModelVersionsParamPtrs contains pointers to parameters of the Repository.ListModelVersions
type RepositoryMockListModelVersionsParamPtrs struct {
	ctx         *context.Context
	modelUID    *uuid.UUID
	groupDigest *bool
}

// RepositoryMockListModelVersionsResults contains results of the Repository.ListModelVersions
type RepositoryMockListModelVersionsResults struct {
	versions []*datamodel.ModelVersion
	err      error
}

// RepositoryMockListModelVersionsOrigins contains origins of expectations of the Repository.ListModelVersions
type RepositoryMockListModelVersionsExpectationOrigins struct {
	origin            string
	originCtx         string
	originModelUID    string
	originGroupDigest string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelVersions *mRepositoryMockListModelVersions) Optional() *mRepositoryMockListModelVersions {
	mmListModelVersions.optional = true
	return mmListModelVersions
}

// Expect sets up expected params for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Expect(ctx context.Context, modelUID uuid.UUID, groupDigest bool) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.paramPtrs != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by ExpectParams functions")
	}

	mmListModelVersions.defaultExpectation.params = &RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}
	mmListModelVersions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelVersions.expectations {
		if minimock.Equal(e.params, mmListModelVersions.defaultExpectation.params) {
			mmListModelVersions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelVersions.defaultExpectation.params)
		}
	}

	return mmListModelVersions
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelVersions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelVersions
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmListModelVersions.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmListModelVersions
}

// ExpectGroupDigestParam3 sets up expected param groupDigest for Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) ExpectGroupDigestParam3(groupDigest bool) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{}
	}

	if mmListModelVersions.defaultExpectation.params != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Expect")
	}

	if mmListModelVersions.defaultExpectation.paramPtrs == nil {
		mmListModelVersions.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsParamPtrs{}
	}
	mmListModelVersions.defaultExpectation.paramPtrs.groupDigest = &groupDigest
	mmListModelVersions.defaultExpectation.expectationOrigins.originGroupDigest = minimock.CallerInfo(1)

	return mmListModelVersions
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Inspect(f func(ctx context.Context, modelUID uuid.UUID, groupDigest bool)) *mRepositoryMockListModelVersions {
	if mmListModelVersions.mock.inspectFuncListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelVersions")
	}

	mmListModelVersions.mock.inspectFuncListModelVersions = f

	return mmListModelVersions
}

// Return sets up results that will be returned by Repository.ListModelVersions
func (mmListModelVersions *mRepositoryMockListModelVersions) Return(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	if mmListModelVersions.defaultExpectation == nil {
		mmListModelVersions.defaultExpectation = &RepositoryMockListModelVersionsExpectation{mock: mmListModelVersions.mock}
	}
	mmListModelVersions.defaultExpectation.results = &RepositoryMockListModelVersionsResults{versions, err}
	mmListModelVersions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelVersions.mock
}

// Set uses given function f to mock the Repository.ListModelVersions method
func (mmListModelVersions *mRepositoryMockListModelVersions) Set(f func(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmListModelVersions.defaultExpectation != nil {
		mmListModelVersions.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelVersions method")
	}

	if len(mmListModelVersions.expectations) > 0 {
		mmListModelVersions.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelVersions method")
	}

	mmListModelVersions.mock.funcListModelVersions = f
	mmListModelVersions.mock.funcListModelVersionsOrigin = minimock.CallerInfo(1)
	return mmListModelVersions.mock
}

// When sets expectation for the Repository.ListModelVersions which will trigger the result defined by the following
// Then helper
func (mmListModelVersions *mRepositoryMockListModelVersions) When(ctx context.Context, modelUID uuid.UUID, groupDigest bool) *RepositoryMockListModelVersionsExpectation {
	if mmListModelVersions.mock.funcListModelVersions != nil {
		mmListModelVersions.mock.t.Fatalf("RepositoryMock.ListModelVersions mock is already set by Set")
	}

	expectation := &RepositoryMockListModelVersionsExpectation{
		mock:               mmListModelVersions.mock,
		params:             &RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest},
		expectationOrigins: RepositoryMockListModelVersionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelVersions.expectations = append(mmListModelVersions.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelVersions return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelVersionsExpectation) Then(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelVersionsResults{versions, err}
	return e.mock
}

// Times sets number of times Repository.ListModelVersions should be invoked
func (mmListModelVersions *mRepositoryMockListModelVersions) Times(n uint64) *mRepositoryMockListModelVersions {
	if n == 0 {
		mmListModelVersions.mock.t.Fatalf("Times of RepositoryMock.ListModelVersions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelVersions.expectedInvocations, n)
	mmListModelVersions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelVersions
}

func (mmListModelVersions *mRepositoryMockListModelVersions) invocationsDone() bool {
	if len(mmListModelVersions.expectations) == 0 && mmListModelVersions.defaultExpectation == nil && mmListModelVersions.mock.funcListModelVersions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelVersions.mock.afterListModelVersionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelVersions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelVersions implements mm_repository.Repository
func (mmListModelVersions *RepositoryMock) ListModelVersions(ctx context.Context, modelUID uuid.UUID, groupDigest bool) (versions []*datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmListModelVersions.beforeListModelVersionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelVersions.afterListModelVersionsCounter, 1)

	mmListModelVersions.t.Helper()

	if mmListModelVersions.inspectFuncListModelVersions != nil {
		mmListModelVersions.inspectFuncListModelVersions(ctx, modelUID, groupDigest)
	}

	mm_params := RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}

	// Record call args
	mmListModelVersions.ListModelVersionsMock.mutex.Lock()
	mmListModelVersions.ListModelVersionsMock.callArgs = append(mmListModelVersions.ListModelVersionsMock.callArgs, &mm_params)
	mmListModelVersions.ListModelVersionsMock.mutex.Unlock()

	for _, e := range mmListModelVersions.ListModelVersionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.versions, e.results.err
		}
	}

	if mmListModelVersions.ListModelVersionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelVersions.ListModelVersionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelVersions.ListModelVersionsMock.defaultExpectation.params
		mm_want_ptrs := mmListModelVersions.ListModelVersionsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelVersionsParams{ctx, modelUID, groupDigest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersions.ListModelVersionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersions.ListModelVersionsMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.groupDigest != nil && !minimock.Equal(*mm_want_ptrs.groupDigest, mm_got.groupDigest) {
				mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameter groupDigest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersions.ListModelVersionsMock.defaultExpectation.expectationOrigins.originGroupDigest, *mm_want_ptrs.groupDigest, mm_got.groupDigest, minimock.Diff(*mm_want_ptrs.groupDigest, mm_got.groupDigest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelVersions.t.Errorf("RepositoryMock.ListModelVersions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelVersions.ListModelVersionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelVersions.ListModelVersionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelVersions.t.Fatal("No results are set for the RepositoryMock.ListModelVersions")
		}
		return (*mm_results).versions, (*mm_results).err
	}
	if mmListModelVersions.funcListModelVersions != nil {
		return mmListModelVersions.funcListModelVersions(ctx, modelUID, groupDigest)
	}
	mmListModelVersions.t.Fatalf("Unexpected call to RepositoryMock.ListModelVersions. %v %v %v", ctx, modelUID, groupDigest)
	return
}

// ListModelVersionsAfterCounter returns a count of finished RepositoryMock.ListModelVersions invocations
func (mmListModelVersions *RepositoryMock) ListModelVersionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersions.afterListModelVersionsCounter)
}

// ListModelVersionsBeforeCounter returns a count of RepositoryMock.ListModelVersions invocations
func (mmListModelVersions *RepositoryMock) ListModelVersionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersions.beforeListModelVersionsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelVersions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelVersions *mRepositoryMockListModelVersions) Calls() []*RepositoryMockListModelVersionsParams {
	mmListModelVersions.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelVersionsParams, len(mmListModelVersions.callArgs))
	copy(argCopy, mmListModelVersions.callArgs)

	mmListModelVersions.mutex.RUnlock()

	return argCopy
}

// MinimockListModelVersionsDone returns true if the count of the ListModelVersions invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelVersionsDone() bool {
	if m.ListModelVersionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelVersionsMock.invocationsDone()
}

// MinimockListModelVersionsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelVersionsInspect() {
	for _, e := range m.ListModelVersionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelVersionsCounter := mm_atomic.LoadUint64(&m.afterListModelVersionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelVersionsMock.defaultExpectation != nil && afterListModelVersionsCounter < 1 {
		if m.ListModelVersionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersions at\n%s", m.ListModelVersionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersions at\n%s with params: %#v", m.ListModelVersionsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelVersionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelVersions != nil && afterListModelVersionsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelVersions at\n%s", m.funcListModelVersionsOrigin)
	}

	if !m.ListModelVersionsMock.invocationsDone() && afterListModelVersionsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelVersions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelVersionsMock.expectedInvocations), m.ListModelVersionsMock.expectedInvocationsOrigin, afterListModelVersionsCounter)
	}
}

type mRepositoryMockListModelVersionsByDigest struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelVersionsByDigestExpectation
	expectations       []*RepositoryMockListModelVersionsByDigestExpectation

	callArgs []*RepositoryMockListModelVersionsByDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelVersionsByDigestExpectation specifies expectation struct of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelVersionsByDigestParams
	paramPtrs          *RepositoryMockListModelVersionsByDigestParamPtrs
	expectationOrigins RepositoryMockListModelVersionsByDigestExpectationOrigins
	results            *RepositoryMockListModelVersionsByDigestResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelVersionsByDigestParams contains parameters of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	digest   string
}

// RepositoryMockListModelVersionsByDigestParamPtrs contains pointers to parameters of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	digest   *string
}

// RepositoryMockListModelVersionsByDigestResults contains results of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestResults struct {
	versions []*datamodel.ModelVersion
	err      error
}

// RepositoryMockListModelVersionsByDigestOrigins contains origins of expectations of the Repository.ListModelVersionsByDigest
type RepositoryMockListModelVersionsByDigestExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originDigest   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Optional() *mRepositoryMockListModelVersionsByDigest {
	mmListModelVersionsByDigest.optional = true
	return mmListModelVersionsByDigest
}

// Expect sets up expected params for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Expect(ctx context.Context, modelUID uuid.UUID, digest string) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by ExpectParams functions")
	}

	mmListModelVersionsByDigest.defaultExpectation.params = &RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}
	mmListModelVersionsByDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelVersionsByDigest.expectations {
		if minimock.Equal(e.params, mmListModelVersionsByDigest.defaultExpectation.params) {
			mmListModelVersionsByDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelVersionsByDigest.defaultExpectation.params)
		}
	}

	return mmListModelVersionsByDigest
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelVersionsByDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelVersionsByDigest
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmListModelVersionsByDigest.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmListModelVersionsByDigest
}

// ExpectDigestParam3 sets up expected param digest for Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) ExpectDigestParam3(digest string) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{}
	}

	if mmListModelVersionsByDigest.defaultExpectation.params != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Expect")
	}

	if mmListModelVersionsByDigest.defaultExpectation.paramPtrs == nil {
		mmListModelVersionsByDigest.defaultExpectation.paramPtrs = &RepositoryMockListModelVersionsByDigestParamPtrs{}
	}
	mmListModelVersionsByDigest.defaultExpectation.paramPtrs.digest = &digest
	mmListModelVersionsByDigest.defaultExpectation.expectationOrigins.originDigest = minimock.CallerInfo(1)

	return mmListModelVersionsByDigest
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Inspect(f func(ctx context.Context, modelUID uuid.UUID, digest string)) *mRepositoryMockListModelVersionsByDigest {
	if mmListModelVersionsByDigest.mock.inspectFuncListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelVersionsByDigest")
	}

	mmListModelVersionsByDigest.mock.inspectFuncListModelVersionsByDigest = f

	return mmListModelVersionsByDigest
}

// Return sets up results that will be returned by Repository.ListModelVersionsByDigest
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Return(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	if mmListModelVersionsByDigest.defaultExpectation == nil {
		mmListModelVersionsByDigest.defaultExpectation = &RepositoryMockListModelVersionsByDigestExpectation{mock: mmListModelVersionsByDigest.mock}
	}
	mmListModelVersionsByDigest.defaultExpectation.results = &RepositoryMockListModelVersionsByDigestResults{versions, err}
	mmListModelVersionsByDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelVersionsByDigest.mock
}

// Set uses given function f to mock the Repository.ListModelVersionsByDigest method
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Set(f func(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error)) *RepositoryMock {
	if mmListModelVersionsByDigest.defaultExpectation != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelVersionsByDigest method")
	}

	if len(mmListModelVersionsByDigest.expectations) > 0 {
		mmListModelVersionsByDigest.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelVersionsByDigest method")
	}

	mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest = f
	mmListModelVersionsByDigest.mock.funcListModelVersionsByDigestOrigin = minimock.CallerInfo(1)
	return mmListModelVersionsByDigest.mock
}

// When sets expectation for the Repository.ListModelVersionsByDigest which will trigger the result defined by the following
// Then helper
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) When(ctx context.Context, modelUID uuid.UUID, digest string) *RepositoryMockListModelVersionsByDigestExpectation {
	if mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.mock.t.Fatalf("RepositoryMock.ListModelVersionsByDigest mock is already set by Set")
	}

	expectation := &RepositoryMockListModelVersionsByDigestExpectation{
		mock:               mmListModelVersionsByDigest.mock,
		params:             &RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest},
		expectationOrigins: RepositoryMockListModelVersionsByDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelVersionsByDigest.expectations = append(mmListModelVersionsByDigest.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelVersionsByDigest return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelVersionsByDigestExpectation) Then(versions []*datamodel.ModelVersion, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelVersionsByDigestResults{versions, err}
	return e.mock
}

// Times sets number of times Repository.ListModelVersionsByDigest should be invoked
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Times(n uint64) *mRepositoryMockListModelVersionsByDigest {
	if n == 0 {
		mmListModelVersionsByDigest.mock.t.Fatalf("Times of RepositoryMock.ListModelVersionsByDigest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelVersionsByDigest.expectedInvocations, n)
	mmListModelVersionsByDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelVersionsByDigest
}

func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) invocationsDone() bool {
	if len(mmListModelVersionsByDigest.expectations) == 0 && mmListModelVersionsByDigest.defaultExpectation == nil && mmListModelVersionsByDigest.mock.funcListModelVersionsByDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelVersionsByDigest.mock.afterListModelVersionsByDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelVersionsByDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelVersionsByDigest implements mm_repository.Repository
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigest(ctx context.Context, modelUID uuid.UUID, digest string) (versions []*datamodel.ModelVersion, err error) {
	mm_atomic.AddUint64(&mmListModelVersionsByDigest.beforeListModelVersionsByDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelVersionsByDigest.afterListModelVersionsByDigestCounter, 1)

	mmListModelVersionsByDigest.t.Helper()

	if mmListModelVersionsByDigest.inspectFuncListModelVersionsByDigest != nil {
		mmListModelVersionsByDigest.inspectFuncListModelVersionsByDigest(ctx, modelUID, digest)
	}

	mm_params := RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}

	// Record call args
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.mutex.Lock()
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.callArgs = append(mmListModelVersionsByDigest.ListModelVersionsByDigestMock.callArgs, &mm_params)
	mmListModelVersionsByDigest.ListModelVersionsByDigestMock.mutex.Unlock()

	for _, e := range mmListModelVersionsByDigest.ListModelVersionsByDigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.versions, e.results.err
		}
	}

	if mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.params
		mm_want_ptrs := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelVersionsByDigestParams{ctx, modelUID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameter digest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.expectationOrigins.originDigest, *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelVersionsByDigest.t.Errorf("RepositoryMock.ListModelVersionsByDigest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelVersionsByDigest.ListModelVersionsByDigestMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelVersionsByDigest.t.Fatal("No results are set for the RepositoryMock.ListModelVersionsByDigest")
		}
		return (*mm_results).versions, (*mm_results).err
	}
	if mmListModelVersionsByDigest.funcListModelVersionsByDigest != nil {
		return mmListModelVersionsByDigest.funcListModelVersionsByDigest(ctx, modelUID, digest)
	}
	mmListModelVersionsByDigest.t.Fatalf("Unexpected call to RepositoryMock.ListModelVersionsByDigest. %v %v %v", ctx, modelUID, digest)
	return
}

// ListModelVersionsByDigestAfterCounter returns a count of finished RepositoryMock.ListModelVersionsByDigest invocations
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersionsByDigest.afterListModelVersionsByDigestCounter)
}

// ListModelVersionsByDigestBeforeCounter returns a count of RepositoryMock.ListModelVersionsByDigest invocations
func (mmListModelVersionsByDigest *RepositoryMock) ListModelVersionsByDigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelVersionsByDigest.beforeListModelVersionsByDigestCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelVersionsByDigest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelVersionsByDigest *mRepositoryMockListModelVersionsByDigest) Calls() []*RepositoryMockListModelVersionsByDigestParams {
	mmListModelVersionsByDigest.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelVersionsByDigestParams, len(mmListModelVersionsByDigest.callArgs))
	copy(argCopy, mmListModelVersionsByDigest.callArgs)

	mmListModelVersionsByDigest.mutex.RUnlock()

	return argCopy
}

// MinimockListModelVersionsByDigestDone returns true if the count of the ListModelVersionsByDigest invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelVersionsByDigestDone() bool {
	if m.ListModelVersionsByDigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelVersionsByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelVersionsByDigestMock.invocationsDone()
}

// MinimockListModelVersionsByDigestInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelVersionsByDigestInspect() {
	for _, e := range m.ListModelVersionsByDigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelVersionsByDigestCounter := mm_atomic.LoadUint64(&m.afterListModelVersionsByDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelVersionsByDigestMock.defaultExpectation != nil && afterListModelVersionsByDigestCounter < 1 {
		if m.ListModelVersionsByDigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest at\n%s", m.ListModelVersionsByDigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest at\n%s with params: %#v", m.ListModelVersionsByDigestMock.defaultExpectation.expectationOrigins.origin, *m.ListModelVersionsByDigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelVersionsByDigest != nil && afterListModelVersionsByDigestCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelVersionsByDigest at\n%s", m.funcListModelVersionsByDigestOrigin)
	}

	if !m.ListModelVersionsByDigestMock.invocationsDone() && afterListModelVersionsByDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelVersionsByDigest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelVersionsByDigestMock.expectedInvocations), m.ListModelVersionsByDigestMock.expectedInvocationsOrigin, afterListModelVersionsByDigestCounter)
	}
}

type mRepositoryMockListModels struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelsExpectation
	expectations       []*RepositoryMockListModelsExpectation

	callArgs []*RepositoryMockListModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelsExpectation specifies expectation struct of the Repository.ListModels
type RepositoryMockListModelsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelsParams
	paramPtrs          *RepositoryMockListModelsParamPtrs
	expectationOrigins RepositoryMockListModelsExpectationOrigins
	results            *RepositoryMockListModelsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelsParams contains parameters of the Repository.ListModels
type RepositoryMockListModelsParams struct {
	ctx          context.Context
	pageSize     int64
	pageToken    string
	isBasicView  bool
	filter       filtering.Filter
	uidAllowList []uuid.UUID
	showDeleted  bool
	order        ordering.OrderBy
	visibility   *modelpb.Model_Visibility
}

// RepositoryMockListModelsParamPtrs contains pointers to parameters of the Repository.ListModels
type RepositoryMockListModelsParamPtrs struct {
	ctx          *context.Context
	pageSize     *int64
	pageToken    *string
	isBasicView  *bool
	filter       *filtering.Filter
	uidAllowList *[]uuid.UUID
	showDeleted  *bool
	order        *ordering.OrderBy
	visibility   **modelpb.Model_Visibility
}

// RepositoryMockListModelsResults contains results of the Repository.ListModels
type RepositoryMockListModelsResults struct {
	models        []*datamodel.Model
	totalSize     int64
	nextPageToken string
	err           error
}

// RepositoryMockListModelsOrigins contains origins of expectations of the Repository.ListModels
type RepositoryMockListModelsExpectationOrigins struct {
	origin             string
	originCtx          string
	originPageSize     string
	originPageToken    string
	originIsBasicView  string
	originFilter       string
	originUidAllowList string
	originShowDeleted  string
	originOrder        string
	originVisibility   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModels *mRepositoryMockListModels) Optional() *mRepositoryMockListModels {
	mmListModels.optional = true
	return mmListModels
}

// Expect sets up expected params for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.paramPtrs != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by ExpectParams functions")
	}

	mmListModels.defaultExpectation.params = &RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}
	mmListModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModels.expectations {
		if minimock.Equal(e.params, mmListModels.defaultExpectation.params) {
			mmListModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModels.defaultExpectation.params)
		}
	}

	return mmListModels
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListModels.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListModels.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListModels.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.filter = &filter
	mmListModels.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectUidAllowListParam6 sets up expected param uidAllowList for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectUidAllowListParam6(uidAllowList []uuid.UUID) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListModels.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectShowDeletedParam7 sets up expected param showDeleted for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectShowDeletedParam7(showDeleted bool) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListModels.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectOrderParam8 sets up expected param order for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectOrderParam8(order ordering.OrderBy) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.order = &order
	mmListModels.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListModels
}

// ExpectVisibilityParam9 sets up expected param visibility for Repository.ListModels
func (mmListModels *mRepositoryMockListModels) ExpectVisibilityParam9(visibility *modelpb.Model_Visibility) *mRepositoryMockListModels {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{}
	}

	if mmListModels.defaultExpectation.params != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Expect")
	}

	if mmListModels.defaultExpectation.paramPtrs == nil {
		mmListModels.defaultExpectation.paramPtrs = &RepositoryMockListModelsParamPtrs{}
	}
	mmListModels.defaultExpectation.paramPtrs.visibility = &visibility
	mmListModels.defaultExpectation.expectationOrigins.originVisibility = minimock.CallerInfo(1)

	return mmListModels
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)) *mRepositoryMockListModels {
	if mmListModels.mock.inspectFuncListModels != nil {
		mmListModels.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModels")
	}

	mmListModels.mock.inspectFuncListModels = f

	return mmListModels
}

// Return sets up results that will be returned by Repository.ListModels
func (mmListModels *mRepositoryMockListModels) Return(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	if mmListModels.defaultExpectation == nil {
		mmListModels.defaultExpectation = &RepositoryMockListModelsExpectation{mock: mmListModels.mock}
	}
	mmListModels.defaultExpectation.results = &RepositoryMockListModelsResults{models, totalSize, nextPageToken, err}
	mmListModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModels.mock
}

// Set uses given function f to mock the Repository.ListModels method
func (mmListModels *mRepositoryMockListModels) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)) *RepositoryMock {
	if mmListModels.defaultExpectation != nil {
		mmListModels.mock.t.Fatalf("Default expectation is already set for the Repository.ListModels method")
	}

	if len(mmListModels.expectations) > 0 {
		mmListModels.mock.t.Fatalf("Some expectations are already set for the Repository.ListModels method")
	}

	mmListModels.mock.funcListModels = f
	mmListModels.mock.funcListModelsOrigin = minimock.CallerInfo(1)
	return mmListModels.mock
}

// When sets expectation for the Repository.ListModels which will trigger the result defined by the following
// Then helper
func (mmListModels *mRepositoryMockListModels) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *RepositoryMockListModelsExpectation {
	if mmListModels.mock.funcListModels != nil {
		mmListModels.mock.t.Fatalf("RepositoryMock.ListModels mock is already set by Set")
	}

	expectation := &RepositoryMockListModelsExpectation{
		mock:               mmListModels.mock,
		params:             &RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility},
		expectationOrigins: RepositoryMockListModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModels.expectations = append(mmListModels.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModels return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelsExpectation) Then(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelsResults{models, totalSize, nextPageToken, err}
	return e.mock
}

// Times sets number of times Repository.ListModels should be invoked
func (mmListModels *mRepositoryMockListModels) Times(n uint64) *mRepositoryMockListModels {
	if n == 0 {
		mmListModels.mock.t.Fatalf("Times of RepositoryMock.ListModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModels.expectedInvocations, n)
	mmListModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModels
}

func (mmListModels *mRepositoryMockListModels) invocationsDone() bool {
	if len(mmListModels.expectations) == 0 && mmListModels.defaultExpectation == nil && mmListModels.mock.funcListModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModels.mock.afterListModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModels implements mm_repository.Repository
func (mmListModels *RepositoryMock) ListModels(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error) {
	mm_atomic.AddUint64(&mmListModels.beforeListModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListModels.afterListModelsCounter, 1)

	mmListModels.t.Helper()

	if mmListModels.inspectFuncListModels != nil {
		mmListModels.inspectFuncListModels(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}

	mm_params := RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

	// Record call args
	mmListModels.ListModelsMock.mutex.Lock()
	mmListModels.ListModelsMock.callArgs = append(mmListModels.ListModelsMock.callArgs, &mm_params)
	mmListModels.ListModelsMock.mutex.Unlock()

	for _, e := range mmListModels.ListModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.models, e.results.totalSize, e.results.nextPageToken, e.results.err
		}
	}

	if mmListModels.ListModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModels.ListModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListModels.ListModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListModels.ListModelsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelsParams{ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.visibility != nil && !minimock.Equal(*mm_want_ptrs.visibility, mm_got.visibility) {
				mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameter visibility, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.originVisibility, *mm_want_ptrs.visibility, mm_got.visibility, minimock.Diff(*mm_want_ptrs.visibility, mm_got.visibility))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModels.t.Errorf("RepositoryMock.ListModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModels.ListModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModels.ListModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListModels.t.Fatal("No results are set for the RepositoryMock.ListModels")
		}
		return (*mm_results).models, (*mm_results).totalSize, (*mm_results).nextPageToken, (*mm_results).err
	}
	if mmListModels.funcListModels != nil {
		return mmListModels.funcListModels(ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}
	mmListModels.t.Fatalf("Unexpected call to RepositoryMock.ListModels. %v %v %v %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	return
}

// ListModelsAfterCounter returns a count of finished RepositoryMock.ListModels invocations
func (mmListModels *RepositoryMock) ListModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.afterListModelsCounter)
}

// ListModelsBeforeCounter returns a count of RepositoryMock.ListModels invocations
func (mmListModels *RepositoryMock) ListModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModels.beforeListModelsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModels *mRepositoryMockListModels) Calls() []*RepositoryMockListModelsParams {
	mmListModels.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelsParams, len(mmListModels.callArgs))
	copy(argCopy, mmListModels.callArgs)

	mmListModels.mutex.RUnlock()

	return argCopy
}

// MinimockListModelsDone returns true if the count of the ListModels invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelsDone() bool {
	if m.ListModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelsMock.invocationsDone()
}

// MinimockListModelsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelsInspect() {
	for _, e := range m.ListModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelsCounter := mm_atomic.LoadUint64(&m.afterListModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelsMock.defaultExpectation != nil && afterListModelsCounter < 1 {
		if m.ListModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModels at\n%s", m.ListModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModels at\n%s with params: %#v", m.ListModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModels != nil && afterListModelsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModels at\n%s", m.funcListModelsOrigin)
	}

	if !m.ListModelsMock.invocationsDone() && afterListModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelsMock.expectedInvocations), m.ListModelsMock.expectedInvocationsOrigin, afterListModelsCounter)
	}
}

type mRepositoryMockListModelsAdmin struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListModelsAdminExpectation
	expectations       []*RepositoryMockListModelsAdminExpectation

	callArgs []*RepositoryMockListModelsAdminParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListModelsAdminExpectation specifies expectation struct of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListModelsAdminParams
	paramPtrs          *RepositoryMockListModelsAdminParamPtrs
	expectationOrigins RepositoryMockListModelsAdminExpectationOrigins
	results            *RepositoryMockListModelsAdminResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListModelsAdminParams contains parameters of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminParams struct {
	ctx         context.Context
	pageSize    int64
	pageToken   string
	isBasicView bool
	filter      filtering.Filter
	showDeleted bool
}

// RepositoryMockListModelsAdminParamPtrs contains pointers to parameters of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminParamPtrs struct {
	ctx         *context.Context
	pageSize    *int64
	pageToken   *string
	isBasicView *bool
	filter      *filtering.Filter
	showDeleted *bool
}

// RepositoryMockListModelsAdminResults contains results of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminResults struct {
	mpa1 []*datamodel.Model
	i1   int64
	s1   string
	err  error
}

// RepositoryMockListModelsAdminOrigins contains origins of expectations of the Repository.ListModelsAdmin
type RepositoryMockListModelsAdminExpectationOrigins struct {
	origin            string
	originCtx         string
	originPageSize    string
	originPageToken   string
	originIsBasicView string
	originFilter      string
	originShowDeleted string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Optional() *mRepositoryMockListModelsAdmin {
	mmListModelsAdmin.optional = true
	return mmListModelsAdmin
}

// Expect sets up expected params for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Expect(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by ExpectParams functions")
	}

	mmListModelsAdmin.defaultExpectation.params = &RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}
	mmListModelsAdmin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListModelsAdmin.expectations {
		if minimock.Equal(e.params, mmListModelsAdmin.defaultExpectation.params) {
			mmListModelsAdmin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListModelsAdmin.defaultExpectation.params)
		}
	}

	return mmListModelsAdmin
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.ctx = &ctx
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// ExpectPageSizeParam2 sets up expected param pageSize for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectPageSizeParam2(pageSize int64) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// ExpectPageTokenParam3 sets up expected param pageToken for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectPageTokenParam3(pageToken string) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// ExpectIsBasicViewParam4 sets up expected param isBasicView for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectIsBasicViewParam4(isBasicView bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// ExpectFilterParam5 sets up expected param filter for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectFilterParam5(filter filtering.Filter) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.filter = &filter
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// ExpectShowDeletedParam6 sets up expected param showDeleted for Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) ExpectShowDeletedParam6(showDeleted bool) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{}
	}

	if mmListModelsAdmin.defaultExpectation.params != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Expect")
	}

	if mmListModelsAdmin.defaultExpectation.paramPtrs == nil {
		mmListModelsAdmin.defaultExpectation.paramPtrs = &RepositoryMockListModelsAdminParamPtrs{}
	}
	mmListModelsAdmin.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListModelsAdmin.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListModelsAdmin
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Inspect(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool)) *mRepositoryMockListModelsAdmin {
	if mmListModelsAdmin.mock.inspectFuncListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListModelsAdmin")
	}

	mmListModelsAdmin.mock.inspectFuncListModelsAdmin = f

	return mmListModelsAdmin
}

// Return sets up results that will be returned by Repository.ListModelsAdmin
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Return(mpa1 []*datamodel.Model, i1 int64, s1 string, err error) *RepositoryMock {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	if mmListModelsAdmin.defaultExpectation == nil {
		mmListModelsAdmin.defaultExpectation = &RepositoryMockListModelsAdminExpectation{mock: mmListModelsAdmin.mock}
	}
	mmListModelsAdmin.defaultExpectation.results = &RepositoryMockListModelsAdminResults{mpa1, i1, s1, err}
	mmListModelsAdmin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListModelsAdmin.mock
}

// Set uses given function f to mock the Repository.ListModelsAdmin method
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Set(f func(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error)) *RepositoryMock {
	if mmListModelsAdmin.defaultExpectation != nil {
		mmListModelsAdmin.mock.t.Fatalf("Default expectation is already set for the Repository.ListModelsAdmin method")
	}

	if len(mmListModelsAdmin.expectations) > 0 {
		mmListModelsAdmin.mock.t.Fatalf("Some expectations are already set for the Repository.ListModelsAdmin method")
	}

	mmListModelsAdmin.mock.funcListModelsAdmin = f
	mmListModelsAdmin.mock.funcListModelsAdminOrigin = minimock.CallerInfo(1)
	return mmListModelsAdmin.mock
}

// When sets expectation for the Repository.ListModelsAdmin which will trigger the result defined by the following
// Then helper
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) When(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) *RepositoryMockListModelsAdminExpectation {
	if mmListModelsAdmin.mock.funcListModelsAdmin != nil {
		mmListModelsAdmin.mock.t.Fatalf("RepositoryMock.ListModelsAdmin mock is already set by Set")
	}

	expectation := &RepositoryMockListModelsAdminExpectation{
		mock:               mmListModelsAdmin.mock,
		params:             &RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted},
		expectationOrigins: RepositoryMockListModelsAdminExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListModelsAdmin.expectations = append(mmListModelsAdmin.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListModelsAdmin return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListModelsAdminExpectation) Then(mpa1 []*datamodel.Model, i1 int64, s1 string, err error) *RepositoryMock {
	e.results = &RepositoryMockListModelsAdminResults{mpa1, i1, s1, err}
	return e.mock
}

// Times sets number of times Repository.ListModelsAdmin should be invoked
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Times(n uint64) *mRepositoryMockListModelsAdmin {
	if n == 0 {
		mmListModelsAdmin.mock.t.Fatalf("Times of RepositoryMock.ListModelsAdmin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListModelsAdmin.expectedInvocations, n)
	mmListModelsAdmin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListModelsAdmin
}

func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) invocationsDone() bool {
	if len(mmListModelsAdmin.expectations) == 0 && mmListModelsAdmin.defaultExpectation == nil && mmListModelsAdmin.mock.funcListModelsAdmin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListModelsAdmin.mock.afterListModelsAdminCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListModelsAdmin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListModelsAdmin implements mm_repository.Repository
func (mmListModelsAdmin *RepositoryMock) ListModelsAdmin(ctx context.Context, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, showDeleted bool) (mpa1 []*datamodel.Model, i1 int64, s1 string, err error) {
	mm_atomic.AddUint64(&mmListModelsAdmin.beforeListModelsAdminCounter, 1)
	defer mm_atomic.AddUint64(&mmListModelsAdmin.afterListModelsAdminCounter, 1)

	mmListModelsAdmin.t.Helper()

	if mmListModelsAdmin.inspectFuncListModelsAdmin != nil {
		mmListModelsAdmin.inspectFuncListModelsAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	}

	mm_params := RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}

	// Record call args
	mmListModelsAdmin.ListModelsAdminMock.mutex.Lock()
	mmListModelsAdmin.ListModelsAdminMock.callArgs = append(mmListModelsAdmin.ListModelsAdminMock.callArgs, &mm_params)
	mmListModelsAdmin.ListModelsAdminMock.mutex.Unlock()

	for _, e := range mmListModelsAdmin.ListModelsAdminMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mpa1, e.results.i1, e.results.s1, e.results.err
		}
	}

	if mmListModelsAdmin.ListModelsAdminMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.Counter, 1)
		mm_want := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.params
		mm_want_ptrs := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListModelsAdminParams{ctx, pageSize, pageToken, isBasicView, filter, showDeleted}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListModelsAdmin.t.Errorf("RepositoryMock.ListModelsAdmin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListModelsAdmin.ListModelsAdminMock.defaultExpectation.results
		if mm_results == nil {
			mmListModelsAdmin.t.Fatal("No results are set for the RepositoryMock.ListModelsAdmin")
		}
		return (*mm_results).mpa1, (*mm_results).i1, (*mm_results).s1, (*mm_results).err
	}
	if mmListModelsAdmin.funcListModelsAdmin != nil {
		return mmListModelsAdmin.funcListModelsAdmin(ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	}
	mmListModelsAdmin.t.Fatalf("Unexpected call to RepositoryMock.ListModelsAdmin. %v %v %v %v %v %v", ctx, pageSize, pageToken, isBasicView, filter, showDeleted)
	return
}

// ListModelsAdminAfterCounter returns a count of finished RepositoryMock.ListModelsAdmin invocations
func (mmListModelsAdmin *RepositoryMock) ListModelsAdminAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelsAdmin.afterListModelsAdminCounter)
}

// ListModelsAdminBeforeCounter returns a count of RepositoryMock.ListModelsAdmin invocations
func (mmListModelsAdmin *RepositoryMock) ListModelsAdminBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListModelsAdmin.beforeListModelsAdminCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListModelsAdmin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListModelsAdmin *mRepositoryMockListModelsAdmin) Calls() []*RepositoryMockListModelsAdminParams {
	mmListModelsAdmin.mutex.RLock()

	argCopy := make([]*RepositoryMockListModelsAdminParams, len(mmListModelsAdmin.callArgs))
	copy(argCopy, mmListModelsAdmin.callArgs)

	mmListModelsAdmin.mutex.RUnlock()

	return argCopy
}

// MinimockListModelsAdminDone returns true if the count of the ListModelsAdmin invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListModelsAdminDone() bool {
	if m.ListModelsAdminMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListModelsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListModelsAdminMock.invocationsDone()
}

// MinimockListModelsAdminInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListModelsAdminInspect() {
	for _, e := range m.ListModelsAdminMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListModelsAdminCounter := mm_atomic.LoadUint64(&m.afterListModelsAdminCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListModelsAdminMock.defaultExpectation != nil && afterListModelsAdminCounter < 1 {
		if m.ListModelsAdminMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin at\n%s", m.ListModelsAdminMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin at\n%s with params: %#v", m.ListModelsAdminMock.defaultExpectation.expectationOrigins.origin, *m.ListModelsAdminMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListModelsAdmin != nil && afterListModelsAdminCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListModelsAdmin at\n%s", m.funcListModelsAdminOrigin)
	}

	if !m.ListModelsAdminMock.invocationsDone() && afterListModelsAdminCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListModelsAdmin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListModelsAdminMock.expectedInvocations), m.ListModelsAdminMock.expectedInvocationsOrigin, afterListModelsAdminCounter)
	}
}

type mRepositoryMockListNamespaceModels struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListNamespaceModelsExpectation
	expectations       []*RepositoryMockListNamespaceModelsExpectation

	callArgs []*RepositoryMockListNamespaceModelsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockListNamespaceModelsExpectation specifies expectation struct of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockListNamespaceModelsParams
	paramPtrs          *RepositoryMockListNamespaceModelsParamPtrs
	expectationOrigins RepositoryMockListNamespaceModelsExpectationOrigins
	results            *RepositoryMockListNamespaceModelsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockListNamespaceModelsParams contains parameters of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsParams struct {
	ctx            context.Context
	ownerPermalink string
	pageSize       int64
	pageToken      string
	isBasicView    bool
	filter         filtering.Filter
	uidAllowList   []uuid.UUID
	showDeleted    bool
	order          ordering.OrderBy
	visibility     *modelpb.Model_Visibility
}

// RepositoryMockListNamespaceModelsParamPtrs contains pointers to parameters of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	pageSize       *int64
	pageToken      *string
	isBasicView    *bool
	filter         *filtering.Filter
	uidAllowList   *[]uuid.UUID
	showDeleted    *bool
	order          *ordering.OrderBy
	visibility     **modelpb.Model_Visibility
}

// RepositoryMockListNamespaceModelsResults contains results of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsResults struct {
	models        []*datamodel.Model
	totalSize     int64
	nextPageToken string
	err           error
}

// RepositoryMockListNamespaceModelsOrigins contains origins of expectations of the Repository.ListNamespaceModels
type RepositoryMockListNamespaceModelsExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originPageSize       string
	originPageToken      string
	originIsBasicView    string
	originFilter         string
	originUidAllowList   string
	originShowDeleted    string
	originOrder          string
	originVisibility     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Optional() *mRepositoryMockListNamespaceModels {
	mmListNamespaceModels.optional = true
	return mmListNamespaceModels
}

// Expect sets up expected params for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Expect(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by ExpectParams functions")
	}

	mmListNamespaceModels.defaultExpectation.params = &RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}
	mmListNamespaceModels.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListNamespaceModels.expectations {
		if minimock.Equal(e.params, mmListNamespaceModels.defaultExpectation.params) {
			mmListNamespaceModels.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListNamespaceModels.defaultExpectation.params)
		}
	}

	return mmListNamespaceModels
}

// ExpectCtxParam1 sets up expected param ctx for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectCtxParam1(ctx context.Context) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.ctx = &ctx
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectPageSizeParam3 sets up expected param pageSize for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectPageSizeParam3(pageSize int64) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.pageSize = &pageSize
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originPageSize = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectPageTokenParam4 sets up expected param pageToken for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectPageTokenParam4(pageToken string) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.pageToken = &pageToken
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originPageToken = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectIsBasicViewParam5 sets up expected param isBasicView for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectIsBasicViewParam5(isBasicView bool) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.isBasicView = &isBasicView
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originIsBasicView = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectFilterParam6 sets up expected param filter for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectFilterParam6(filter filtering.Filter) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.filter = &filter
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectUidAllowListParam7 sets up expected param uidAllowList for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectUidAllowListParam7(uidAllowList []uuid.UUID) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.uidAllowList = &uidAllowList
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originUidAllowList = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectShowDeletedParam8 sets up expected param showDeleted for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectShowDeletedParam8(showDeleted bool) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.showDeleted = &showDeleted
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originShowDeleted = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectOrderParam9 sets up expected param order for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectOrderParam9(order ordering.OrderBy) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.order = &order
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// ExpectVisibilityParam10 sets up expected param visibility for Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) ExpectVisibilityParam10(visibility *modelpb.Model_Visibility) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{}
	}

	if mmListNamespaceModels.defaultExpectation.params != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Expect")
	}

	if mmListNamespaceModels.defaultExpectation.paramPtrs == nil {
		mmListNamespaceModels.defaultExpectation.paramPtrs = &RepositoryMockListNamespaceModelsParamPtrs{}
	}
	mmListNamespaceModels.defaultExpectation.paramPtrs.visibility = &visibility
	mmListNamespaceModels.defaultExpectation.expectationOrigins.originVisibility = minimock.CallerInfo(1)

	return mmListNamespaceModels
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Inspect(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility)) *mRepositoryMockListNamespaceModels {
	if mmListNamespaceModels.mock.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListNamespaceModels")
	}

	mmListNamespaceModels.mock.inspectFuncListNamespaceModels = f

	return mmListNamespaceModels
}

// Return sets up results that will be returned by Repository.ListNamespaceModels
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Return(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	if mmListNamespaceModels.defaultExpectation == nil {
		mmListNamespaceModels.defaultExpectation = &RepositoryMockListNamespaceModelsExpectation{mock: mmListNamespaceModels.mock}
	}
	mmListNamespaceModels.defaultExpectation.results = &RepositoryMockListNamespaceModelsResults{models, totalSize, nextPageToken, err}
	mmListNamespaceModels.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels.mock
}

// Set uses given function f to mock the Repository.ListNamespaceModels method
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Set(f func(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error)) *RepositoryMock {
	if mmListNamespaceModels.defaultExpectation != nil {
		mmListNamespaceModels.mock.t.Fatalf("Default expectation is already set for the Repository.ListNamespaceModels method")
	}

	if len(mmListNamespaceModels.expectations) > 0 {
		mmListNamespaceModels.mock.t.Fatalf("Some expectations are already set for the Repository.ListNamespaceModels method")
	}

	mmListNamespaceModels.mock.funcListNamespaceModels = f
	mmListNamespaceModels.mock.funcListNamespaceModelsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels.mock
}

// When sets expectation for the Repository.ListNamespaceModels which will trigger the result defined by the following
// Then helper
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) When(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) *RepositoryMockListNamespaceModelsExpectation {
	if mmListNamespaceModels.mock.funcListNamespaceModels != nil {
		mmListNamespaceModels.mock.t.Fatalf("RepositoryMock.ListNamespaceModels mock is already set by Set")
	}

	expectation := &RepositoryMockListNamespaceModelsExpectation{
		mock:               mmListNamespaceModels.mock,
		params:             &RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility},
		expectationOrigins: RepositoryMockListNamespaceModelsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListNamespaceModels.expectations = append(mmListNamespaceModels.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListNamespaceModels return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListNamespaceModelsExpectation) Then(models []*datamodel.Model, totalSize int64, nextPageToken string, err error) *RepositoryMock {
	e.results = &RepositoryMockListNamespaceModelsResults{models, totalSize, nextPageToken, err}
	return e.mock
}

// Times sets number of times Repository.ListNamespaceModels should be invoked
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Times(n uint64) *mRepositoryMockListNamespaceModels {
	if n == 0 {
		mmListNamespaceModels.mock.t.Fatalf("Times of RepositoryMock.ListNamespaceModels mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListNamespaceModels.expectedInvocations, n)
	mmListNamespaceModels.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListNamespaceModels
}

func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) invocationsDone() bool {
	if len(mmListNamespaceModels.expectations) == 0 && mmListNamespaceModels.defaultExpectation == nil && mmListNamespaceModels.mock.funcListNamespaceModels == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.mock.afterListNamespaceModelsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListNamespaceModels.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListNamespaceModels implements mm_repository.Repository
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModels(ctx context.Context, ownerPermalink string, pageSize int64, pageToken string, isBasicView bool, filter filtering.Filter, uidAllowList []uuid.UUID, showDeleted bool, order ordering.OrderBy, visibility *modelpb.Model_Visibility) (models []*datamodel.Model, totalSize int64, nextPageToken string, err error) {
	mm_atomic.AddUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter, 1)
	defer mm_atomic.AddUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter, 1)

	mmListNamespaceModels.t.Helper()

	if mmListNamespaceModels.inspectFuncListNamespaceModels != nil {
		mmListNamespaceModels.inspectFuncListNamespaceModels(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}

	mm_params := RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

	// Record call args
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Lock()
	mmListNamespaceModels.ListNamespaceModelsMock.callArgs = append(mmListNamespaceModels.ListNamespaceModelsMock.callArgs, &mm_params)
	mmListNamespaceModels.ListNamespaceModelsMock.mutex.Unlock()

	for _, e := range mmListNamespaceModels.ListNamespaceModelsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.models, e.results.totalSize, e.results.nextPageToken, e.results.err
		}
	}

	if mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.Counter, 1)
		mm_want := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.params
		mm_want_ptrs := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockListNamespaceModelsParams{ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.pageSize != nil && !minimock.Equal(*mm_want_ptrs.pageSize, mm_got.pageSize) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter pageSize, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originPageSize, *mm_want_ptrs.pageSize, mm_got.pageSize, minimock.Diff(*mm_want_ptrs.pageSize, mm_got.pageSize))
			}

			if mm_want_ptrs.pageToken != nil && !minimock.Equal(*mm_want_ptrs.pageToken, mm_got.pageToken) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter pageToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originPageToken, *mm_want_ptrs.pageToken, mm_got.pageToken, minimock.Diff(*mm_want_ptrs.pageToken, mm_got.pageToken))
			}

			if mm_want_ptrs.isBasicView != nil && !minimock.Equal(*mm_want_ptrs.isBasicView, mm_got.isBasicView) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter isBasicView, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originIsBasicView, *mm_want_ptrs.isBasicView, mm_got.isBasicView, minimock.Diff(*mm_want_ptrs.isBasicView, mm_got.isBasicView))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.uidAllowList != nil && !minimock.Equal(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter uidAllowList, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originUidAllowList, *mm_want_ptrs.uidAllowList, mm_got.uidAllowList, minimock.Diff(*mm_want_ptrs.uidAllowList, mm_got.uidAllowList))
			}

			if mm_want_ptrs.showDeleted != nil && !minimock.Equal(*mm_want_ptrs.showDeleted, mm_got.showDeleted) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter showDeleted, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originShowDeleted, *mm_want_ptrs.showDeleted, mm_got.showDeleted, minimock.Diff(*mm_want_ptrs.showDeleted, mm_got.showDeleted))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

			if mm_want_ptrs.visibility != nil && !minimock.Equal(*mm_want_ptrs.visibility, mm_got.visibility) {
				mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameter visibility, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.originVisibility, *mm_want_ptrs.visibility, mm_got.visibility, minimock.Diff(*mm_want_ptrs.visibility, mm_got.visibility))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListNamespaceModels.t.Errorf("RepositoryMock.ListNamespaceModels got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListNamespaceModels.ListNamespaceModelsMock.defaultExpectation.results
		if mm_results == nil {
			mmListNamespaceModels.t.Fatal("No results are set for the RepositoryMock.ListNamespaceModels")
		}
		return (*mm_results).models, (*mm_results).totalSize, (*mm_results).nextPageToken, (*mm_results).err
	}
	if mmListNamespaceModels.funcListNamespaceModels != nil {
		return mmListNamespaceModels.funcListNamespaceModels(ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	}
	mmListNamespaceModels.t.Fatalf("Unexpected call to RepositoryMock.ListNamespaceModels. %v %v %v %v %v %v %v %v %v %v", ctx, ownerPermalink, pageSize, pageToken, isBasicView, filter, uidAllowList, showDeleted, order, visibility)
	return
}

// ListNamespaceModelsAfterCounter returns a count of finished RepositoryMock.ListNamespaceModels invocations
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModelsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.afterListNamespaceModelsCounter)
}

// ListNamespaceModelsBeforeCounter returns a count of RepositoryMock.ListNamespaceModels invocations
func (mmListNamespaceModels *RepositoryMock) ListNamespaceModelsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListNamespaceModels.beforeListNamespaceModelsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListNamespaceModels.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListNamespaceModels *mRepositoryMockListNamespaceModels) Calls() []*RepositoryMockListNamespaceModelsParams {
	mmListNamespaceModels.mutex.RLock()

	argCopy := make([]*RepositoryMockListNamespaceModelsParams, len(mmListNamespaceModels.callArgs))
	copy(argCopy, mmListNamespaceModels.callArgs)

	mmListNamespaceModels.mutex.RUnlock()

	return argCopy
}

// MinimockListNamespaceModelsDone returns true if the count of the ListNamespaceModels invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListNamespaceModelsDone() bool {
	if m.ListNamespaceModelsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListNamespaceModelsMock.invocationsDone()
}

// MinimockListNamespaceModelsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListNamespaceModelsInspect() {
	for _, e := range m.ListNamespaceModelsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListNamespaceModelsCounter := mm_atomic.LoadUint64(&m.afterListNamespaceModelsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListNamespaceModelsMock.defaultExpectation != nil && afterListNamespaceModelsCounter < 1 {
		if m.ListNamespaceModelsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels at\n%s", m.ListNamespaceModelsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels at\n%s with params: %#v", m.ListNamespaceModelsMock.defaultExpectation.expectationOrigins.origin, *m.ListNamespaceModelsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListNamespaceModels != nil && afterListNamespaceModelsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.ListNamespaceModels at\n%s", m.funcListNamespaceModelsOrigin)
	}

	if !m.ListNamespaceModelsMock.invocationsDone() && afterListNamespaceModelsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.ListNamespaceModels at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListNamespaceModelsMock.expectedInvocations), m.ListNamespaceModelsMock.expectedInvocationsOrigin, afterListNamespaceModelsCounter)
	}
}

type mRepositoryMockPinUser struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockPinUserExpectation
	expectations       []*RepositoryMockPinUserExpectation

	callArgs []*RepositoryMockPinUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockPinUserExpectation specifies expectation struct of the Repository.PinUser
type RepositoryMockPinUserExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockPinUserParams
	paramPtrs          *RepositoryMockPinUserParamPtrs
	expectationOrigins RepositoryMockPinUserExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RepositoryMockPinUserParams contains parameters of the Repository.PinUser
type RepositoryMockPinUserParams struct {
	ctx   context.Context
	table string
}

// RepositoryMockPinUserParamPtrs contains pointers to parameters of the Repository.PinUser
type RepositoryMockPinUserParamPtrs struct {
	ctx   *context.Context
	table *string
}

// RepositoryMockPinUserOrigins contains origins of expectations of the Repository.PinUser
type RepositoryMockPinUserExpectationOrigins struct {
	origin      string
	originCtx   string
	originTable string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPinUser *mRepositoryMockPinUser) Optional() *mRepositoryMockPinUser {
	mmPinUser.optional = true
	return mmPinUser
}

// Expect sets up expected params for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Expect(ctx context.Context, table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.paramPtrs != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by ExpectParams functions")
	}

	mmPinUser.defaultExpectation.params = &RepositoryMockPinUserParams{ctx, table}
	mmPinUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPinUser.expectations {
		if minimock.Equal(e.params, mmPinUser.defaultExpectation.params) {
			mmPinUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPinUser.defaultExpectation.params)
		}
	}

	return mmPinUser
}

// ExpectCtxParam1 sets up expected param ctx for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectCtxParam1(ctx context.Context) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmPinUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPinUser
}

// ExpectTableParam2 sets up expected param table for Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) ExpectTableParam2(table string) *mRepositoryMockPinUser {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{}
	}

	if mmPinUser.defaultExpectation.params != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Expect")
	}

	if mmPinUser.defaultExpectation.paramPtrs == nil {
		mmPinUser.defaultExpectation.paramPtrs = &RepositoryMockPinUserParamPtrs{}
	}
	mmPinUser.defaultExpectation.paramPtrs.table = &table
	mmPinUser.defaultExpectation.expectationOrigins.originTable = minimock.CallerInfo(1)

	return mmPinUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Inspect(f func(ctx context.Context, table string)) *mRepositoryMockPinUser {
	if mmPinUser.mock.inspectFuncPinUser != nil {
		mmPinUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.PinUser")
	}

	mmPinUser.mock.inspectFuncPinUser = f

	return mmPinUser
}

// Return sets up results that will be returned by Repository.PinUser
func (mmPinUser *mRepositoryMockPinUser) Return() *RepositoryMock {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	if mmPinUser.defaultExpectation == nil {
		mmPinUser.defaultExpectation = &RepositoryMockPinUserExpectation{mock: mmPinUser.mock}
	}

	mmPinUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// Set uses given function f to mock the Repository.PinUser method
func (mmPinUser *mRepositoryMockPinUser) Set(f func(ctx context.Context, table string)) *RepositoryMock {
	if mmPinUser.defaultExpectation != nil {
		mmPinUser.mock.t.Fatalf("Default expectation is already set for the Repository.PinUser method")
	}

	if len(mmPinUser.expectations) > 0 {
		mmPinUser.mock.t.Fatalf("Some expectations are already set for the Repository.PinUser method")
	}

	mmPinUser.mock.funcPinUser = f
	mmPinUser.mock.funcPinUserOrigin = minimock.CallerInfo(1)
	return mmPinUser.mock
}

// When sets expectation for the Repository.PinUser which will trigger the result defined by the following
// Then helper
func (mmPinUser *mRepositoryMockPinUser) When(ctx context.Context, table string) *RepositoryMockPinUserExpectation {
	if mmPinUser.mock.funcPinUser != nil {
		mmPinUser.mock.t.Fatalf("RepositoryMock.PinUser mock is already set by Set")
	}

	expectation := &RepositoryMockPinUserExpectation{
		mock:               mmPinUser.mock,
		params:             &RepositoryMockPinUserParams{ctx, table},
		expectationOrigins: RepositoryMockPinUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPinUser.expectations = append(mmPinUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.PinUser return parameters for the expectation previously defined by the When method

func (e *RepositoryMockPinUserExpectation) Then() *RepositoryMock {
	return e.mock
}

// Times sets number of times Repository.PinUser should be invoked
func (mmPinUser *mRepositoryMockPinUser) Times(n uint64) *mRepositoryMockPinUser {
	if n == 0 {
		mmPinUser.mock.t.Fatalf("Times of RepositoryMock.PinUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPinUser.expectedInvocations, n)
	mmPinUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPinUser
}

func (mmPinUser *mRepositoryMockPinUser) invocationsDone() bool {
	if len(mmPinUser.expectations) == 0 && mmPinUser.defaultExpectation == nil && mmPinUser.mock.funcPinUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPinUser.mock.afterPinUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPinUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// PinUser implements mm_repository.Repository
func (mmPinUser *RepositoryMock) PinUser(ctx context.Context, table string) {
	mm_atomic.AddUint64(&mmPinUser.beforePinUserCounter, 1)
	defer mm_atomic.AddUint64(&mmPinUser.afterPinUserCounter, 1)

	mmPinUser.t.Helper()

	if mmPinUser.inspectFuncPinUser != nil {
		mmPinUser.inspectFuncPinUser(ctx, table)
	}

	mm_params := RepositoryMockPinUserParams{ctx, table}

	// Record call args
	mmPinUser.PinUserMock.mutex.Lock()
	mmPinUser.PinUserMock.callArgs = append(mmPinUser.PinUserMock.callArgs, &mm_params)
	mmPinUser.PinUserMock.mutex.Unlock()

	for _, e := range mmPinUser.PinUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmPinUser.PinUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPinUser.PinUserMock.defaultExpectation.Counter, 1)
		mm_want := mmPinUser.PinUserMock.defaultExpectation.params
		mm_want_ptrs := mmPinUser.PinUserMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockPinUserParams{ctx, table}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.table != nil && !minimock.Equal(*mm_want_ptrs.table, mm_got.table) {
				mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameter table, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.originTable, *mm_want_ptrs.table, mm_got.table, minimock.Diff(*mm_want_ptrs.table, mm_got.table))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPinUser.t.Errorf("RepositoryMock.PinUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPinUser.PinUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmPinUser.funcPinUser != nil {
		mmPinUser.funcPinUser(ctx, table)
		return
	}
	mmPinUser.t.Fatalf("Unexpected call to RepositoryMock.PinUser. %v %v", ctx, table)

}

// PinUserAfterCounter returns a count of finished RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.afterPinUserCounter)
}

// PinUserBeforeCounter returns a count of RepositoryMock.PinUser invocations
func (mmPinUser *RepositoryMock) PinUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPinUser.beforePinUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.PinUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPinUser *mRepositoryMockPinUser) Calls() []*RepositoryMockPinUserParams {
	mmPinUser.mutex.RLock()

	argCopy := make([]*RepositoryMockPinUserParams, len(mmPinUser.callArgs))
	copy(argCopy, mmPinUser.callArgs)

	mmPinUser.mutex.RUnlock()

	return argCopy
}

// MinimockPinUserDone returns true if the count of the PinUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockPinUserDone() bool {
	if m.PinUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PinUserMock.invocationsDone()
}

// MinimockPinUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockPinUserInspect() {
	for _, e := range m.PinUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPinUserCounter := mm_atomic.LoadUint64(&m.afterPinUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PinUserMock.defaultExpectation != nil && afterPinUserCounter < 1 {
		if m.PinUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.PinUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s with params: %#v", m.PinUserMock.defaultExpectation.expectationOrigins.origin, *m.PinUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPinUser != nil && afterPinUserCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.PinUser at\n%s", m.funcPinUserOrigin)
	}

	if !m.PinUserMock.invocationsDone() && afterPinUserCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.PinUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PinUserMock.expectedInvocations), m.PinUserMock.expectedInvocationsOrigin, afterPinUserCounter)
	}
}

type mRepositoryMockUpdateModelRun struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateModelRunExpectation
	expectations       []*RepositoryMockUpdateModelRunExpectation

	callArgs []*RepositoryMockUpdateModelRunParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateModelRunExpectation specifies expectation struct of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateModelRunParams
	paramPtrs          *RepositoryMockUpdateModelRunParamPtrs
	expectationOrigins RepositoryMockUpdateModelRunExpectationOrigins
	results            *RepositoryMockUpdateModelRunResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateModelRunParams contains parameters of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunParams struct {
	ctx      context.Context
	modelRun *datamodel.ModelRun
}

// RepositoryMockUpdateModelRunParamPtrs contains pointers to parameters of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunParamPtrs struct {
	ctx      *context.Context
	modelRun **datamodel.ModelRun
}

// RepositoryMockUpdateModelRunResults contains results of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunResults struct {
	err error
}

// RepositoryMockUpdateModelRunOrigins contains origins of expectations of the Repository.UpdateModelRun
type RepositoryMockUpdateModelRunExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelRun string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Optional() *mRepositoryMockUpdateModelRun {
	mmUpdateModelRun.optional = true
	return mmUpdateModelRun
}

// Expect sets up expected params for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Expect(ctx context.Context, modelRun *datamodel.ModelRun) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by ExpectParams functions")
	}

	mmUpdateModelRun.defaultExpectation.params = &RepositoryMockUpdateModelRunParams{ctx, modelRun}
	mmUpdateModelRun.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateModelRun.expectations {
		if minimock.Equal(e.params, mmUpdateModelRun.defaultExpectation.params) {
			mmUpdateModelRun.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateModelRun.defaultExpectation.params)
		}
	}

	return mmUpdateModelRun
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.params != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Expect")
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs == nil {
		mmUpdateModelRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelRunParamPtrs{}
	}
	mmUpdateModelRun.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateModelRun.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateModelRun
}

// ExpectModelRunParam2 sets up expected param modelRun for Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) ExpectModelRunParam2(modelRun *datamodel.ModelRun) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{}
	}

	if mmUpdateModelRun.defaultExpectation.params != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Expect")
	}

	if mmUpdateModelRun.defaultExpectation.paramPtrs == nil {
		mmUpdateModelRun.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelRunParamPtrs{}
	}
	mmUpdateModelRun.defaultExpectation.paramPtrs.modelRun = &modelRun
	mmUpdateModelRun.defaultExpectation.expectationOrigins.originModelRun = minimock.CallerInfo(1)

	return mmUpdateModelRun
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Inspect(f func(ctx context.Context, modelRun *datamodel.ModelRun)) *mRepositoryMockUpdateModelRun {
	if mmUpdateModelRun.mock.inspectFuncUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateModelRun")
	}

	mmUpdateModelRun.mock.inspectFuncUpdateModelRun = f

	return mmUpdateModelRun
}

// Return sets up results that will be returned by Repository.UpdateModelRun
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Return(err error) *RepositoryMock {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	if mmUpdateModelRun.defaultExpectation == nil {
		mmUpdateModelRun.defaultExpectation = &RepositoryMockUpdateModelRunExpectation{mock: mmUpdateModelRun.mock}
	}
	mmUpdateModelRun.defaultExpectation.results = &RepositoryMockUpdateModelRunResults{err}
	mmUpdateModelRun.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateModelRun.mock
}

// Set uses given function f to mock the Repository.UpdateModelRun method
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Set(f func(ctx context.Context, modelRun *datamodel.ModelRun) (err error)) *RepositoryMock {
	if mmUpdateModelRun.defaultExpectation != nil {
		mmUpdateModelRun.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateModelRun method")
	}

	if len(mmUpdateModelRun.expectations) > 0 {
		mmUpdateModelRun.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateModelRun method")
	}

	mmUpdateModelRun.mock.funcUpdateModelRun = f
	mmUpdateModelRun.mock.funcUpdateModelRunOrigin = minimock.CallerInfo(1)
	return mmUpdateModelRun.mock
}

// When sets expectation for the Repository.UpdateModelRun which will trigger the result defined by the following
// Then helper
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) When(ctx context.Context, modelRun *datamodel.ModelRun) *RepositoryMockUpdateModelRunExpectation {
	if mmUpdateModelRun.mock.funcUpdateModelRun != nil {
		mmUpdateModelRun.mock.t.Fatalf("RepositoryMock.UpdateModelRun mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateModelRunExpectation{
		mock:               mmUpdateModelRun.mock,
		params:             &RepositoryMockUpdateModelRunParams{ctx, modelRun},
		expectationOrigins: RepositoryMockUpdateModelRunExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateModelRun.expectations = append(mmUpdateModelRun.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateModelRun return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateModelRunExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateModelRunResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateModelRun should be invoked
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Times(n uint64) *mRepositoryMockUpdateModelRun {
	if n == 0 {
		mmUpdateModelRun.mock.t.Fatalf("Times of RepositoryMock.UpdateModelRun mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateModelRun.expectedInvocations, n)
	mmUpdateModelRun.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateModelRun
}

func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) invocationsDone() bool {
	if len(mmUpdateModelRun.expectations) == 0 && mmUpdateModelRun.defaultExpectation == nil && mmUpdateModelRun.mock.funcUpdateModelRun == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateModelRun.mock.afterUpdateModelRunCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateModelRun.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateModelRun implements mm_repository.Repository
func (mmUpdateModelRun *RepositoryMock) UpdateModelRun(ctx context.Context, modelRun *datamodel.ModelRun) (err error) {
	mm_atomic.AddUint64(&mmUpdateModelRun.beforeUpdateModelRunCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateModelRun.afterUpdateModelRunCounter, 1)

	mmUpdateModelRun.t.Helper()

	if mmUpdateModelRun.inspectFuncUpdateModelRun != nil {
		mmUpdateModelRun.inspectFuncUpdateModelRun(ctx, modelRun)
	}

	mm_params := RepositoryMockUpdateModelRunParams{ctx, modelRun}

	// Record call args
	mmUpdateModelRun.UpdateModelRunMock.mutex.Lock()
	mmUpdateModelRun.UpdateModelRunMock.callArgs = append(mmUpdateModelRun.UpdateModelRunMock.callArgs, &mm_params)
	mmUpdateModelRun.UpdateModelRunMock.mutex.Unlock()

	for _, e := range mmUpdateModelRun.UpdateModelRunMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateModelRun.UpdateModelRunMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateModelRunParams{ctx, modelRun}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelRun != nil && !minimock.Equal(*mm_want_ptrs.modelRun, mm_got.modelRun) {
				mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameter modelRun, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.expectationOrigins.originModelRun, *mm_want_ptrs.modelRun, mm_got.modelRun, minimock.Diff(*mm_want_ptrs.modelRun, mm_got.modelRun))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateModelRun.t.Errorf("RepositoryMock.UpdateModelRun got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateModelRun.UpdateModelRunMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateModelRun.t.Fatal("No results are set for the RepositoryMock.UpdateModelRun")
		}
		return (*mm_results).err
	}
	if mmUpdateModelRun.funcUpdateModelRun != nil {
		return mmUpdateModelRun.funcUpdateModelRun(ctx, modelRun)
	}
	mmUpdateModelRun.t.Fatalf("Unexpected call to RepositoryMock.UpdateModelRun. %v %v", ctx, modelRun)
	return
}

// UpdateModelRunAfterCounter returns a count of finished RepositoryMock.UpdateModelRun invocations
func (mmUpdateModelRun *RepositoryMock) UpdateModelRunAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelRun.afterUpdateModelRunCounter)
}

// UpdateModelRunBeforeCounter returns a count of RepositoryMock.UpdateModelRun invocations
func (mmUpdateModelRun *RepositoryMock) UpdateModelRunBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelRun.beforeUpdateModelRunCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateModelRun.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateModelRun *mRepositoryMockUpdateModelRun) Calls() []*RepositoryMockUpdateModelRunParams {
	mmUpdateModelRun.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateModelRunParams, len(mmUpdateModelRun.callArgs))
	copy(argCopy, mmUpdateModelRun.callArgs)

	mmUpdateModelRun.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateModelRunDone returns true if the count of the UpdateModelRun invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateModelRunDone() bool {
	if m.UpdateModelRunMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateModelRunMock.invocationsDone()
}

// MinimockUpdateModelRunInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateModelRunInspect() {
	for _, e := range m.UpdateModelRunMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateModelRunCounter := mm_atomic.LoadUint64(&m.afterUpdateModelRunCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateModelRunMock.defaultExpectation != nil && afterUpdateModelRunCounter < 1 {
		if m.UpdateModelRunMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun at\n%s", m.UpdateModelRunMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun at\n%s with params: %#v", m.UpdateModelRunMock.defaultExpectation.expectationOrigins.origin, *m.UpdateModelRunMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateModelRun != nil && afterUpdateModelRunCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateModelRun at\n%s", m.funcUpdateModelRunOrigin)
	}

	if !m.UpdateModelRunMock.invocationsDone() && afterUpdateModelRunCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateModelRun at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateModelRunMock.expectedInvocations), m.UpdateModelRunMock.expectedInvocationsOrigin, afterUpdateModelRunCounter)
	}
}

type mRepositoryMockUpdateModelVersionDigestByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateModelVersionDigestByIDExpectation
	expectations       []*RepositoryMockUpdateModelVersionDigestByIDExpectation

	callArgs []*RepositoryMockUpdateModelVersionDigestByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateModelVersionDigestByIDExpectation specifies expectation struct of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateModelVersionDigestByIDParams
	paramPtrs          *RepositoryMockUpdateModelVersionDigestByIDParamPtrs
	expectationOrigins RepositoryMockUpdateModelVersionDigestByIDExpectationOrigins
	results            *RepositoryMockUpdateModelVersionDigestByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateModelVersionDigestByIDParams contains parameters of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDParams struct {
	ctx       context.Context
	modelUID  uuid.UUID
	versionID string
	digest    string
}

// RepositoryMockUpdateModelVersionDigestByIDParamPtrs contains pointers to parameters of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDParamPtrs struct {
	ctx       *context.Context
	modelUID  *uuid.UUID
	versionID *string
	digest    *string
}

// RepositoryMockUpdateModelVersionDigestByIDResults contains results of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDResults struct {
	err error
}

// RepositoryMockUpdateModelVersionDigestByIDOrigins contains origins of expectations of the Repository.UpdateModelVersionDigestByID
type RepositoryMockUpdateModelVersionDigestByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelUID  string
	originVersionID string
	originDigest    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Optional() *mRepositoryMockUpdateModelVersionDigestByID {
	mmUpdateModelVersionDigestByID.optional = true
	return mmUpdateModelVersionDigestByID
}

// Expect sets up expected params for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Expect(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by ExpectParams functions")
	}

	mmUpdateModelVersionDigestByID.defaultExpectation.params = &RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}
	mmUpdateModelVersionDigestByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateModelVersionDigestByID.expectations {
		if minimock.Equal(e.params, mmUpdateModelVersionDigestByID.defaultExpectation.params) {
			mmUpdateModelVersionDigestByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateModelVersionDigestByID.defaultExpectation.params)
		}
	}

	return mmUpdateModelVersionDigestByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateModelVersionDigestByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateModelVersionDigestByID
}

// ExpectModelUIDParam2 sets up expected param modelUID for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectModelUIDParam2(modelUID uuid.UUID) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmUpdateModelVersionDigestByID.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmUpdateModelVersionDigestByID
}

// ExpectVersionIDParam3 sets up expected param versionID for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectVersionIDParam3(versionID string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.versionID = &versionID
	mmUpdateModelVersionDigestByID.defaultExpectation.expectationOrigins.originVersionID = minimock.CallerInfo(1)

	return mmUpdateModelVersionDigestByID
}

// ExpectDigestParam4 sets up expected param digest for Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) ExpectDigestParam4(digest string) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{}
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.params != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Expect")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateModelVersionDigestByIDParamPtrs{}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.paramPtrs.digest = &digest
	mmUpdateModelVersionDigestByID.defaultExpectation.expectationOrigins.originDigest = minimock.CallerInfo(1)

	return mmUpdateModelVersionDigestByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Inspect(f func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string)) *mRepositoryMockUpdateModelVersionDigestByID {
	if mmUpdateModelVersionDigestByID.mock.inspectFuncUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateModelVersionDigestByID")
	}

	mmUpdateModelVersionDigestByID.mock.inspectFuncUpdateModelVersionDigestByID = f

	return mmUpdateModelVersionDigestByID
}

// Return sets up results that will be returned by Repository.UpdateModelVersionDigestByID
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Return(err error) *RepositoryMock {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	if mmUpdateModelVersionDigestByID.defaultExpectation == nil {
		mmUpdateModelVersionDigestByID.defaultExpectation = &RepositoryMockUpdateModelVersionDigestByIDExpectation{mock: mmUpdateModelVersionDigestByID.mock}
	}
	mmUpdateModelVersionDigestByID.defaultExpectation.results = &RepositoryMockUpdateModelVersionDigestByIDResults{err}
	mmUpdateModelVersionDigestByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateModelVersionDigestByID.mock
}

// Set uses given function f to mock the Repository.UpdateModelVersionDigestByID method
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Set(f func(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error)) *RepositoryMock {
	if mmUpdateModelVersionDigestByID.defaultExpectation != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateModelVersionDigestByID method")
	}

	if len(mmUpdateModelVersionDigestByID.expectations) > 0 {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateModelVersionDigestByID method")
	}

	mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID = f
	mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateModelVersionDigestByID.mock
}

// When sets expectation for the Repository.UpdateModelVersionDigestByID which will trigger the result defined by the following
// Then helper
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) When(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) *RepositoryMockUpdateModelVersionDigestByIDExpectation {
	if mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("RepositoryMock.UpdateModelVersionDigestByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateModelVersionDigestByIDExpectation{
		mock:               mmUpdateModelVersionDigestByID.mock,
		params:             &RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest},
		expectationOrigins: RepositoryMockUpdateModelVersionDigestByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateModelVersionDigestByID.expectations = append(mmUpdateModelVersionDigestByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateModelVersionDigestByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateModelVersionDigestByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateModelVersionDigestByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateModelVersionDigestByID should be invoked
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Times(n uint64) *mRepositoryMockUpdateModelVersionDigestByID {
	if n == 0 {
		mmUpdateModelVersionDigestByID.mock.t.Fatalf("Times of RepositoryMock.UpdateModelVersionDigestByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateModelVersionDigestByID.expectedInvocations, n)
	mmUpdateModelVersionDigestByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateModelVersionDigestByID
}

func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) invocationsDone() bool {
	if len(mmUpdateModelVersionDigestByID.expectations) == 0 && mmUpdateModelVersionDigestByID.defaultExpectation == nil && mmUpdateModelVersionDigestByID.mock.funcUpdateModelVersionDigestByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.mock.afterUpdateModelVersionDigestByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateModelVersionDigestByID implements mm_repository.Repository
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByID(ctx context.Context, modelUID uuid.UUID, versionID string, digest string) (err error) {
	mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.beforeUpdateModelVersionDigestByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.afterUpdateModelVersionDigestByIDCounter, 1)

	mmUpdateModelVersionDigestByID.t.Helper()

	if mmUpdateModelVersionDigestByID.inspectFuncUpdateModelVersionDigestByID != nil {
		mmUpdateModelVersionDigestByID.inspectFuncUpdateModelVersionDigestByID(ctx, modelUID, versionID, digest)
	}

	mm_params := RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}

	// Record call args
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.mutex.Lock()
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.callArgs = append(mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.callArgs, &mm_params)
	mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.mutex.Unlock()

	for _, e := range mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateModelVersionDigestByIDParams{ctx, modelUID, versionID, digest}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.versionID != nil && !minimock.Equal(*mm_want_ptrs.versionID, mm_got.versionID) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter versionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.originVersionID, *mm_want_ptrs.versionID, mm_got.versionID, minimock.Diff(*mm_want_ptrs.versionID, mm_got.versionID))
			}

			if mm_want_ptrs.digest != nil && !minimock.Equal(*mm_want_ptrs.digest, mm_got.digest) {
				mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameter digest, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.originDigest, *mm_want_ptrs.digest, mm_got.digest, minimock.Diff(*mm_want_ptrs.digest, mm_got.digest))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateModelVersionDigestByID.t.Errorf("RepositoryMock.UpdateModelVersionDigestByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateModelVersionDigestByID.UpdateModelVersionDigestByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateModelVersionDigestByID.t.Fatal("No results are set for the RepositoryMock.UpdateModelVersionDigestByID")
		}
		return (*mm_results).err
	}
	if mmUpdateModelVersionDigestByID.funcUpdateModelVersionDigestByID != nil {
		return mmUpdateModelVersionDigestByID.funcUpdateModelVersionDigestByID(ctx, modelUID, versionID, digest)
	}
	mmUpdateModelVersionDigestByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateModelVersionDigestByID. %v %v %v %v", ctx, modelUID, versionID, digest)
	return
}

// UpdateModelVersionDigestByIDAfterCounter returns a count of finished RepositoryMock.UpdateModelVersionDigestByID invocations
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.afterUpdateModelVersionDigestByIDCounter)
}

// UpdateModelVersionDigestByIDBeforeCounter returns a count of RepositoryMock.UpdateModelVersionDigestByID invocations
func (mmUpdateModelVersionDigestByID *RepositoryMock) UpdateModelVersionDigestByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModelVersionDigestByID.beforeUpdateModelVersionDigestByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateModelVersionDigestByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateModelVersionDigestByID *mRepositoryMockUpdateModelVersionDigestByID) Calls() []*RepositoryMockUpdateModelVersionDigestByIDParams {
	mmUpdateModelVersionDigestByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateModelVersionDigestByIDParams, len(mmUpdateModelVersionDigestByID.callArgs))
	copy(argCopy, mmUpdateModelVersionDigestByID.callArgs)

	mmUpdateModelVersionDigestByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateModelVersionDigestByIDDone returns true if the count of the UpdateModelVersionDigestByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateModelVersionDigestByIDDone() bool {
	if m.UpdateModelVersionDigestByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateModelVersionDigestByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateModelVersionDigestByIDMock.invocationsDone()
}

// MinimockUpdateModelVersionDigestByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateModelVersionDigestByIDInspect() {
	for _, e := range m.UpdateModelVersionDigestByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateModelVersionDigestByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateModelVersionDigestByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateModelVersionDigestByIDMock.defaultExpectation != nil && afterUpdateModelVersionDigestByIDCounter < 1 {
		if m.UpdateModelVersionDigestByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID at\n%s", m.UpdateModelVersionDigestByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID at\n%s with params: %#v", m.UpdateModelVersionDigestByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateModelVersionDigestByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateModelVersionDigestByID != nil && afterUpdateModelVersionDigestByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateModelVersionDigestByID at\n%s", m.funcUpdateModelVersionDigestByIDOrigin)
	}

	if !m.UpdateModelVersionDigestByIDMock.invocationsDone() && afterUpdateModelVersionDigestByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateModelVersionDigestByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateModelVersionDigestByIDMock.expectedInvocations), m.UpdateModelVersionDigestByIDMock.expectedInvocationsOrigin, afterUpdateModelVersionDigestByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceModelByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceModelByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceModelByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceModelByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceModelByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceModelByIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceModelByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceModelByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceModelByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceModelByIDParams contains parameters of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	model          *datamodel.Model
}

// RepositoryMockUpdateNamespaceModelByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	model          **datamodel.Model
}

// RepositoryMockUpdateNamespaceModelByIDResults contains results of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespaceModelByIDOrigins contains origins of expectations of the Repository.UpdateNamespaceModelByID
type RepositoryMockUpdateNamespaceModelByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originModel          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Optional() *mRepositoryMockUpdateNamespaceModelByID {
	mmUpdateNamespaceModelByID.optional = true
	return mmUpdateNamespaceModelByID
}

// Expect sets up expected params for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Expect(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceModelByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}
	mmUpdateNamespaceModelByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceModelByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceModelByID.defaultExpectation.params) {
			mmUpdateNamespaceModelByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceModelByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceModelByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceModelByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespaceModelByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespaceModelByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelByID
}

// ExpectModelParam4 sets up expected param model for Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) ExpectModelParam4(model *datamodel.Model) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{}
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelByIDParamPtrs{}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.paramPtrs.model = &model
	mmUpdateNamespaceModelByID.defaultExpectation.expectationOrigins.originModel = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model)) *mRepositoryMockUpdateNamespaceModelByID {
	if mmUpdateNamespaceModelByID.mock.inspectFuncUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceModelByID")
	}

	mmUpdateNamespaceModelByID.mock.inspectFuncUpdateNamespaceModelByID = f

	return mmUpdateNamespaceModelByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceModelByID
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelByID.defaultExpectation == nil {
		mmUpdateNamespaceModelByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelByIDExpectation{mock: mmUpdateNamespaceModelByID.mock}
	}
	mmUpdateNamespaceModelByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceModelByIDResults{err}
	mmUpdateNamespaceModelByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceModelByID method
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Set(f func(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error)) *RepositoryMock {
	if mmUpdateNamespaceModelByID.defaultExpectation != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceModelByID method")
	}

	if len(mmUpdateNamespaceModelByID.expectations) > 0 {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceModelByID method")
	}

	mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID = f
	mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceModelByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) When(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) *RepositoryMockUpdateNamespaceModelByIDExpectation {
	if mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceModelByIDExpectation{
		mock:               mmUpdateNamespaceModelByID.mock,
		params:             &RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model},
		expectationOrigins: RepositoryMockUpdateNamespaceModelByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceModelByID.expectations = append(mmUpdateNamespaceModelByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceModelByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceModelByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceModelByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceModelByID should be invoked
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Times(n uint64) *mRepositoryMockUpdateNamespaceModelByID {
	if n == 0 {
		mmUpdateNamespaceModelByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceModelByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceModelByID.expectedInvocations, n)
	mmUpdateNamespaceModelByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelByID
}

func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) invocationsDone() bool {
	if len(mmUpdateNamespaceModelByID.expectations) == 0 && mmUpdateNamespaceModelByID.defaultExpectation == nil && mmUpdateNamespaceModelByID.mock.funcUpdateNamespaceModelByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.mock.afterUpdateNamespaceModelByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceModelByID implements mm_repository.Repository
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByID(ctx context.Context, ownerPermalink string, id string, model *datamodel.Model) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.beforeUpdateNamespaceModelByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.afterUpdateNamespaceModelByIDCounter, 1)

	mmUpdateNamespaceModelByID.t.Helper()

	if mmUpdateNamespaceModelByID.inspectFuncUpdateNamespaceModelByID != nil {
		mmUpdateNamespaceModelByID.inspectFuncUpdateNamespaceModelByID(ctx, ownerPermalink, id, model)
	}

	mm_params := RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}

	// Record call args
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.mutex.Lock()
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.callArgs = append(mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceModelByIDParams{ctx, ownerPermalink, id, model}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.model != nil && !minimock.Equal(*mm_want_ptrs.model, mm_got.model) {
				mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameter model, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.originModel, *mm_want_ptrs.model, mm_got.model, minimock.Diff(*mm_want_ptrs.model, mm_got.model))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceModelByID.t.Errorf("RepositoryMock.UpdateNamespaceModelByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceModelByID.UpdateNamespaceModelByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceModelByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceModelByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceModelByID.funcUpdateNamespaceModelByID != nil {
		return mmUpdateNamespaceModelByID.funcUpdateNamespaceModelByID(ctx, ownerPermalink, id, model)
	}
	mmUpdateNamespaceModelByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceModelByID. %v %v %v %v", ctx, ownerPermalink, id, model)
	return
}

// UpdateNamespaceModelByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceModelByID invocations
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.afterUpdateNamespaceModelByIDCounter)
}

// UpdateNamespaceModelByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceModelByID invocations
func (mmUpdateNamespaceModelByID *RepositoryMock) UpdateNamespaceModelByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelByID.beforeUpdateNamespaceModelByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceModelByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceModelByID *mRepositoryMockUpdateNamespaceModelByID) Calls() []*RepositoryMockUpdateNamespaceModelByIDParams {
	mmUpdateNamespaceModelByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceModelByIDParams, len(mmUpdateNamespaceModelByID.callArgs))
	copy(argCopy, mmUpdateNamespaceModelByID.callArgs)

	mmUpdateNamespaceModelByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceModelByIDDone returns true if the count of the UpdateNamespaceModelByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceModelByIDDone() bool {
	if m.UpdateNamespaceModelByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceModelByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceModelByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceModelByIDInspect() {
	for _, e := range m.UpdateNamespaceModelByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceModelByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceModelByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceModelByIDMock.defaultExpectation != nil && afterUpdateNamespaceModelByIDCounter < 1 {
		if m.UpdateNamespaceModelByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID at\n%s", m.UpdateNamespaceModelByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID at\n%s with params: %#v", m.UpdateNamespaceModelByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceModelByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceModelByID != nil && afterUpdateNamespaceModelByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelByID at\n%s", m.funcUpdateNamespaceModelByIDOrigin)
	}

	if !m.UpdateNamespaceModelByIDMock.invocationsDone() && afterUpdateNamespaceModelByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceModelByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceModelByIDMock.expectedInvocations), m.UpdateNamespaceModelByIDMock.expectedInvocationsOrigin, afterUpdateNamespaceModelByIDCounter)
	}
}

type mRepositoryMockUpdateNamespaceModelIDByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateNamespaceModelIDByIDExpectation
	expectations       []*RepositoryMockUpdateNamespaceModelIDByIDExpectation

	callArgs []*RepositoryMockUpdateNamespaceModelIDByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateNamespaceModelIDByIDExpectation specifies expectation struct of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateNamespaceModelIDByIDParams
	paramPtrs          *RepositoryMockUpdateNamespaceModelIDByIDParamPtrs
	expectationOrigins RepositoryMockUpdateNamespaceModelIDByIDExpectationOrigins
	results            *RepositoryMockUpdateNamespaceModelIDByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateNamespaceModelIDByIDParams contains parameters of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDParams struct {
	ctx            context.Context
	ownerPermalink string
	id             string
	newID          string
}

// RepositoryMockUpdateNamespaceModelIDByIDParamPtrs contains pointers to parameters of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDParamPtrs struct {
	ctx            *context.Context
	ownerPermalink *string
	id             *string
	newID          *string
}

// RepositoryMockUpdateNamespaceModelIDByIDResults contains results of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDResults struct {
	err error
}

// RepositoryMockUpdateNamespaceModelIDByIDOrigins contains origins of expectations of the Repository.UpdateNamespaceModelIDByID
type RepositoryMockUpdateNamespaceModelIDByIDExpectationOrigins struct {
	origin               string
	originCtx            string
	originOwnerPermalink string
	originId             string
	originNewID          string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Optional() *mRepositoryMockUpdateNamespaceModelIDByID {
	mmUpdateNamespaceModelIDByID.optional = true
	return mmUpdateNamespaceModelIDByID
}

// Expect sets up expected params for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Expect(ctx context.Context, ownerPermalink string, id string, newID string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by ExpectParams functions")
	}

	mmUpdateNamespaceModelIDByID.defaultExpectation.params = &RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}
	mmUpdateNamespaceModelIDByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateNamespaceModelIDByID.expectations {
		if minimock.Equal(e.params, mmUpdateNamespaceModelIDByID.defaultExpectation.params) {
			mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateNamespaceModelIDByID.defaultExpectation.params)
		}
	}

	return mmUpdateNamespaceModelIDByID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateNamespaceModelIDByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelIDByID
}

// ExpectOwnerPermalinkParam2 sets up expected param ownerPermalink for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectOwnerPermalinkParam2(ownerPermalink string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.ownerPermalink = &ownerPermalink
	mmUpdateNamespaceModelIDByID.defaultExpectation.expectationOrigins.originOwnerPermalink = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelIDByID
}

// ExpectIdParam3 sets up expected param id for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectIdParam3(id string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.id = &id
	mmUpdateNamespaceModelIDByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelIDByID
}

// ExpectNewIDParam4 sets up expected param newID for Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) ExpectNewIDParam4(newID string) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{}
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.params != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Expect")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs = &RepositoryMockUpdateNamespaceModelIDByIDParamPtrs{}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.paramPtrs.newID = &newID
	mmUpdateNamespaceModelIDByID.defaultExpectation.expectationOrigins.originNewID = minimock.CallerInfo(1)

	return mmUpdateNamespaceModelIDByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Inspect(f func(ctx context.Context, ownerPermalink string, id string, newID string)) *mRepositoryMockUpdateNamespaceModelIDByID {
	if mmUpdateNamespaceModelIDByID.mock.inspectFuncUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateNamespaceModelIDByID")
	}

	mmUpdateNamespaceModelIDByID.mock.inspectFuncUpdateNamespaceModelIDByID = f

	return mmUpdateNamespaceModelIDByID
}

// Return sets up results that will be returned by Repository.UpdateNamespaceModelIDByID
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Return(err error) *RepositoryMock {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	if mmUpdateNamespaceModelIDByID.defaultExpectation == nil {
		mmUpdateNamespaceModelIDByID.defaultExpectation = &RepositoryMockUpdateNamespaceModelIDByIDExpectation{mock: mmUpdateNamespaceModelIDByID.mock}
	}
	mmUpdateNamespaceModelIDByID.defaultExpectation.results = &RepositoryMockUpdateNamespaceModelIDByIDResults{err}
	mmUpdateNamespaceModelIDByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelIDByID.mock
}

// Set uses given function f to mock the Repository.UpdateNamespaceModelIDByID method
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Set(f func(ctx context.Context, ownerPermalink string, id string, newID string) (err error)) *RepositoryMock {
	if mmUpdateNamespaceModelIDByID.defaultExpectation != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateNamespaceModelIDByID method")
	}

	if len(mmUpdateNamespaceModelIDByID.expectations) > 0 {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateNamespaceModelIDByID method")
	}

	mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID = f
	mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByIDOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelIDByID.mock
}

// When sets expectation for the Repository.UpdateNamespaceModelIDByID which will trigger the result defined by the following
// Then helper
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) When(ctx context.Context, ownerPermalink string, id string, newID string) *RepositoryMockUpdateNamespaceModelIDByIDExpectation {
	if mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("RepositoryMock.UpdateNamespaceModelIDByID mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateNamespaceModelIDByIDExpectation{
		mock:               mmUpdateNamespaceModelIDByID.mock,
		params:             &RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID},
		expectationOrigins: RepositoryMockUpdateNamespaceModelIDByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateNamespaceModelIDByID.expectations = append(mmUpdateNamespaceModelIDByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateNamespaceModelIDByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateNamespaceModelIDByIDExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateNamespaceModelIDByIDResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateNamespaceModelIDByID should be invoked
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Times(n uint64) *mRepositoryMockUpdateNamespaceModelIDByID {
	if n == 0 {
		mmUpdateNamespaceModelIDByID.mock.t.Fatalf("Times of RepositoryMock.UpdateNamespaceModelIDByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateNamespaceModelIDByID.expectedInvocations, n)
	mmUpdateNamespaceModelIDByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateNamespaceModelIDByID
}

func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) invocationsDone() bool {
	if len(mmUpdateNamespaceModelIDByID.expectations) == 0 && mmUpdateNamespaceModelIDByID.defaultExpectation == nil && mmUpdateNamespaceModelIDByID.mock.funcUpdateNamespaceModelIDByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.mock.afterUpdateNamespaceModelIDByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateNamespaceModelIDByID implements mm_repository.Repository
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByID(ctx context.Context, ownerPermalink string, id string, newID string) (err error) {
	mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.beforeUpdateNamespaceModelIDByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.afterUpdateNamespaceModelIDByIDCounter, 1)

	mmUpdateNamespaceModelIDByID.t.Helper()

	if mmUpdateNamespaceModelIDByID.inspectFuncUpdateNamespaceModelIDByID != nil {
		mmUpdateNamespaceModelIDByID.inspectFuncUpdateNamespaceModelIDByID(ctx, ownerPermalink, id, newID)
	}

	mm_params := RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}

	// Record call args
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.mutex.Lock()
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.callArgs = append(mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.callArgs, &mm_params)
	mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.mutex.Unlock()

	for _, e := range mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateNamespaceModelIDByIDParams{ctx, ownerPermalink, id, newID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ownerPermalink != nil && !minimock.Equal(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter ownerPermalink, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.originOwnerPermalink, *mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink, minimock.Diff(*mm_want_ptrs.ownerPermalink, mm_got.ownerPermalink))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.newID != nil && !minimock.Equal(*mm_want_ptrs.newID, mm_got.newID) {
				mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameter newID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.originNewID, *mm_want_ptrs.newID, mm_got.newID, minimock.Diff(*mm_want_ptrs.newID, mm_got.newID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateNamespaceModelIDByID.t.Errorf("RepositoryMock.UpdateNamespaceModelIDByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateNamespaceModelIDByID.UpdateNamespaceModelIDByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateNamespaceModelIDByID.t.Fatal("No results are set for the RepositoryMock.UpdateNamespaceModelIDByID")
		}
		return (*mm_results).err
	}
	if mmUpdateNamespaceModelIDByID.funcUpdateNamespaceModelIDByID != nil {
		return mmUpdateNamespaceModelIDByID.funcUpdateNamespaceModelIDByID(ctx, ownerPermalink, id, newID)
	}
	mmUpdateNamespaceModelIDByID.t.Fatalf("Unexpected call to RepositoryMock.UpdateNamespaceModelIDByID. %v %v %v %v", ctx, ownerPermalink, id, newID)
	return
}

// UpdateNamespaceModelIDByIDAfterCounter returns a count of finished RepositoryMock.UpdateNamespaceModelIDByID invocations
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.afterUpdateNamespaceModelIDByIDCounter)
}

// UpdateNamespaceModelIDByIDBeforeCounter returns a count of RepositoryMock.UpdateNamespaceModelIDByID invocations
func (mmUpdateNamespaceModelIDByID *RepositoryMock) UpdateNamespaceModelIDByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateNamespaceModelIDByID.beforeUpdateNamespaceModelIDByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateNamespaceModelIDByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateNamespaceModelIDByID *mRepositoryMockUpdateNamespaceModelIDByID) Calls() []*RepositoryMockUpdateNamespaceModelIDByIDParams {
	mmUpdateNamespaceModelIDByID.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateNamespaceModelIDByIDParams, len(mmUpdateNamespaceModelIDByID.callArgs))
	copy(argCopy, mmUpdateNamespaceModelIDByID.callArgs)

	mmUpdateNamespaceModelIDByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateNamespaceModelIDByIDDone returns true if the count of the UpdateNamespaceModelIDByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateNamespaceModelIDByIDDone() bool {
	if m.UpdateNamespaceModelIDByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateNamespaceModelIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateNamespaceModelIDByIDMock.invocationsDone()
}

// MinimockUpdateNamespaceModelIDByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateNamespaceModelIDByIDInspect() {
	for _, e := range m.UpdateNamespaceModelIDByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateNamespaceModelIDByIDCounter := mm_atomic.LoadUint64(&m.afterUpdateNamespaceModelIDByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateNamespaceModelIDByIDMock.defaultExpectation != nil && afterUpdateNamespaceModelIDByIDCounter < 1 {
		if m.UpdateNamespaceModelIDByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID at\n%s", m.UpdateNamespaceModelIDByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID at\n%s with params: %#v", m.UpdateNamespaceModelIDByIDMock.defaultExpectation.expectationOrigins.origin, *m.UpdateNamespaceModelIDByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateNamespaceModelIDByID != nil && afterUpdateNamespaceModelIDByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateNamespaceModelIDByID at\n%s", m.funcUpdateNamespaceModelIDByIDOrigin)
	}

	if !m.UpdateNamespaceModelIDByIDMock.invocationsDone() && afterUpdateNamespaceModelIDByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateNamespaceModelIDByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateNamespaceModelIDByIDMock.expectedInvocations), m.UpdateNamespaceModelIDByIDMock.expectedInvocationsOrigin, afterUpdateNamespaceModelIDByIDCounter)
	}
}

type mRepositoryMockUpsertRepositoryTag struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpsertRepositoryTagExpectation
	expectations       []*RepositoryMockUpsertRepositoryTagExpectation

	callArgs []*RepositoryMockUpsertRepositoryTagParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpsertRepositoryTagExpectation specifies expectation struct of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpsertRepositoryTagParams
	paramPtrs          *RepositoryMockUpsertRepositoryTagParamPtrs
	expectationOrigins RepositoryMockUpsertRepositoryTagExpectationOrigins
	results            *RepositoryMockUpsertRepositoryTagResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpsertRepositoryTagParams contains parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParams struct {
	ctx context.Context
	tag *datamodel.Tag
}

// RepositoryMockUpsertRepositoryTagParamPtrs contains pointers to parameters of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagParamPtrs struct {
	ctx *context.Context
	tag **datamodel.Tag
}

// RepositoryMockUpsertRepositoryTagResults contains results of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagResults struct {
	tp1 *datamodel.Tag
	err error
}

// RepositoryMockUpsertRepositoryTagOrigins contains origins of expectations of the Repository.UpsertRepositoryTag
type RepositoryMockUpsertRepositoryTagExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Optional() *mRepositoryMockUpsertRepositoryTag {
	mmUpsertRepositoryTag.optional = true
	return mmUpsertRepositoryTag
}

// Expect sets up expected params for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Expect(ctx context.Context, tag *datamodel.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by ExpectParams functions")
	}

	mmUpsertRepositoryTag.defaultExpectation.params = &RepositoryMockUpsertRepositoryTagParams{ctx, tag}
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpsertRepositoryTag.expectations {
		if minimock.Equal(e.params, mmUpsertRepositoryTag.defaultExpectation.params) {
			mmUpsertRepositoryTag.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpsertRepositoryTag.defaultExpectation.params)
		}
	}

	return mmUpsertRepositoryTag
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// ExpectTagParam2 sets up expected param tag for Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) ExpectTagParam2(tag *datamodel.Tag) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{}
	}

	if mmUpsertRepositoryTag.defaultExpectation.params != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Expect")
	}

	if mmUpsertRepositoryTag.defaultExpectation.paramPtrs == nil {
		mmUpsertRepositoryTag.defaultExpectation.paramPtrs = &RepositoryMockUpsertRepositoryTagParamPtrs{}
	}
	mmUpsertRepositoryTag.defaultExpectation.paramPtrs.tag = &tag
	mmUpsertRepositoryTag.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmUpsertRepositoryTag
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Inspect(f func(ctx context.Context, tag *datamodel.Tag)) *mRepositoryMockUpsertRepositoryTag {
	if mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpsertRepositoryTag")
	}

	mmUpsertRepositoryTag.mock.inspectFuncUpsertRepositoryTag = f

	return mmUpsertRepositoryTag
}

// Return sets up results that will be returned by Repository.UpsertRepositoryTag
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Return(tp1 *datamodel.Tag, err error) *RepositoryMock {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	if mmUpsertRepositoryTag.defaultExpectation == nil {
		mmUpsertRepositoryTag.defaultExpectation = &RepositoryMockUpsertRepositoryTagExpectation{mock: mmUpsertRepositoryTag.mock}
	}
	mmUpsertRepositoryTag.defaultExpectation.results = &RepositoryMockUpsertRepositoryTagResults{tp1, err}
	mmUpsertRepositoryTag.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// Set uses given function f to mock the Repository.UpsertRepositoryTag method
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Set(f func(ctx context.Context, tag *datamodel.Tag) (tp1 *datamodel.Tag, err error)) *RepositoryMock {
	if mmUpsertRepositoryTag.defaultExpectation != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("Default expectation is already set for the Repository.UpsertRepositoryTag method")
	}

	if len(mmUpsertRepositoryTag.expectations) > 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Some expectations are already set for the Repository.UpsertRepositoryTag method")
	}

	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag = f
	mmUpsertRepositoryTag.mock.funcUpsertRepositoryTagOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag.mock
}

// When sets expectation for the Repository.UpsertRepositoryTag which will trigger the result defined by the following
// Then helper
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) When(ctx context.Context, tag *datamodel.Tag) *RepositoryMockUpsertRepositoryTagExpectation {
	if mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.mock.t.Fatalf("RepositoryMock.UpsertRepositoryTag mock is already set by Set")
	}

	expectation := &RepositoryMockUpsertRepositoryTagExpectation{
		mock:               mmUpsertRepositoryTag.mock,
		params:             &RepositoryMockUpsertRepositoryTagParams{ctx, tag},
		expectationOrigins: RepositoryMockUpsertRepositoryTagExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpsertRepositoryTag.expectations = append(mmUpsertRepositoryTag.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpsertRepositoryTag return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpsertRepositoryTagExpectation) Then(tp1 *datamodel.Tag, err error) *RepositoryMock {
	e.results = &RepositoryMockUpsertRepositoryTagResults{tp1, err}
	return e.mock
}

// Times sets number of times Repository.UpsertRepositoryTag should be invoked
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Times(n uint64) *mRepositoryMockUpsertRepositoryTag {
	if n == 0 {
		mmUpsertRepositoryTag.mock.t.Fatalf("Times of RepositoryMock.UpsertRepositoryTag mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpsertRepositoryTag.expectedInvocations, n)
	mmUpsertRepositoryTag.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpsertRepositoryTag
}

func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) invocationsDone() bool {
	if len(mmUpsertRepositoryTag.expectations) == 0 && mmUpsertRepositoryTag.defaultExpectation == nil && mmUpsertRepositoryTag.mock.funcUpsertRepositoryTag == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.mock.afterUpsertRepositoryTagCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpsertRepositoryTag.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpsertRepositoryTag implements mm_repository.Repository
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTag(ctx context.Context, tag *datamodel.Tag) (tp1 *datamodel.Tag, err error) {
	mm_atomic.AddUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter, 1)
	defer mm_atomic.AddUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter, 1)

	mmUpsertRepositoryTag.t.Helper()

	if mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag != nil {
		mmUpsertRepositoryTag.inspectFuncUpsertRepositoryTag(ctx, tag)
	}

	mm_params := RepositoryMockUpsertRepositoryTagParams{ctx, tag}

	// Record call args
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Lock()
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs = append(mmUpsertRepositoryTag.UpsertRepositoryTagMock.callArgs, &mm_params)
	mmUpsertRepositoryTag.UpsertRepositoryTagMock.mutex.Unlock()

	for _, e := range mmUpsertRepositoryTag.UpsertRepositoryTagMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.tp1, e.results.err
		}
	}

	if mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.Counter, 1)
		mm_want := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.params
		mm_want_ptrs := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpsertRepositoryTagParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpsertRepositoryTag.t.Errorf("RepositoryMock.UpsertRepositoryTag got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpsertRepositoryTag.UpsertRepositoryTagMock.defaultExpectation.results
		if mm_results == nil {
			mmUpsertRepositoryTag.t.Fatal("No results are set for the RepositoryMock.UpsertRepositoryTag")
		}
		return (*mm_results).tp1, (*mm_results).err
	}
	if mmUpsertRepositoryTag.funcUpsertRepositoryTag != nil {
		return mmUpsertRepositoryTag.funcUpsertRepositoryTag(ctx, tag)
	}
	mmUpsertRepositoryTag.t.Fatalf("Unexpected call to RepositoryMock.UpsertRepositoryTag. %v %v", ctx, tag)
	return
}

// UpsertRepositoryTagAfterCounter returns a count of finished RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.afterUpsertRepositoryTagCounter)
}

// UpsertRepositoryTagBeforeCounter returns a count of RepositoryMock.UpsertRepositoryTag invocations
func (mmUpsertRepositoryTag *RepositoryMock) UpsertRepositoryTagBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpsertRepositoryTag.beforeUpsertRepositoryTagCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpsertRepositoryTag.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpsertRepositoryTag *mRepositoryMockUpsertRepositoryTag) Calls() []*RepositoryMockUpsertRepositoryTagParams {
	mmUpsertRepositoryTag.mutex.RLock()

	argCopy := make([]*RepositoryMockUpsertRepositoryTagParams, len(mmUpsertRepositoryTag.callArgs))
	copy(argCopy, mmUpsertRepositoryTag.callArgs)

	mmUpsertRepositoryTag.mutex.RUnlock()

	return argCopy
}

// MinimockUpsertRepositoryTagDone returns true if the count of the UpsertRepositoryTag invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpsertRepositoryTagDone() bool {
	if m.UpsertRepositoryTagMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpsertRepositoryTagMock.invocationsDone()
}

// MinimockUpsertRepositoryTagInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpsertRepositoryTagInspect() {
	for _, e := range m.UpsertRepositoryTagMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpsertRepositoryTagCounter := mm_atomic.LoadUint64(&m.afterUpsertRepositoryTagCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpsertRepositoryTagMock.defaultExpectation != nil && afterUpsertRepositoryTagCounter < 1 {
		if m.UpsertRepositoryTagMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.UpsertRepositoryTagMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s with params: %#v", m.UpsertRepositoryTagMock.defaultExpectation.expectationOrigins.origin, *m.UpsertRepositoryTagMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpsertRepositoryTag != nil && afterUpsertRepositoryTagCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpsertRepositoryTag at\n%s", m.funcUpsertRepositoryTagOrigin)
	}

	if !m.UpsertRepositoryTagMock.invocationsDone() && afterUpsertRepositoryTagCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpsertRepositoryTag at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpsertRepositoryTagMock.expectedInvocations), m.UpsertRepositoryTagMock.expectedInvocationsOrigin, afterUpsertRepositoryTagCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPinnedUserInspect()

			m.MinimockCreateModelRunInspect()

			m.MinimockCreateModelTagsInspect()

			m.MinimockCreateModelVersionInspect()

			m.MinimockCreateNamespaceModelInspect()

			m.MinimockDeleteModelTagsInspect()

			m.MinimockDeleteModelVersionByDigestInspect()

			m.MinimockDeleteModelVersionByIDInspect()

			m.MinimockDeleteNamespaceModelByIDInspect()

			m.MinimockDeleteRepositoryTagInspect()

			m.MinimockGetLatestModelRunByModelUIDInspect()

			m.MinimockGetLatestModelVersionByModelUIDInspect()

			m.MinimockGetLatestModelVersionRunByModelUIDInspect()

			m.MinimockGetModelByUIDInspect()

			m.MinimockGetModelByUIDAdminInspect()

			m.MinimockGetModelDefinitionInspect()

			m.MinimockGetModelDefinitionByUIDInspect()

			m.MinimockGetModelRunByUIDInspect()

			m.MinimockGetModelVersionByIDInspect()

			m.MinimockGetNamespaceModelByIDInspect()

			m.MinimockGetRepositoryTagInspect()

			m.MinimockListModelDefinitionsInspect()

			m.MinimockListModelRunsInspect()

			m.MinimockListModelRunsByRequesterInspect()

			m.MinimockListModelTagsInspect()

			m.MinimockListModelVersionsInspect()

			m.MinimockListModelVersionsByDigestInspect()

			m.MinimockListModelsInspect()

			m.MinimockListModelsAdminInspect()

			m.MinimockListNamespaceModelsInspect()

			m.MinimockPinUserInspect()

			m.MinimockUpdateModelRunInspect()

			m.MinimockUpdateModelVersionDigestByIDInspect()

			m.MinimockUpdateNamespaceModelByIDInspect()

			m.MinimockUpdateNamespaceModelIDByIDInspect()

			m.MinimockUpsertRepositoryTagInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPinnedUserDone() &&
		m.MinimockCreateModelRunDone() &&
		m.MinimockCreateModelTagsDone() &&
		m.MinimockCreateModelVersionDone() &&
		m.MinimockCreateNamespaceModelDone() &&
		m.MinimockDeleteModelTagsDone() &&
		m.MinimockDeleteModelVersionByDigestDone() &&
		m.MinimockDeleteModelVersionByIDDone() &&
		m.MinimockDeleteNamespaceModelByIDDone() &&
		m.MinimockDeleteRepositoryTagDone() &&
		m.MinimockGetLatestModelRunByModelUIDDone() &&
		m.MinimockGetLatestModelVersionByModelUIDDone() &&
		m.MinimockGetLatestModelVersionRunByModelUIDDone() &&
		m.MinimockGetModelByUIDDone() &&
		m.MinimockGetModelByUIDAdminDone() &&
		m.MinimockGetModelDefinitionDone() &&
		m.MinimockGetModelDefinitionByUIDDone() &&
		m.MinimockGetModelRunByUIDDone() &&
		m.MinimockGetModelVersionByIDDone() &&
		m.MinimockGetNamespaceModelByIDDone() &&
		m.MinimockGetRepositoryTagDone() &&
		m.MinimockListModelDefinitionsDone() &&
		m.MinimockListModelRunsDone() &&
		m.MinimockListModelRunsByRequesterDone() &&
		m.MinimockListModelTagsDone() &&
		m.MinimockListModelVersionsDone() &&
		m.MinimockListModelVersionsByDigestDone() &&
		m.MinimockListModelsDone() &&
		m.MinimockListModelsAdminDone() &&
		m.MinimockListNamespaceModelsDone() &&
		m.MinimockPinUserDone() &&
		m.MinimockUpdateModelRunDone() &&
		m.MinimockUpdateModelVersionDigestByIDDone() &&
		m.MinimockUpdateNamespaceModelByIDDone() &&
		m.MinimockUpdateNamespaceModelIDByIDDone() &&
		m.MinimockUpsertRepositoryTagDone()
}
