// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
	"github.com/instill-ai/x/openfga"
	openfgax "github.com/instill-ai/x/openfga"
	openfgaclient "github.com/openfga/go-sdk/client"
)

// ACLClientInterfaceMock implements mm_acl.ACLClientInterface
type ACLClientInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPermission          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error)
	funcCheckPermissionOrigin    string
	inspectFuncCheckPermission   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string)
	afterCheckPermissionCounter  uint64
	beforeCheckPermissionCounter uint64
	CheckPermissionMock          mACLClientInterfaceMockCheckPermission

	funcCheckPermissionByUser          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error)
	funcCheckPermissionByUserOrigin    string
	inspectFuncCheckPermissionByUser   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string)
	afterCheckPermissionByUserCounter  uint64
	beforeCheckPermissionByUserCounter uint64
	CheckPermissionByUserMock          mACLClientInterfaceMockCheckPermissionByUser

	funcCheckPublicExecutable          func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error)
	funcCheckPublicExecutableOrigin    string
	inspectFuncCheckPublicExecutable   func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID)
	afterCheckPublicExecutableCounter  uint64
	beforeCheckPublicExecutableCounter uint64
	CheckPublicExecutableMock          mACLClientInterfaceMockCheckPublicExecutable

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mACLClientInterfaceMockClose

	funcDeleteModelPermission          func(ctx context.Context, modelUID uuid.UUID, user string) (err error)
	funcDeleteModelPermissionOrigin    string
	inspectFuncDeleteModelPermission   func(ctx context.Context, modelUID uuid.UUID, user string)
	afterDeleteModelPermissionCounter  uint64
	beforeDeleteModelPermissionCounter uint64
	DeleteModelPermissionMock          mACLClientInterfaceMockDeleteModelPermission

	funcDeletePublicModelPermission          func(ctx context.Context, modelUID uuid.UUID) (err error)
	funcDeletePublicModelPermissionOrigin    string
	inspectFuncDeletePublicModelPermission   func(ctx context.Context, modelUID uuid.UUID)
	afterDeletePublicModelPermissionCounter  uint64
	beforeDeletePublicModelPermissionCounter uint64
	DeletePublicModelPermissionMock          mACLClientInterfaceMockDeletePublicModelPermission

	funcGetAuthorizationModelID          func() (s1 string)
	funcGetAuthorizationModelIDOrigin    string
	inspectFuncGetAuthorizationModelID   func()
	afterGetAuthorizationModelIDCounter  uint64
	beforeGetAuthorizationModelIDCounter uint64
	GetAuthorizationModelIDMock          mACLClientInterfaceMockGetAuthorizationModelID

	funcGetStoreID          func() (s1 string)
	funcGetStoreIDOrigin    string
	inspectFuncGetStoreID   func()
	afterGetStoreIDCounter  uint64
	beforeGetStoreIDCounter uint64
	GetStoreIDMock          mACLClientInterfaceMockGetStoreID

	funcListPermissions          func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error)
	funcListPermissionsOrigin    string
	inspectFuncListPermissions   func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool)
	afterListPermissionsCounter  uint64
	beforeListPermissionsCounter uint64
	ListPermissionsMock          mACLClientInterfaceMockListPermissions

	funcPurge          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error)
	funcPurgeOrigin    string
	inspectFuncPurge   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID)
	afterPurgeCounter  uint64
	beforePurgeCounter uint64
	PurgeMock          mACLClientInterfaceMockPurge

	funcSDKClient          func() (op1 *openfgaclient.OpenFgaClient)
	funcSDKClientOrigin    string
	inspectFuncSDKClient   func()
	afterSDKClientCounter  uint64
	beforeSDKClientCounter uint64
	SDKClientMock          mACLClientInterfaceMockSDKClient

	funcSetAuthorizationModelID          func(modelID string) (err error)
	funcSetAuthorizationModelIDOrigin    string
	inspectFuncSetAuthorizationModelID   func(modelID string)
	afterSetAuthorizationModelIDCounter  uint64
	beforeSetAuthorizationModelIDCounter uint64
	SetAuthorizationModelIDMock          mACLClientInterfaceMockSetAuthorizationModelID

	funcSetModelPermission          func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error)
	funcSetModelPermissionOrigin    string
	inspectFuncSetModelPermission   func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool)
	afterSetModelPermissionCounter  uint64
	beforeSetModelPermissionCounter uint64
	SetModelPermissionMock          mACLClientInterfaceMockSetModelPermission

	funcSetOwner          func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error)
	funcSetOwnerOrigin    string
	inspectFuncSetOwner   func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID)
	afterSetOwnerCounter  uint64
	beforeSetOwnerCounter uint64
	SetOwnerMock          mACLClientInterfaceMockSetOwner

	funcSetPublicModelPermission          func(ctx context.Context, modelUID uuid.UUID) (err error)
	funcSetPublicModelPermissionOrigin    string
	inspectFuncSetPublicModelPermission   func(ctx context.Context, modelUID uuid.UUID)
	afterSetPublicModelPermissionCounter  uint64
	beforeSetPublicModelPermissionCounter uint64
	SetPublicModelPermissionMock          mACLClientInterfaceMockSetPublicModelPermission

	funcSetStoreID          func(storeID string) (err error)
	funcSetStoreIDOrigin    string
	inspectFuncSetStoreID   func(storeID string)
	afterSetStoreIDCounter  uint64
	beforeSetStoreIDCounter uint64
	SetStoreIDMock          mACLClientInterfaceMockSetStoreID
}

// NewACLClientInterfaceMock returns a mock for mm_acl.ACLClientInterface
func NewACLClientInterfaceMock(t minimock.Tester) *ACLClientInterfaceMock {
	m := &ACLClientInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPermissionMock = mACLClientInterfaceMockCheckPermission{mock: m}
	m.CheckPermissionMock.callArgs = []*ACLClientInterfaceMockCheckPermissionParams{}

	m.CheckPermissionByUserMock = mACLClientInterfaceMockCheckPermissionByUser{mock: m}
	m.CheckPermissionByUserMock.callArgs = []*ACLClientInterfaceMockCheckPermissionByUserParams{}

	m.CheckPublicExecutableMock = mACLClientInterfaceMockCheckPublicExecutable{mock: m}
	m.CheckPublicExecutableMock.callArgs = []*ACLClientInterfaceMockCheckPublicExecutableParams{}

	m.CloseMock = mACLClientInterfaceMockClose{mock: m}

	m.DeleteModelPermissionMock = mACLClientInterfaceMockDeleteModelPermission{mock: m}
	m.DeleteModelPermissionMock.callArgs = []*ACLClientInterfaceMockDeleteModelPermissionParams{}

	m.DeletePublicModelPermissionMock = mACLClientInterfaceMockDeletePublicModelPermission{mock: m}
	m.DeletePublicModelPermissionMock.callArgs = []*ACLClientInterfaceMockDeletePublicModelPermissionParams{}

	m.GetAuthorizationModelIDMock = mACLClientInterfaceMockGetAuthorizationModelID{mock: m}

	m.GetStoreIDMock = mACLClientInterfaceMockGetStoreID{mock: m}

	m.ListPermissionsMock = mACLClientInterfaceMockListPermissions{mock: m}
	m.ListPermissionsMock.callArgs = []*ACLClientInterfaceMockListPermissionsParams{}

	m.PurgeMock = mACLClientInterfaceMockPurge{mock: m}
	m.PurgeMock.callArgs = []*ACLClientInterfaceMockPurgeParams{}

	m.SDKClientMock = mACLClientInterfaceMockSDKClient{mock: m}

	m.SetAuthorizationModelIDMock = mACLClientInterfaceMockSetAuthorizationModelID{mock: m}
	m.SetAuthorizationModelIDMock.callArgs = []*ACLClientInterfaceMockSetAuthorizationModelIDParams{}

	m.SetModelPermissionMock = mACLClientInterfaceMockSetModelPermission{mock: m}
	m.SetModelPermissionMock.callArgs = []*ACLClientInterfaceMockSetModelPermissionParams{}

	m.SetOwnerMock = mACLClientInterfaceMockSetOwner{mock: m}
	m.SetOwnerMock.callArgs = []*ACLClientInterfaceMockSetOwnerParams{}

	m.SetPublicModelPermissionMock = mACLClientInterfaceMockSetPublicModelPermission{mock: m}
	m.SetPublicModelPermissionMock.callArgs = []*ACLClientInterfaceMockSetPublicModelPermissionParams{}

	m.SetStoreIDMock = mACLClientInterfaceMockSetStoreID{mock: m}
	m.SetStoreIDMock.callArgs = []*ACLClientInterfaceMockSetStoreIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mACLClientInterfaceMockCheckPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPermissionParams
	paramPtrs          *ACLClientInterfaceMockCheckPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPermissionExpectationOrigins
	results            *ACLClientInterfaceMockCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPermissionParams contains parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckPermissionResults contains results of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPermissionOrigins contains origins of expectations of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Optional() *mACLClientInterfaceMockCheckPermission {
	mmCheckPermission.optional = true
	return mmCheckPermission
}

// Expect sets up expected params for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.paramPtrs != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by ExpectParams functions")
	}

	mmCheckPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}
	mmCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermission.expectations {
		if minimock.Equal(e.params, mmCheckPermission.defaultExpectation.params) {
			mmCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermission.defaultExpectation.params)
		}
	}

	return mmCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.inspectFuncCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPermission")
	}

	mmCheckPermission.mock.inspectFuncCheckPermission = f

	return mmCheckPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{mock: mmCheckPermission.mock}
	}
	mmCheckPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	mmCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPermission method
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPermission.defaultExpectation != nil {
		mmCheckPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPermission method")
	}

	if len(mmCheckPermission.expectations) > 0 {
		mmCheckPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPermission method")
	}

	mmCheckPermission.mock.funcCheckPermission = f
	mmCheckPermission.mock.funcCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckPermission which will trigger the result defined by the following
// Then helper
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckPermissionExpectation {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPermissionExpectation{
		mock:               mmCheckPermission.mock,
		params:             &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role},
		expectationOrigins: ACLClientInterfaceMockCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermission.expectations = append(mmCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPermission should be invoked
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Times(n uint64) *mACLClientInterfaceMockCheckPermission {
	if n == 0 {
		mmCheckPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermission.expectedInvocations, n)
	mmCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermission
}

func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) invocationsDone() bool {
	if len(mmCheckPermission.expectations) == 0 && mmCheckPermission.defaultExpectation == nil && mmCheckPermission.mock.funcCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermission.mock.afterCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermission implements mm_acl.ACLClientInterface
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermission(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermission.beforeCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermission.afterCheckPermissionCounter, 1)

	mmCheckPermission.t.Helper()

	if mmCheckPermission.inspectFuncCheckPermission != nil {
		mmCheckPermission.inspectFuncCheckPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckPermission.CheckPermissionMock.mutex.Lock()
	mmCheckPermission.CheckPermissionMock.callArgs = append(mmCheckPermission.CheckPermissionMock.callArgs, &mm_params)
	mmCheckPermission.CheckPermissionMock.mutex.Unlock()

	for _, e := range mmCheckPermission.CheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermission.CheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermission.CheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermission.CheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermission.CheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermission.CheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermission.funcCheckPermission != nil {
		return mmCheckPermission.funcCheckPermission(ctx, objectType, objectUID, role)
	}
	mmCheckPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.afterCheckPermissionCounter)
}

// CheckPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.beforeCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Calls() []*ACLClientInterfaceMockCheckPermissionParams {
	mmCheckPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPermissionParams, len(mmCheckPermission.callArgs))
	copy(argCopy, mmCheckPermission.callArgs)

	mmCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionDone returns true if the count of the CheckPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPermissionDone() bool {
	if m.CheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionMock.invocationsDone()
}

// MinimockCheckPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPermissionInspect() {
	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionMock.defaultExpectation != nil && afterCheckPermissionCounter < 1 {
		if m.CheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.CheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", m.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermission != nil && afterCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.funcCheckPermissionOrigin)
	}

	if !m.CheckPermissionMock.invocationsDone() && afterCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionMock.expectedInvocations), m.CheckPermissionMock.expectedInvocationsOrigin, afterCheckPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPermissionByUser struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPermissionByUserExpectation
	expectations       []*ACLClientInterfaceMockCheckPermissionByUserExpectation

	callArgs []*ACLClientInterfaceMockCheckPermissionByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPermissionByUserExpectation specifies expectation struct of the ACLClientInterface.CheckPermissionByUser
type ACLClientInterfaceMockCheckPermissionByUserExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPermissionByUserParams
	paramPtrs          *ACLClientInterfaceMockCheckPermissionByUserParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPermissionByUserExpectationOrigins
	results            *ACLClientInterfaceMockCheckPermissionByUserResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPermissionByUserParams contains parameters of the ACLClientInterface.CheckPermissionByUser
type ACLClientInterfaceMockCheckPermissionByUserParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	userType   openfga.UserType
	userUID    string
	role       string
}

// ACLClientInterfaceMockCheckPermissionByUserParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPermissionByUser
type ACLClientInterfaceMockCheckPermissionByUserParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	userType   *openfga.UserType
	userUID    *string
	role       *string
}

// ACLClientInterfaceMockCheckPermissionByUserResults contains results of the ACLClientInterface.CheckPermissionByUser
type ACLClientInterfaceMockCheckPermissionByUserResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPermissionByUserOrigins contains origins of expectations of the ACLClientInterface.CheckPermissionByUser
type ACLClientInterfaceMockCheckPermissionByUserExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originUserType   string
	originUserUID    string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Optional() *mACLClientInterfaceMockCheckPermissionByUser {
	mmCheckPermissionByUser.optional = true
	return mmCheckPermissionByUser
}

// Expect sets up expected params for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by ExpectParams functions")
	}

	mmCheckPermissionByUser.defaultExpectation.params = &ACLClientInterfaceMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermissionByUser.expectations {
		if minimock.Equal(e.params, mmCheckPermissionByUser.defaultExpectation.params) {
			mmCheckPermissionByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermissionByUser.defaultExpectation.params)
		}
	}

	return mmCheckPermissionByUser
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectUserTypeParam4 sets up expected param userType for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectUserTypeParam4(userType openfga.UserType) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.userType = &userType
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originUserType = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectUserUIDParam5 sets up expected param userUID for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectUserUIDParam5(userUID string) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.userUID = &userUID
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originUserUID = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// ExpectRoleParam6 sets up expected param role for ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) ExpectRoleParam6(role string) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{}
	}

	if mmCheckPermissionByUser.defaultExpectation.params != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Expect")
	}

	if mmCheckPermissionByUser.defaultExpectation.paramPtrs == nil {
		mmCheckPermissionByUser.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionByUserParamPtrs{}
	}
	mmCheckPermissionByUser.defaultExpectation.paramPtrs.role = &role
	mmCheckPermissionByUser.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermissionByUser
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string)) *mACLClientInterfaceMockCheckPermissionByUser {
	if mmCheckPermissionByUser.mock.inspectFuncCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPermissionByUser")
	}

	mmCheckPermissionByUser.mock.inspectFuncCheckPermissionByUser = f

	return mmCheckPermissionByUser
}

// Return sets up results that will be returned by ACLClientInterface.CheckPermissionByUser
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	if mmCheckPermissionByUser.defaultExpectation == nil {
		mmCheckPermissionByUser.defaultExpectation = &ACLClientInterfaceMockCheckPermissionByUserExpectation{mock: mmCheckPermissionByUser.mock}
	}
	mmCheckPermissionByUser.defaultExpectation.results = &ACLClientInterfaceMockCheckPermissionByUserResults{b1, err}
	mmCheckPermissionByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPermissionByUser method
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPermissionByUser.defaultExpectation != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPermissionByUser method")
	}

	if len(mmCheckPermissionByUser.expectations) > 0 {
		mmCheckPermissionByUser.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPermissionByUser method")
	}

	mmCheckPermissionByUser.mock.funcCheckPermissionByUser = f
	mmCheckPermissionByUser.mock.funcCheckPermissionByUserOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser.mock
}

// When sets expectation for the ACLClientInterface.CheckPermissionByUser which will trigger the result defined by the following
// Then helper
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) *ACLClientInterfaceMockCheckPermissionByUserExpectation {
	if mmCheckPermissionByUser.mock.funcCheckPermissionByUser != nil {
		mmCheckPermissionByUser.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermissionByUser mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPermissionByUserExpectation{
		mock:               mmCheckPermissionByUser.mock,
		params:             &ACLClientInterfaceMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role},
		expectationOrigins: ACLClientInterfaceMockCheckPermissionByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermissionByUser.expectations = append(mmCheckPermissionByUser.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPermissionByUser return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPermissionByUserExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPermissionByUserResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPermissionByUser should be invoked
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Times(n uint64) *mACLClientInterfaceMockCheckPermissionByUser {
	if n == 0 {
		mmCheckPermissionByUser.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPermissionByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermissionByUser.expectedInvocations, n)
	mmCheckPermissionByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermissionByUser
}

func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) invocationsDone() bool {
	if len(mmCheckPermissionByUser.expectations) == 0 && mmCheckPermissionByUser.defaultExpectation == nil && mmCheckPermissionByUser.mock.funcCheckPermissionByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermissionByUser.mock.afterCheckPermissionByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermissionByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermissionByUser implements mm_acl.ACLClientInterface
func (mmCheckPermissionByUser *ACLClientInterfaceMock) CheckPermissionByUser(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, userType openfga.UserType, userUID string, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermissionByUser.beforeCheckPermissionByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermissionByUser.afterCheckPermissionByUserCounter, 1)

	mmCheckPermissionByUser.t.Helper()

	if mmCheckPermissionByUser.inspectFuncCheckPermissionByUser != nil {
		mmCheckPermissionByUser.inspectFuncCheckPermissionByUser(ctx, objectType, objectUID, userType, userUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}

	// Record call args
	mmCheckPermissionByUser.CheckPermissionByUserMock.mutex.Lock()
	mmCheckPermissionByUser.CheckPermissionByUserMock.callArgs = append(mmCheckPermissionByUser.CheckPermissionByUserMock.callArgs, &mm_params)
	mmCheckPermissionByUser.CheckPermissionByUserMock.mutex.Unlock()

	for _, e := range mmCheckPermissionByUser.CheckPermissionByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPermissionByUserParams{ctx, objectType, objectUID, userType, userUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.userType != nil && !minimock.Equal(*mm_want_ptrs.userType, mm_got.userType) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter userType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originUserType, *mm_want_ptrs.userType, mm_got.userType, minimock.Diff(*mm_want_ptrs.userType, mm_got.userType))
			}

			if mm_want_ptrs.userUID != nil && !minimock.Equal(*mm_want_ptrs.userUID, mm_got.userUID) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter userUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originUserUID, *mm_want_ptrs.userUID, mm_got.userUID, minimock.Diff(*mm_want_ptrs.userUID, mm_got.userUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermissionByUser.t.Errorf("ACLClientInterfaceMock.CheckPermissionByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermissionByUser.CheckPermissionByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermissionByUser.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPermissionByUser")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermissionByUser.funcCheckPermissionByUser != nil {
		return mmCheckPermissionByUser.funcCheckPermissionByUser(ctx, objectType, objectUID, userType, userUID, role)
	}
	mmCheckPermissionByUser.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPermissionByUser. %v %v %v %v %v %v", ctx, objectType, objectUID, userType, userUID, role)
	return
}

// CheckPermissionByUserAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPermissionByUser invocations
func (mmCheckPermissionByUser *ACLClientInterfaceMock) CheckPermissionByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermissionByUser.afterCheckPermissionByUserCounter)
}

// CheckPermissionByUserBeforeCounter returns a count of ACLClientInterfaceMock.CheckPermissionByUser invocations
func (mmCheckPermissionByUser *ACLClientInterfaceMock) CheckPermissionByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermissionByUser.beforeCheckPermissionByUserCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPermissionByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermissionByUser *mACLClientInterfaceMockCheckPermissionByUser) Calls() []*ACLClientInterfaceMockCheckPermissionByUserParams {
	mmCheckPermissionByUser.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPermissionByUserParams, len(mmCheckPermissionByUser.callArgs))
	copy(argCopy, mmCheckPermissionByUser.callArgs)

	mmCheckPermissionByUser.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionByUserDone returns true if the count of the CheckPermissionByUser invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPermissionByUserDone() bool {
	if m.CheckPermissionByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionByUserMock.invocationsDone()
}

// MinimockCheckPermissionByUserInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPermissionByUserInspect() {
	for _, e := range m.CheckPermissionByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermissionByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionByUserCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionByUserMock.defaultExpectation != nil && afterCheckPermissionByUserCounter < 1 {
		if m.CheckPermissionByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermissionByUser at\n%s", m.CheckPermissionByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermissionByUser at\n%s with params: %#v", m.CheckPermissionByUserMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermissionByUser != nil && afterCheckPermissionByUserCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermissionByUser at\n%s", m.funcCheckPermissionByUserOrigin)
	}

	if !m.CheckPermissionByUserMock.invocationsDone() && afterCheckPermissionByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPermissionByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionByUserMock.expectedInvocations), m.CheckPermissionByUserMock.expectedInvocationsOrigin, afterCheckPermissionByUserCounter)
	}
}

type mACLClientInterfaceMockCheckPublicExecutable struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPublicExecutableExpectation
	expectations       []*ACLClientInterfaceMockCheckPublicExecutableExpectation

	callArgs []*ACLClientInterfaceMockCheckPublicExecutableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPublicExecutableExpectation specifies expectation struct of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPublicExecutableParams
	paramPtrs          *ACLClientInterfaceMockCheckPublicExecutableParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins
	results            *ACLClientInterfaceMockCheckPublicExecutableResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPublicExecutableParams contains parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParams struct {
	ctx        context.Context
	objectType openfgax.ObjectType
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParamPtrs struct {
	ctx        *context.Context
	objectType *openfgax.ObjectType
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableResults contains results of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPublicExecutableOrigins contains origins of expectations of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Optional() *mACLClientInterfaceMockCheckPublicExecutable {
	mmCheckPublicExecutable.optional = true
	return mmCheckPublicExecutable
}

// Expect sets up expected params for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Expect(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by ExpectParams functions")
	}

	mmCheckPublicExecutable.defaultExpectation.params = &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPublicExecutable.expectations {
		if minimock.Equal(e.params, mmCheckPublicExecutable.defaultExpectation.params) {
			mmCheckPublicExecutable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPublicExecutable.defaultExpectation.params)
		}
	}

	return mmCheckPublicExecutable
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectTypeParam2(objectType openfgax.ObjectType) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Inspect(f func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID)) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPublicExecutable")
	}

	mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable = f

	return mmCheckPublicExecutable
}

// Return sets up results that will be returned by ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{mock: mmCheckPublicExecutable.mock}
	}
	mmCheckPublicExecutable.defaultExpectation.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	mmCheckPublicExecutable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPublicExecutable method
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Set(f func(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.defaultExpectation != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	if len(mmCheckPublicExecutable.expectations) > 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	mmCheckPublicExecutable.mock.funcCheckPublicExecutable = f
	mmCheckPublicExecutable.mock.funcCheckPublicExecutableOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// When sets expectation for the ACLClientInterface.CheckPublicExecutable which will trigger the result defined by the following
// Then helper
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) When(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) *ACLClientInterfaceMockCheckPublicExecutableExpectation {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPublicExecutableExpectation{
		mock:               mmCheckPublicExecutable.mock,
		params:             &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPublicExecutable.expectations = append(mmCheckPublicExecutable.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPublicExecutable return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPublicExecutableExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPublicExecutable should be invoked
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Times(n uint64) *mACLClientInterfaceMockCheckPublicExecutable {
	if n == 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPublicExecutable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPublicExecutable.expectedInvocations, n)
	mmCheckPublicExecutable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable
}

func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) invocationsDone() bool {
	if len(mmCheckPublicExecutable.expectations) == 0 && mmCheckPublicExecutable.defaultExpectation == nil && mmCheckPublicExecutable.mock.funcCheckPublicExecutable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.mock.afterCheckPublicExecutableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPublicExecutable implements mm_acl.ACLClientInterface
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutable(ctx context.Context, objectType openfgax.ObjectType, objectUID uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter, 1)

	mmCheckPublicExecutable.t.Helper()

	if mmCheckPublicExecutable.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.inspectFuncCheckPublicExecutable(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

	// Record call args
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Lock()
	mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs = append(mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs, &mm_params)
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Unlock()

	for _, e := range mmCheckPublicExecutable.CheckPublicExecutableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPublicExecutable.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPublicExecutable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPublicExecutable.funcCheckPublicExecutable != nil {
		return mmCheckPublicExecutable.funcCheckPublicExecutable(ctx, objectType, objectUID)
	}
	mmCheckPublicExecutable.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPublicExecutable. %v %v %v", ctx, objectType, objectUID)
	return
}

// CheckPublicExecutableAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter)
}

// CheckPublicExecutableBeforeCounter returns a count of ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPublicExecutable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Calls() []*ACLClientInterfaceMockCheckPublicExecutableParams {
	mmCheckPublicExecutable.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPublicExecutableParams, len(mmCheckPublicExecutable.callArgs))
	copy(argCopy, mmCheckPublicExecutable.callArgs)

	mmCheckPublicExecutable.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPublicExecutableDone returns true if the count of the CheckPublicExecutable invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableDone() bool {
	if m.CheckPublicExecutableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPublicExecutableMock.invocationsDone()
}

// MinimockCheckPublicExecutableInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableInspect() {
	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPublicExecutableCounter := mm_atomic.LoadUint64(&m.afterCheckPublicExecutableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPublicExecutableMock.defaultExpectation != nil && afterCheckPublicExecutableCounter < 1 {
		if m.CheckPublicExecutableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.CheckPublicExecutableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", m.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *m.CheckPublicExecutableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPublicExecutable != nil && afterCheckPublicExecutableCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.funcCheckPublicExecutableOrigin)
	}

	if !m.CheckPublicExecutableMock.invocationsDone() && afterCheckPublicExecutableCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPublicExecutable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPublicExecutableMock.expectedInvocations), m.CheckPublicExecutableMock.expectedInvocationsOrigin, afterCheckPublicExecutableCounter)
	}
}

type mACLClientInterfaceMockClose struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCloseExpectation
	expectations       []*ACLClientInterfaceMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCloseExpectation specifies expectation struct of the ACLClientInterface.Close
type ACLClientInterfaceMockCloseExpectation struct {
	mock *ACLClientInterfaceMock

	results      *ACLClientInterfaceMockCloseResults
	returnOrigin string
	Counter      uint64
}

// ACLClientInterfaceMockCloseResults contains results of the ACLClientInterface.Close
type ACLClientInterfaceMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mACLClientInterfaceMockClose) Optional() *mACLClientInterfaceMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for ACLClientInterface.Close
func (mmClose *mACLClientInterfaceMockClose) Expect() *mACLClientInterfaceMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ACLClientInterfaceMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ACLClientInterfaceMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.Close
func (mmClose *mACLClientInterfaceMockClose) Inspect(f func()) *mACLClientInterfaceMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by ACLClientInterface.Close
func (mmClose *mACLClientInterfaceMockClose) Return(err error) *ACLClientInterfaceMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ACLClientInterfaceMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ACLClientInterfaceMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ACLClientInterfaceMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the ACLClientInterface.Close method
func (mmClose *mACLClientInterfaceMockClose) Set(f func() (err error)) *ACLClientInterfaceMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times ACLClientInterface.Close should be invoked
func (mmClose *mACLClientInterfaceMockClose) Times(n uint64) *mACLClientInterfaceMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of ACLClientInterfaceMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mACLClientInterfaceMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_acl.ACLClientInterface
func (mmClose *ACLClientInterfaceMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ACLClientInterfaceMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ACLClientInterfaceMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ACLClientInterfaceMock.Close invocations
func (mmClose *ACLClientInterfaceMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ACLClientInterfaceMock.Close invocations
func (mmClose *ACLClientInterfaceMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientInterfaceMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mACLClientInterfaceMockDeleteModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeleteModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockDeleteModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockDeleteModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockDeleteModelPermissionExpectation specifies expectation struct of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockDeleteModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockDeleteModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockDeleteModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockDeleteModelPermissionParams contains parameters of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	user     string
}

// ACLClientInterfaceMockDeleteModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	user     *string
}

// ACLClientInterfaceMockDeleteModelPermissionResults contains results of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockDeleteModelPermissionOrigins contains origins of expectations of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originUser     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Optional() *mACLClientInterfaceMockDeleteModelPermission {
	mmDeleteModelPermission.optional = true
	return mmDeleteModelPermission
}

// Expect sets up expected params for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Expect(ctx context.Context, modelUID uuid.UUID, user string) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by ExpectParams functions")
	}

	mmDeleteModelPermission.defaultExpectation.params = &ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteModelPermission.expectations {
		if minimock.Equal(e.params, mmDeleteModelPermission.defaultExpectation.params) {
			mmDeleteModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelPermission.defaultExpectation.params)
		}
	}

	return mmDeleteModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectUserParam3(user string) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.user = &user
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID, user string)) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.inspectFuncDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeleteModelPermission")
	}

	mmDeleteModelPermission.mock.inspectFuncDeleteModelPermission = f

	return mmDeleteModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{mock: mmDeleteModelPermission.mock}
	}
	mmDeleteModelPermission.defaultExpectation.results = &ACLClientInterfaceMockDeleteModelPermissionResults{err}
	mmDeleteModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeleteModelPermission method
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID, user string) (err error)) *ACLClientInterfaceMock {
	if mmDeleteModelPermission.defaultExpectation != nil {
		mmDeleteModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeleteModelPermission method")
	}

	if len(mmDeleteModelPermission.expectations) > 0 {
		mmDeleteModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeleteModelPermission method")
	}

	mmDeleteModelPermission.mock.funcDeleteModelPermission = f
	mmDeleteModelPermission.mock.funcDeleteModelPermissionOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission.mock
}

// When sets expectation for the ACLClientInterface.DeleteModelPermission which will trigger the result defined by the following
// Then helper
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) When(ctx context.Context, modelUID uuid.UUID, user string) *ACLClientInterfaceMockDeleteModelPermissionExpectation {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeleteModelPermissionExpectation{
		mock:               mmDeleteModelPermission.mock,
		params:             &ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user},
		expectationOrigins: ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteModelPermission.expectations = append(mmDeleteModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeleteModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeleteModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeleteModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeleteModelPermission should be invoked
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Times(n uint64) *mACLClientInterfaceMockDeleteModelPermission {
	if n == 0 {
		mmDeleteModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeleteModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelPermission.expectedInvocations, n)
	mmDeleteModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission
}

func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) invocationsDone() bool {
	if len(mmDeleteModelPermission.expectations) == 0 && mmDeleteModelPermission.defaultExpectation == nil && mmDeleteModelPermission.mock.funcDeleteModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelPermission.mock.afterDeleteModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelPermission implements mm_acl.ACLClientInterface
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermission(ctx context.Context, modelUID uuid.UUID, user string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelPermission.beforeDeleteModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelPermission.afterDeleteModelPermissionCounter, 1)

	mmDeleteModelPermission.t.Helper()

	if mmDeleteModelPermission.inspectFuncDeleteModelPermission != nil {
		mmDeleteModelPermission.inspectFuncDeleteModelPermission(ctx, modelUID, user)
	}

	mm_params := ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}

	// Record call args
	mmDeleteModelPermission.DeleteModelPermissionMock.mutex.Lock()
	mmDeleteModelPermission.DeleteModelPermissionMock.callArgs = append(mmDeleteModelPermission.DeleteModelPermissionMock.callArgs, &mm_params)
	mmDeleteModelPermission.DeleteModelPermissionMock.mutex.Unlock()

	for _, e := range mmDeleteModelPermission.DeleteModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeleteModelPermission")
		}
		return (*mm_results).err
	}
	if mmDeleteModelPermission.funcDeleteModelPermission != nil {
		return mmDeleteModelPermission.funcDeleteModelPermission(ctx, modelUID, user)
	}
	mmDeleteModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeleteModelPermission. %v %v %v", ctx, modelUID, user)
	return
}

// DeleteModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeleteModelPermission invocations
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelPermission.afterDeleteModelPermissionCounter)
}

// DeleteModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeleteModelPermission invocations
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelPermission.beforeDeleteModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeleteModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Calls() []*ACLClientInterfaceMockDeleteModelPermissionParams {
	mmDeleteModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeleteModelPermissionParams, len(mmDeleteModelPermission.callArgs))
	copy(argCopy, mmDeleteModelPermission.callArgs)

	mmDeleteModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelPermissionDone returns true if the count of the DeleteModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeleteModelPermissionDone() bool {
	if m.DeleteModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelPermissionMock.invocationsDone()
}

// MinimockDeleteModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeleteModelPermissionInspect() {
	for _, e := range m.DeleteModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteModelPermissionCounter := mm_atomic.LoadUint64(&m.afterDeleteModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelPermissionMock.defaultExpectation != nil && afterDeleteModelPermissionCounter < 1 {
		if m.DeleteModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s", m.DeleteModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s with params: %#v", m.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelPermission != nil && afterDeleteModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s", m.funcDeleteModelPermissionOrigin)
	}

	if !m.DeleteModelPermissionMock.invocationsDone() && afterDeleteModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeleteModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelPermissionMock.expectedInvocations), m.DeleteModelPermissionMock.expectedInvocationsOrigin, afterDeleteModelPermissionCounter)
	}
}

type mACLClientInterfaceMockDeletePublicModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeletePublicModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockDeletePublicModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockDeletePublicModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockDeletePublicModelPermissionExpectation specifies expectation struct of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockDeletePublicModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockDeletePublicModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockDeletePublicModelPermissionParams contains parameters of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// ACLClientInterfaceMockDeletePublicModelPermissionResults contains results of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockDeletePublicModelPermissionOrigins contains origins of expectations of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Optional() *mACLClientInterfaceMockDeletePublicModelPermission {
	mmDeletePublicModelPermission.optional = true
	return mmDeletePublicModelPermission
}

// Expect sets up expected params for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Expect(ctx context.Context, modelUID uuid.UUID) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by ExpectParams functions")
	}

	mmDeletePublicModelPermission.defaultExpectation.params = &ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePublicModelPermission.expectations {
		if minimock.Equal(e.params, mmDeletePublicModelPermission.defaultExpectation.params) {
			mmDeletePublicModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePublicModelPermission.defaultExpectation.params)
		}
	}

	return mmDeletePublicModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.params != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Expect")
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeletePublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs{}
	}
	mmDeletePublicModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePublicModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.params != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Expect")
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeletePublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs{}
	}
	mmDeletePublicModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeletePublicModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.inspectFuncDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeletePublicModelPermission")
	}

	mmDeletePublicModelPermission.mock.inspectFuncDeletePublicModelPermission = f

	return mmDeletePublicModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{mock: mmDeletePublicModelPermission.mock}
	}
	mmDeletePublicModelPermission.defaultExpectation.results = &ACLClientInterfaceMockDeletePublicModelPermissionResults{err}
	mmDeletePublicModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeletePublicModelPermission method
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmDeletePublicModelPermission.defaultExpectation != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeletePublicModelPermission method")
	}

	if len(mmDeletePublicModelPermission.expectations) > 0 {
		mmDeletePublicModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeletePublicModelPermission method")
	}

	mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission = f
	mmDeletePublicModelPermission.mock.funcDeletePublicModelPermissionOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission.mock
}

// When sets expectation for the ACLClientInterface.DeletePublicModelPermission which will trigger the result defined by the following
// Then helper
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) When(ctx context.Context, modelUID uuid.UUID) *ACLClientInterfaceMockDeletePublicModelPermissionExpectation {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{
		mock:               mmDeletePublicModelPermission.mock,
		params:             &ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID},
		expectationOrigins: ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePublicModelPermission.expectations = append(mmDeletePublicModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeletePublicModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeletePublicModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeletePublicModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeletePublicModelPermission should be invoked
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Times(n uint64) *mACLClientInterfaceMockDeletePublicModelPermission {
	if n == 0 {
		mmDeletePublicModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeletePublicModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePublicModelPermission.expectedInvocations, n)
	mmDeletePublicModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission
}

func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) invocationsDone() bool {
	if len(mmDeletePublicModelPermission.expectations) == 0 && mmDeletePublicModelPermission.defaultExpectation == nil && mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePublicModelPermission.mock.afterDeletePublicModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePublicModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePublicModelPermission implements mm_acl.ACLClientInterface
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermission(ctx context.Context, modelUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeletePublicModelPermission.beforeDeletePublicModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePublicModelPermission.afterDeletePublicModelPermissionCounter, 1)

	mmDeletePublicModelPermission.t.Helper()

	if mmDeletePublicModelPermission.inspectFuncDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.inspectFuncDeletePublicModelPermission(ctx, modelUID)
	}

	mm_params := ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}

	// Record call args
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.mutex.Lock()
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.callArgs = append(mmDeletePublicModelPermission.DeletePublicModelPermissionMock.callArgs, &mm_params)
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.mutex.Unlock()

	for _, e := range mmDeletePublicModelPermission.DeletePublicModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePublicModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeletePublicModelPermission")
		}
		return (*mm_results).err
	}
	if mmDeletePublicModelPermission.funcDeletePublicModelPermission != nil {
		return mmDeletePublicModelPermission.funcDeletePublicModelPermission(ctx, modelUID)
	}
	mmDeletePublicModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeletePublicModelPermission. %v %v", ctx, modelUID)
	return
}

// DeletePublicModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeletePublicModelPermission invocations
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePublicModelPermission.afterDeletePublicModelPermissionCounter)
}

// DeletePublicModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeletePublicModelPermission invocations
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePublicModelPermission.beforeDeletePublicModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeletePublicModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Calls() []*ACLClientInterfaceMockDeletePublicModelPermissionParams {
	mmDeletePublicModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeletePublicModelPermissionParams, len(mmDeletePublicModelPermission.callArgs))
	copy(argCopy, mmDeletePublicModelPermission.callArgs)

	mmDeletePublicModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePublicModelPermissionDone returns true if the count of the DeletePublicModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeletePublicModelPermissionDone() bool {
	if m.DeletePublicModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePublicModelPermissionMock.invocationsDone()
}

// MinimockDeletePublicModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeletePublicModelPermissionInspect() {
	for _, e := range m.DeletePublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePublicModelPermissionCounter := mm_atomic.LoadUint64(&m.afterDeletePublicModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePublicModelPermissionMock.defaultExpectation != nil && afterDeletePublicModelPermissionCounter < 1 {
		if m.DeletePublicModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s", m.DeletePublicModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s with params: %#v", m.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeletePublicModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePublicModelPermission != nil && afterDeletePublicModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s", m.funcDeletePublicModelPermissionOrigin)
	}

	if !m.DeletePublicModelPermissionMock.invocationsDone() && afterDeletePublicModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePublicModelPermissionMock.expectedInvocations), m.DeletePublicModelPermissionMock.expectedInvocationsOrigin, afterDeletePublicModelPermissionCounter)
	}
}

type mACLClientInterfaceMockGetAuthorizationModelID struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockGetAuthorizationModelIDExpectation
	expectations       []*ACLClientInterfaceMockGetAuthorizationModelIDExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockGetAuthorizationModelIDExpectation specifies expectation struct of the ACLClientInterface.GetAuthorizationModelID
type ACLClientInterfaceMockGetAuthorizationModelIDExpectation struct {
	mock *ACLClientInterfaceMock

	results      *ACLClientInterfaceMockGetAuthorizationModelIDResults
	returnOrigin string
	Counter      uint64
}

// ACLClientInterfaceMockGetAuthorizationModelIDResults contains results of the ACLClientInterface.GetAuthorizationModelID
type ACLClientInterfaceMockGetAuthorizationModelIDResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Optional() *mACLClientInterfaceMockGetAuthorizationModelID {
	mmGetAuthorizationModelID.optional = true
	return mmGetAuthorizationModelID
}

// Expect sets up expected params for ACLClientInterface.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Expect() *mACLClientInterfaceMockGetAuthorizationModelID {
	if mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.GetAuthorizationModelID mock is already set by Set")
	}

	if mmGetAuthorizationModelID.defaultExpectation == nil {
		mmGetAuthorizationModelID.defaultExpectation = &ACLClientInterfaceMockGetAuthorizationModelIDExpectation{}
	}

	return mmGetAuthorizationModelID
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Inspect(f func()) *mACLClientInterfaceMockGetAuthorizationModelID {
	if mmGetAuthorizationModelID.mock.inspectFuncGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.GetAuthorizationModelID")
	}

	mmGetAuthorizationModelID.mock.inspectFuncGetAuthorizationModelID = f

	return mmGetAuthorizationModelID
}

// Return sets up results that will be returned by ACLClientInterface.GetAuthorizationModelID
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Return(s1 string) *ACLClientInterfaceMock {
	if mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.GetAuthorizationModelID mock is already set by Set")
	}

	if mmGetAuthorizationModelID.defaultExpectation == nil {
		mmGetAuthorizationModelID.defaultExpectation = &ACLClientInterfaceMockGetAuthorizationModelIDExpectation{mock: mmGetAuthorizationModelID.mock}
	}
	mmGetAuthorizationModelID.defaultExpectation.results = &ACLClientInterfaceMockGetAuthorizationModelIDResults{s1}
	mmGetAuthorizationModelID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID.mock
}

// Set uses given function f to mock the ACLClientInterface.GetAuthorizationModelID method
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Set(f func() (s1 string)) *ACLClientInterfaceMock {
	if mmGetAuthorizationModelID.defaultExpectation != nil {
		mmGetAuthorizationModelID.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.GetAuthorizationModelID method")
	}

	if len(mmGetAuthorizationModelID.expectations) > 0 {
		mmGetAuthorizationModelID.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.GetAuthorizationModelID method")
	}

	mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID = f
	mmGetAuthorizationModelID.mock.funcGetAuthorizationModelIDOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID.mock
}

// Times sets number of times ACLClientInterface.GetAuthorizationModelID should be invoked
func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) Times(n uint64) *mACLClientInterfaceMockGetAuthorizationModelID {
	if n == 0 {
		mmGetAuthorizationModelID.mock.t.Fatalf("Times of ACLClientInterfaceMock.GetAuthorizationModelID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAuthorizationModelID.expectedInvocations, n)
	mmGetAuthorizationModelID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAuthorizationModelID
}

func (mmGetAuthorizationModelID *mACLClientInterfaceMockGetAuthorizationModelID) invocationsDone() bool {
	if len(mmGetAuthorizationModelID.expectations) == 0 && mmGetAuthorizationModelID.defaultExpectation == nil && mmGetAuthorizationModelID.mock.funcGetAuthorizationModelID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAuthorizationModelID.mock.afterGetAuthorizationModelIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAuthorizationModelID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAuthorizationModelID implements mm_acl.ACLClientInterface
func (mmGetAuthorizationModelID *ACLClientInterfaceMock) GetAuthorizationModelID() (s1 string) {
	mm_atomic.AddUint64(&mmGetAuthorizationModelID.beforeGetAuthorizationModelIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthorizationModelID.afterGetAuthorizationModelIDCounter, 1)

	mmGetAuthorizationModelID.t.Helper()

	if mmGetAuthorizationModelID.inspectFuncGetAuthorizationModelID != nil {
		mmGetAuthorizationModelID.inspectFuncGetAuthorizationModelID()
	}

	if mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetAuthorizationModelID.GetAuthorizationModelIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthorizationModelID.t.Fatal("No results are set for the ACLClientInterfaceMock.GetAuthorizationModelID")
		}
		return (*mm_results).s1
	}
	if mmGetAuthorizationModelID.funcGetAuthorizationModelID != nil {
		return mmGetAuthorizationModelID.funcGetAuthorizationModelID()
	}
	mmGetAuthorizationModelID.t.Fatalf("Unexpected call to ACLClientInterfaceMock.GetAuthorizationModelID.")
	return
}

// GetAuthorizationModelIDAfterCounter returns a count of finished ACLClientInterfaceMock.GetAuthorizationModelID invocations
func (mmGetAuthorizationModelID *ACLClientInterfaceMock) GetAuthorizationModelIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorizationModelID.afterGetAuthorizationModelIDCounter)
}

// GetAuthorizationModelIDBeforeCounter returns a count of ACLClientInterfaceMock.GetAuthorizationModelID invocations
func (mmGetAuthorizationModelID *ACLClientInterfaceMock) GetAuthorizationModelIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorizationModelID.beforeGetAuthorizationModelIDCounter)
}

// MinimockGetAuthorizationModelIDDone returns true if the count of the GetAuthorizationModelID invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockGetAuthorizationModelIDDone() bool {
	if m.GetAuthorizationModelIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAuthorizationModelIDMock.invocationsDone()
}

// MinimockGetAuthorizationModelIDInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockGetAuthorizationModelIDInspect() {
	for _, e := range m.GetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientInterfaceMock.GetAuthorizationModelID")
		}
	}

	afterGetAuthorizationModelIDCounter := mm_atomic.LoadUint64(&m.afterGetAuthorizationModelIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthorizationModelIDMock.defaultExpectation != nil && afterGetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.GetAuthorizationModelID at\n%s", m.GetAuthorizationModelIDMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthorizationModelID != nil && afterGetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.GetAuthorizationModelID at\n%s", m.funcGetAuthorizationModelIDOrigin)
	}

	if !m.GetAuthorizationModelIDMock.invocationsDone() && afterGetAuthorizationModelIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.GetAuthorizationModelID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAuthorizationModelIDMock.expectedInvocations), m.GetAuthorizationModelIDMock.expectedInvocationsOrigin, afterGetAuthorizationModelIDCounter)
	}
}

type mACLClientInterfaceMockGetStoreID struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockGetStoreIDExpectation
	expectations       []*ACLClientInterfaceMockGetStoreIDExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockGetStoreIDExpectation specifies expectation struct of the ACLClientInterface.GetStoreID
type ACLClientInterfaceMockGetStoreIDExpectation struct {
	mock *ACLClientInterfaceMock

	results      *ACLClientInterfaceMockGetStoreIDResults
	returnOrigin string
	Counter      uint64
}

// ACLClientInterfaceMockGetStoreIDResults contains results of the ACLClientInterface.GetStoreID
type ACLClientInterfaceMockGetStoreIDResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Optional() *mACLClientInterfaceMockGetStoreID {
	mmGetStoreID.optional = true
	return mmGetStoreID
}

// Expect sets up expected params for ACLClientInterface.GetStoreID
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Expect() *mACLClientInterfaceMockGetStoreID {
	if mmGetStoreID.mock.funcGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.GetStoreID mock is already set by Set")
	}

	if mmGetStoreID.defaultExpectation == nil {
		mmGetStoreID.defaultExpectation = &ACLClientInterfaceMockGetStoreIDExpectation{}
	}

	return mmGetStoreID
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.GetStoreID
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Inspect(f func()) *mACLClientInterfaceMockGetStoreID {
	if mmGetStoreID.mock.inspectFuncGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.GetStoreID")
	}

	mmGetStoreID.mock.inspectFuncGetStoreID = f

	return mmGetStoreID
}

// Return sets up results that will be returned by ACLClientInterface.GetStoreID
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Return(s1 string) *ACLClientInterfaceMock {
	if mmGetStoreID.mock.funcGetStoreID != nil {
		mmGetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.GetStoreID mock is already set by Set")
	}

	if mmGetStoreID.defaultExpectation == nil {
		mmGetStoreID.defaultExpectation = &ACLClientInterfaceMockGetStoreIDExpectation{mock: mmGetStoreID.mock}
	}
	mmGetStoreID.defaultExpectation.results = &ACLClientInterfaceMockGetStoreIDResults{s1}
	mmGetStoreID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetStoreID.mock
}

// Set uses given function f to mock the ACLClientInterface.GetStoreID method
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Set(f func() (s1 string)) *ACLClientInterfaceMock {
	if mmGetStoreID.defaultExpectation != nil {
		mmGetStoreID.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.GetStoreID method")
	}

	if len(mmGetStoreID.expectations) > 0 {
		mmGetStoreID.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.GetStoreID method")
	}

	mmGetStoreID.mock.funcGetStoreID = f
	mmGetStoreID.mock.funcGetStoreIDOrigin = minimock.CallerInfo(1)
	return mmGetStoreID.mock
}

// Times sets number of times ACLClientInterface.GetStoreID should be invoked
func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) Times(n uint64) *mACLClientInterfaceMockGetStoreID {
	if n == 0 {
		mmGetStoreID.mock.t.Fatalf("Times of ACLClientInterfaceMock.GetStoreID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetStoreID.expectedInvocations, n)
	mmGetStoreID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetStoreID
}

func (mmGetStoreID *mACLClientInterfaceMockGetStoreID) invocationsDone() bool {
	if len(mmGetStoreID.expectations) == 0 && mmGetStoreID.defaultExpectation == nil && mmGetStoreID.mock.funcGetStoreID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetStoreID.mock.afterGetStoreIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetStoreID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetStoreID implements mm_acl.ACLClientInterface
func (mmGetStoreID *ACLClientInterfaceMock) GetStoreID() (s1 string) {
	mm_atomic.AddUint64(&mmGetStoreID.beforeGetStoreIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStoreID.afterGetStoreIDCounter, 1)

	mmGetStoreID.t.Helper()

	if mmGetStoreID.inspectFuncGetStoreID != nil {
		mmGetStoreID.inspectFuncGetStoreID()
	}

	if mmGetStoreID.GetStoreIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStoreID.GetStoreIDMock.defaultExpectation.Counter, 1)

		mm_results := mmGetStoreID.GetStoreIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStoreID.t.Fatal("No results are set for the ACLClientInterfaceMock.GetStoreID")
		}
		return (*mm_results).s1
	}
	if mmGetStoreID.funcGetStoreID != nil {
		return mmGetStoreID.funcGetStoreID()
	}
	mmGetStoreID.t.Fatalf("Unexpected call to ACLClientInterfaceMock.GetStoreID.")
	return
}

// GetStoreIDAfterCounter returns a count of finished ACLClientInterfaceMock.GetStoreID invocations
func (mmGetStoreID *ACLClientInterfaceMock) GetStoreIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStoreID.afterGetStoreIDCounter)
}

// GetStoreIDBeforeCounter returns a count of ACLClientInterfaceMock.GetStoreID invocations
func (mmGetStoreID *ACLClientInterfaceMock) GetStoreIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStoreID.beforeGetStoreIDCounter)
}

// MinimockGetStoreIDDone returns true if the count of the GetStoreID invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockGetStoreIDDone() bool {
	if m.GetStoreIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetStoreIDMock.invocationsDone()
}

// MinimockGetStoreIDInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockGetStoreIDInspect() {
	for _, e := range m.GetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientInterfaceMock.GetStoreID")
		}
	}

	afterGetStoreIDCounter := mm_atomic.LoadUint64(&m.afterGetStoreIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetStoreIDMock.defaultExpectation != nil && afterGetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.GetStoreID at\n%s", m.GetStoreIDMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStoreID != nil && afterGetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.GetStoreID at\n%s", m.funcGetStoreIDOrigin)
	}

	if !m.GetStoreIDMock.invocationsDone() && afterGetStoreIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.GetStoreID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetStoreIDMock.expectedInvocations), m.GetStoreIDMock.expectedInvocationsOrigin, afterGetStoreIDCounter)
	}
}

type mACLClientInterfaceMockListPermissions struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockListPermissionsExpectation
	expectations       []*ACLClientInterfaceMockListPermissionsExpectation

	callArgs []*ACLClientInterfaceMockListPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockListPermissionsExpectation specifies expectation struct of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockListPermissionsParams
	paramPtrs          *ACLClientInterfaceMockListPermissionsParamPtrs
	expectationOrigins ACLClientInterfaceMockListPermissionsExpectationOrigins
	results            *ACLClientInterfaceMockListPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockListPermissionsParams contains parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	role       string
	isPublic   bool
}

// ACLClientInterfaceMockListPermissionsParamPtrs contains pointers to parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	role       *string
	isPublic   *bool
}

// ACLClientInterfaceMockListPermissionsResults contains results of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsResults struct {
	ua1 []uuid.UUID
	err error
}

// ACLClientInterfaceMockListPermissionsOrigins contains origins of expectations of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originRole       string
	originIsPublic   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Optional() *mACLClientInterfaceMockListPermissions {
	mmListPermissions.optional = true
	return mmListPermissions
}

// Expect sets up expected params for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Expect(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.paramPtrs != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by ExpectParams functions")
	}

	mmListPermissions.defaultExpectation.params = &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}
	mmListPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPermissions.expectations {
		if minimock.Equal(e.params, mmListPermissions.defaultExpectation.params) {
			mmListPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPermissions.defaultExpectation.params)
		}
	}

	return mmListPermissions
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.objectType = &objectType
	mmListPermissions.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectRoleParam3 sets up expected param role for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectRoleParam3(role string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.role = &role
	mmListPermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectIsPublicParam4 sets up expected param isPublic for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectIsPublicParam4(isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.isPublic = &isPublic
	mmListPermissions.defaultExpectation.expectationOrigins.originIsPublic = minimock.CallerInfo(1)

	return mmListPermissions
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool)) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.inspectFuncListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.ListPermissions")
	}

	mmListPermissions.mock.inspectFuncListPermissions = f

	return mmListPermissions
}

// Return sets up results that will be returned by ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Return(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{mock: mmListPermissions.mock}
	}
	mmListPermissions.defaultExpectation.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	mmListPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// Set uses given function f to mock the ACLClientInterface.ListPermissions method
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Set(f func(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error)) *ACLClientInterfaceMock {
	if mmListPermissions.defaultExpectation != nil {
		mmListPermissions.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.ListPermissions method")
	}

	if len(mmListPermissions.expectations) > 0 {
		mmListPermissions.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.ListPermissions method")
	}

	mmListPermissions.mock.funcListPermissions = f
	mmListPermissions.mock.funcListPermissionsOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// When sets expectation for the ACLClientInterface.ListPermissions which will trigger the result defined by the following
// Then helper
func (mmListPermissions *mACLClientInterfaceMockListPermissions) When(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) *ACLClientInterfaceMockListPermissionsExpectation {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockListPermissionsExpectation{
		mock:               mmListPermissions.mock,
		params:             &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic},
		expectationOrigins: ACLClientInterfaceMockListPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPermissions.expectations = append(mmListPermissions.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.ListPermissions return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockListPermissionsExpectation) Then(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.ListPermissions should be invoked
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Times(n uint64) *mACLClientInterfaceMockListPermissions {
	if n == 0 {
		mmListPermissions.mock.t.Fatalf("Times of ACLClientInterfaceMock.ListPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPermissions.expectedInvocations, n)
	mmListPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPermissions
}

func (mmListPermissions *mACLClientInterfaceMockListPermissions) invocationsDone() bool {
	if len(mmListPermissions.expectations) == 0 && mmListPermissions.defaultExpectation == nil && mmListPermissions.mock.funcListPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPermissions.mock.afterListPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPermissions implements mm_acl.ACLClientInterface
func (mmListPermissions *ACLClientInterfaceMock) ListPermissions(ctx context.Context, objectType openfga.ObjectType, role string, isPublic bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmListPermissions.beforeListPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPermissions.afterListPermissionsCounter, 1)

	mmListPermissions.t.Helper()

	if mmListPermissions.inspectFuncListPermissions != nil {
		mmListPermissions.inspectFuncListPermissions(ctx, objectType, role, isPublic)
	}

	mm_params := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

	// Record call args
	mmListPermissions.ListPermissionsMock.mutex.Lock()
	mmListPermissions.ListPermissionsMock.callArgs = append(mmListPermissions.ListPermissionsMock.callArgs, &mm_params)
	mmListPermissions.ListPermissionsMock.mutex.Unlock()

	for _, e := range mmListPermissions.ListPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListPermissions.ListPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPermissions.ListPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPermissions.ListPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmListPermissions.ListPermissionsMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.isPublic != nil && !minimock.Equal(*mm_want_ptrs.isPublic, mm_got.isPublic) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter isPublic, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originIsPublic, *mm_want_ptrs.isPublic, mm_got.isPublic, minimock.Diff(*mm_want_ptrs.isPublic, mm_got.isPublic))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPermissions.ListPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPermissions.t.Fatal("No results are set for the ACLClientInterfaceMock.ListPermissions")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListPermissions.funcListPermissions != nil {
		return mmListPermissions.funcListPermissions(ctx, objectType, role, isPublic)
	}
	mmListPermissions.t.Fatalf("Unexpected call to ACLClientInterfaceMock.ListPermissions. %v %v %v %v", ctx, objectType, role, isPublic)
	return
}

// ListPermissionsAfterCounter returns a count of finished ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.afterListPermissionsCounter)
}

// ListPermissionsBeforeCounter returns a count of ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.beforeListPermissionsCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.ListPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Calls() []*ACLClientInterfaceMockListPermissionsParams {
	mmListPermissions.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockListPermissionsParams, len(mmListPermissions.callArgs))
	copy(argCopy, mmListPermissions.callArgs)

	mmListPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockListPermissionsDone returns true if the count of the ListPermissions invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockListPermissionsDone() bool {
	if m.ListPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPermissionsMock.invocationsDone()
}

// MinimockListPermissionsInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockListPermissionsInspect() {
	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPermissionsCounter := mm_atomic.LoadUint64(&m.afterListPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPermissionsMock.defaultExpectation != nil && afterListPermissionsCounter < 1 {
		if m.ListPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.ListPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", m.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.ListPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPermissions != nil && afterListPermissionsCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.funcListPermissionsOrigin)
	}

	if !m.ListPermissionsMock.invocationsDone() && afterListPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.ListPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPermissionsMock.expectedInvocations), m.ListPermissionsMock.expectedInvocationsOrigin, afterListPermissionsCounter)
	}
}

type mACLClientInterfaceMockPurge struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockPurgeExpectation
	expectations       []*ACLClientInterfaceMockPurgeExpectation

	callArgs []*ACLClientInterfaceMockPurgeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockPurgeExpectation specifies expectation struct of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockPurgeParams
	paramPtrs          *ACLClientInterfaceMockPurgeParamPtrs
	expectationOrigins ACLClientInterfaceMockPurgeExpectationOrigins
	results            *ACLClientInterfaceMockPurgeResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockPurgeParams contains parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockPurgeParamPtrs contains pointers to parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockPurgeResults contains results of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeResults struct {
	err error
}

// ACLClientInterfaceMockPurgeOrigins contains origins of expectations of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurge *mACLClientInterfaceMockPurge) Optional() *mACLClientInterfaceMockPurge {
	mmPurge.optional = true
	return mmPurge
}

// Expect sets up expected params for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.paramPtrs != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by ExpectParams functions")
	}

	mmPurge.defaultExpectation.params = &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}
	mmPurge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPurge.expectations {
		if minimock.Equal(e.params, mmPurge.defaultExpectation.params) {
			mmPurge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurge.defaultExpectation.params)
		}
	}

	return mmPurge
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.ctx = &ctx
	mmPurge.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectType = &objectType
	mmPurge.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmPurge.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmPurge
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID)) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.inspectFuncPurge != nil {
		mmPurge.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.Purge")
	}

	mmPurge.mock.inspectFuncPurge = f

	return mmPurge
}

// Return sets up results that will be returned by ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Return(err error) *ACLClientInterfaceMock {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{mock: mmPurge.mock}
	}
	mmPurge.defaultExpectation.results = &ACLClientInterfaceMockPurgeResults{err}
	mmPurge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// Set uses given function f to mock the ACLClientInterface.Purge method
func (mmPurge *mACLClientInterfaceMockPurge) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmPurge.defaultExpectation != nil {
		mmPurge.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.Purge method")
	}

	if len(mmPurge.expectations) > 0 {
		mmPurge.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.Purge method")
	}

	mmPurge.mock.funcPurge = f
	mmPurge.mock.funcPurgeOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// When sets expectation for the ACLClientInterface.Purge which will trigger the result defined by the following
// Then helper
func (mmPurge *mACLClientInterfaceMockPurge) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) *ACLClientInterfaceMockPurgeExpectation {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockPurgeExpectation{
		mock:               mmPurge.mock,
		params:             &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockPurgeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPurge.expectations = append(mmPurge.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.Purge return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockPurgeExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockPurgeResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.Purge should be invoked
func (mmPurge *mACLClientInterfaceMockPurge) Times(n uint64) *mACLClientInterfaceMockPurge {
	if n == 0 {
		mmPurge.mock.t.Fatalf("Times of ACLClientInterfaceMock.Purge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurge.expectedInvocations, n)
	mmPurge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPurge
}

func (mmPurge *mACLClientInterfaceMockPurge) invocationsDone() bool {
	if len(mmPurge.expectations) == 0 && mmPurge.defaultExpectation == nil && mmPurge.mock.funcPurge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurge.mock.afterPurgeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Purge implements mm_acl.ACLClientInterface
func (mmPurge *ACLClientInterfaceMock) Purge(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPurge.beforePurgeCounter, 1)
	defer mm_atomic.AddUint64(&mmPurge.afterPurgeCounter, 1)

	mmPurge.t.Helper()

	if mmPurge.inspectFuncPurge != nil {
		mmPurge.inspectFuncPurge(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

	// Record call args
	mmPurge.PurgeMock.mutex.Lock()
	mmPurge.PurgeMock.callArgs = append(mmPurge.PurgeMock.callArgs, &mm_params)
	mmPurge.PurgeMock.mutex.Unlock()

	for _, e := range mmPurge.PurgeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurge.PurgeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurge.PurgeMock.defaultExpectation.Counter, 1)
		mm_want := mmPurge.PurgeMock.defaultExpectation.params
		mm_want_ptrs := mmPurge.PurgeMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPurge.PurgeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurge.PurgeMock.defaultExpectation.results
		if mm_results == nil {
			mmPurge.t.Fatal("No results are set for the ACLClientInterfaceMock.Purge")
		}
		return (*mm_results).err
	}
	if mmPurge.funcPurge != nil {
		return mmPurge.funcPurge(ctx, objectType, objectUID)
	}
	mmPurge.t.Fatalf("Unexpected call to ACLClientInterfaceMock.Purge. %v %v %v", ctx, objectType, objectUID)
	return
}

// PurgeAfterCounter returns a count of finished ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.afterPurgeCounter)
}

// PurgeBeforeCounter returns a count of ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.beforePurgeCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.Purge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurge *mACLClientInterfaceMockPurge) Calls() []*ACLClientInterfaceMockPurgeParams {
	mmPurge.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockPurgeParams, len(mmPurge.callArgs))
	copy(argCopy, mmPurge.callArgs)

	mmPurge.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeDone returns true if the count of the Purge invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockPurgeDone() bool {
	if m.PurgeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeMock.invocationsDone()
}

// MinimockPurgeInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockPurgeInspect() {
	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPurgeCounter := mm_atomic.LoadUint64(&m.afterPurgeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeMock.defaultExpectation != nil && afterPurgeCounter < 1 {
		if m.PurgeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.PurgeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", m.PurgeMock.defaultExpectation.expectationOrigins.origin, *m.PurgeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurge != nil && afterPurgeCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.funcPurgeOrigin)
	}

	if !m.PurgeMock.invocationsDone() && afterPurgeCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.Purge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeMock.expectedInvocations), m.PurgeMock.expectedInvocationsOrigin, afterPurgeCounter)
	}
}

type mACLClientInterfaceMockSDKClient struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSDKClientExpectation
	expectations       []*ACLClientInterfaceMockSDKClientExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSDKClientExpectation specifies expectation struct of the ACLClientInterface.SDKClient
type ACLClientInterfaceMockSDKClientExpectation struct {
	mock *ACLClientInterfaceMock

	results      *ACLClientInterfaceMockSDKClientResults
	returnOrigin string
	Counter      uint64
}

// ACLClientInterfaceMockSDKClientResults contains results of the ACLClientInterface.SDKClient
type ACLClientInterfaceMockSDKClientResults struct {
	op1 *openfgaclient.OpenFgaClient
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Optional() *mACLClientInterfaceMockSDKClient {
	mmSDKClient.optional = true
	return mmSDKClient
}

// Expect sets up expected params for ACLClientInterface.SDKClient
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Expect() *mACLClientInterfaceMockSDKClient {
	if mmSDKClient.mock.funcSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("ACLClientInterfaceMock.SDKClient mock is already set by Set")
	}

	if mmSDKClient.defaultExpectation == nil {
		mmSDKClient.defaultExpectation = &ACLClientInterfaceMockSDKClientExpectation{}
	}

	return mmSDKClient
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SDKClient
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Inspect(f func()) *mACLClientInterfaceMockSDKClient {
	if mmSDKClient.mock.inspectFuncSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SDKClient")
	}

	mmSDKClient.mock.inspectFuncSDKClient = f

	return mmSDKClient
}

// Return sets up results that will be returned by ACLClientInterface.SDKClient
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Return(op1 *openfgaclient.OpenFgaClient) *ACLClientInterfaceMock {
	if mmSDKClient.mock.funcSDKClient != nil {
		mmSDKClient.mock.t.Fatalf("ACLClientInterfaceMock.SDKClient mock is already set by Set")
	}

	if mmSDKClient.defaultExpectation == nil {
		mmSDKClient.defaultExpectation = &ACLClientInterfaceMockSDKClientExpectation{mock: mmSDKClient.mock}
	}
	mmSDKClient.defaultExpectation.results = &ACLClientInterfaceMockSDKClientResults{op1}
	mmSDKClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSDKClient.mock
}

// Set uses given function f to mock the ACLClientInterface.SDKClient method
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Set(f func() (op1 *openfgaclient.OpenFgaClient)) *ACLClientInterfaceMock {
	if mmSDKClient.defaultExpectation != nil {
		mmSDKClient.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SDKClient method")
	}

	if len(mmSDKClient.expectations) > 0 {
		mmSDKClient.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SDKClient method")
	}

	mmSDKClient.mock.funcSDKClient = f
	mmSDKClient.mock.funcSDKClientOrigin = minimock.CallerInfo(1)
	return mmSDKClient.mock
}

// Times sets number of times ACLClientInterface.SDKClient should be invoked
func (mmSDKClient *mACLClientInterfaceMockSDKClient) Times(n uint64) *mACLClientInterfaceMockSDKClient {
	if n == 0 {
		mmSDKClient.mock.t.Fatalf("Times of ACLClientInterfaceMock.SDKClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSDKClient.expectedInvocations, n)
	mmSDKClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSDKClient
}

func (mmSDKClient *mACLClientInterfaceMockSDKClient) invocationsDone() bool {
	if len(mmSDKClient.expectations) == 0 && mmSDKClient.defaultExpectation == nil && mmSDKClient.mock.funcSDKClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSDKClient.mock.afterSDKClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSDKClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SDKClient implements mm_acl.ACLClientInterface
func (mmSDKClient *ACLClientInterfaceMock) SDKClient() (op1 *openfgaclient.OpenFgaClient) {
	mm_atomic.AddUint64(&mmSDKClient.beforeSDKClientCounter, 1)
	defer mm_atomic.AddUint64(&mmSDKClient.afterSDKClientCounter, 1)

	mmSDKClient.t.Helper()

	if mmSDKClient.inspectFuncSDKClient != nil {
		mmSDKClient.inspectFuncSDKClient()
	}

	if mmSDKClient.SDKClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSDKClient.SDKClientMock.defaultExpectation.Counter, 1)

		mm_results := mmSDKClient.SDKClientMock.defaultExpectation.results
		if mm_results == nil {
			mmSDKClient.t.Fatal("No results are set for the ACLClientInterfaceMock.SDKClient")
		}
		return (*mm_results).op1
	}
	if mmSDKClient.funcSDKClient != nil {
		return mmSDKClient.funcSDKClient()
	}
	mmSDKClient.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SDKClient.")
	return
}

// SDKClientAfterCounter returns a count of finished ACLClientInterfaceMock.SDKClient invocations
func (mmSDKClient *ACLClientInterfaceMock) SDKClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSDKClient.afterSDKClientCounter)
}

// SDKClientBeforeCounter returns a count of ACLClientInterfaceMock.SDKClient invocations
func (mmSDKClient *ACLClientInterfaceMock) SDKClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSDKClient.beforeSDKClientCounter)
}

// MinimockSDKClientDone returns true if the count of the SDKClient invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSDKClientDone() bool {
	if m.SDKClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SDKClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SDKClientMock.invocationsDone()
}

// MinimockSDKClientInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSDKClientInspect() {
	for _, e := range m.SDKClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ACLClientInterfaceMock.SDKClient")
		}
	}

	afterSDKClientCounter := mm_atomic.LoadUint64(&m.afterSDKClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SDKClientMock.defaultExpectation != nil && afterSDKClientCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SDKClient at\n%s", m.SDKClientMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSDKClient != nil && afterSDKClientCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SDKClient at\n%s", m.funcSDKClientOrigin)
	}

	if !m.SDKClientMock.invocationsDone() && afterSDKClientCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SDKClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SDKClientMock.expectedInvocations), m.SDKClientMock.expectedInvocationsOrigin, afterSDKClientCounter)
	}
}

type mACLClientInterfaceMockSetAuthorizationModelID struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetAuthorizationModelIDExpectation
	expectations       []*ACLClientInterfaceMockSetAuthorizationModelIDExpectation

	callArgs []*ACLClientInterfaceMockSetAuthorizationModelIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetAuthorizationModelIDExpectation specifies expectation struct of the ACLClientInterface.SetAuthorizationModelID
type ACLClientInterfaceMockSetAuthorizationModelIDExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetAuthorizationModelIDParams
	paramPtrs          *ACLClientInterfaceMockSetAuthorizationModelIDParamPtrs
	expectationOrigins ACLClientInterfaceMockSetAuthorizationModelIDExpectationOrigins
	results            *ACLClientInterfaceMockSetAuthorizationModelIDResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetAuthorizationModelIDParams contains parameters of the ACLClientInterface.SetAuthorizationModelID
type ACLClientInterfaceMockSetAuthorizationModelIDParams struct {
	modelID string
}

// ACLClientInterfaceMockSetAuthorizationModelIDParamPtrs contains pointers to parameters of the ACLClientInterface.SetAuthorizationModelID
type ACLClientInterfaceMockSetAuthorizationModelIDParamPtrs struct {
	modelID *string
}

// ACLClientInterfaceMockSetAuthorizationModelIDResults contains results of the ACLClientInterface.SetAuthorizationModelID
type ACLClientInterfaceMockSetAuthorizationModelIDResults struct {
	err error
}

// ACLClientInterfaceMockSetAuthorizationModelIDOrigins contains origins of expectations of the ACLClientInterface.SetAuthorizationModelID
type ACLClientInterfaceMockSetAuthorizationModelIDExpectationOrigins struct {
	origin        string
	originModelID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Optional() *mACLClientInterfaceMockSetAuthorizationModelID {
	mmSetAuthorizationModelID.optional = true
	return mmSetAuthorizationModelID
}

// Expect sets up expected params for ACLClientInterface.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Expect(modelID string) *mACLClientInterfaceMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientInterfaceMockSetAuthorizationModelIDExpectation{}
	}

	if mmSetAuthorizationModelID.defaultExpectation.paramPtrs != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by ExpectParams functions")
	}

	mmSetAuthorizationModelID.defaultExpectation.params = &ACLClientInterfaceMockSetAuthorizationModelIDParams{modelID}
	mmSetAuthorizationModelID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetAuthorizationModelID.expectations {
		if minimock.Equal(e.params, mmSetAuthorizationModelID.defaultExpectation.params) {
			mmSetAuthorizationModelID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetAuthorizationModelID.defaultExpectation.params)
		}
	}

	return mmSetAuthorizationModelID
}

// ExpectModelIDParam1 sets up expected param modelID for ACLClientInterface.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) ExpectModelIDParam1(modelID string) *mACLClientInterfaceMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientInterfaceMockSetAuthorizationModelIDExpectation{}
	}

	if mmSetAuthorizationModelID.defaultExpectation.params != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by Expect")
	}

	if mmSetAuthorizationModelID.defaultExpectation.paramPtrs == nil {
		mmSetAuthorizationModelID.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetAuthorizationModelIDParamPtrs{}
	}
	mmSetAuthorizationModelID.defaultExpectation.paramPtrs.modelID = &modelID
	mmSetAuthorizationModelID.defaultExpectation.expectationOrigins.originModelID = minimock.CallerInfo(1)

	return mmSetAuthorizationModelID
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Inspect(f func(modelID string)) *mACLClientInterfaceMockSetAuthorizationModelID {
	if mmSetAuthorizationModelID.mock.inspectFuncSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetAuthorizationModelID")
	}

	mmSetAuthorizationModelID.mock.inspectFuncSetAuthorizationModelID = f

	return mmSetAuthorizationModelID
}

// Return sets up results that will be returned by ACLClientInterface.SetAuthorizationModelID
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Return(err error) *ACLClientInterfaceMock {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by Set")
	}

	if mmSetAuthorizationModelID.defaultExpectation == nil {
		mmSetAuthorizationModelID.defaultExpectation = &ACLClientInterfaceMockSetAuthorizationModelIDExpectation{mock: mmSetAuthorizationModelID.mock}
	}
	mmSetAuthorizationModelID.defaultExpectation.results = &ACLClientInterfaceMockSetAuthorizationModelIDResults{err}
	mmSetAuthorizationModelID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID.mock
}

// Set uses given function f to mock the ACLClientInterface.SetAuthorizationModelID method
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Set(f func(modelID string) (err error)) *ACLClientInterfaceMock {
	if mmSetAuthorizationModelID.defaultExpectation != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetAuthorizationModelID method")
	}

	if len(mmSetAuthorizationModelID.expectations) > 0 {
		mmSetAuthorizationModelID.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetAuthorizationModelID method")
	}

	mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID = f
	mmSetAuthorizationModelID.mock.funcSetAuthorizationModelIDOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID.mock
}

// When sets expectation for the ACLClientInterface.SetAuthorizationModelID which will trigger the result defined by the following
// Then helper
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) When(modelID string) *ACLClientInterfaceMockSetAuthorizationModelIDExpectation {
	if mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.mock.t.Fatalf("ACLClientInterfaceMock.SetAuthorizationModelID mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetAuthorizationModelIDExpectation{
		mock:               mmSetAuthorizationModelID.mock,
		params:             &ACLClientInterfaceMockSetAuthorizationModelIDParams{modelID},
		expectationOrigins: ACLClientInterfaceMockSetAuthorizationModelIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetAuthorizationModelID.expectations = append(mmSetAuthorizationModelID.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetAuthorizationModelID return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetAuthorizationModelIDExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetAuthorizationModelIDResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetAuthorizationModelID should be invoked
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Times(n uint64) *mACLClientInterfaceMockSetAuthorizationModelID {
	if n == 0 {
		mmSetAuthorizationModelID.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetAuthorizationModelID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetAuthorizationModelID.expectedInvocations, n)
	mmSetAuthorizationModelID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetAuthorizationModelID
}

func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) invocationsDone() bool {
	if len(mmSetAuthorizationModelID.expectations) == 0 && mmSetAuthorizationModelID.defaultExpectation == nil && mmSetAuthorizationModelID.mock.funcSetAuthorizationModelID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetAuthorizationModelID.mock.afterSetAuthorizationModelIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetAuthorizationModelID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetAuthorizationModelID implements mm_acl.ACLClientInterface
func (mmSetAuthorizationModelID *ACLClientInterfaceMock) SetAuthorizationModelID(modelID string) (err error) {
	mm_atomic.AddUint64(&mmSetAuthorizationModelID.beforeSetAuthorizationModelIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetAuthorizationModelID.afterSetAuthorizationModelIDCounter, 1)

	mmSetAuthorizationModelID.t.Helper()

	if mmSetAuthorizationModelID.inspectFuncSetAuthorizationModelID != nil {
		mmSetAuthorizationModelID.inspectFuncSetAuthorizationModelID(modelID)
	}

	mm_params := ACLClientInterfaceMockSetAuthorizationModelIDParams{modelID}

	// Record call args
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.mutex.Lock()
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.callArgs = append(mmSetAuthorizationModelID.SetAuthorizationModelIDMock.callArgs, &mm_params)
	mmSetAuthorizationModelID.SetAuthorizationModelIDMock.mutex.Unlock()

	for _, e := range mmSetAuthorizationModelID.SetAuthorizationModelIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetAuthorizationModelIDParams{modelID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.modelID != nil && !minimock.Equal(*mm_want_ptrs.modelID, mm_got.modelID) {
				mmSetAuthorizationModelID.t.Errorf("ACLClientInterfaceMock.SetAuthorizationModelID got unexpected parameter modelID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.originModelID, *mm_want_ptrs.modelID, mm_got.modelID, minimock.Diff(*mm_want_ptrs.modelID, mm_got.modelID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetAuthorizationModelID.t.Errorf("ACLClientInterfaceMock.SetAuthorizationModelID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetAuthorizationModelID.SetAuthorizationModelIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetAuthorizationModelID.t.Fatal("No results are set for the ACLClientInterfaceMock.SetAuthorizationModelID")
		}
		return (*mm_results).err
	}
	if mmSetAuthorizationModelID.funcSetAuthorizationModelID != nil {
		return mmSetAuthorizationModelID.funcSetAuthorizationModelID(modelID)
	}
	mmSetAuthorizationModelID.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetAuthorizationModelID. %v", modelID)
	return
}

// SetAuthorizationModelIDAfterCounter returns a count of finished ACLClientInterfaceMock.SetAuthorizationModelID invocations
func (mmSetAuthorizationModelID *ACLClientInterfaceMock) SetAuthorizationModelIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAuthorizationModelID.afterSetAuthorizationModelIDCounter)
}

// SetAuthorizationModelIDBeforeCounter returns a count of ACLClientInterfaceMock.SetAuthorizationModelID invocations
func (mmSetAuthorizationModelID *ACLClientInterfaceMock) SetAuthorizationModelIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetAuthorizationModelID.beforeSetAuthorizationModelIDCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetAuthorizationModelID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetAuthorizationModelID *mACLClientInterfaceMockSetAuthorizationModelID) Calls() []*ACLClientInterfaceMockSetAuthorizationModelIDParams {
	mmSetAuthorizationModelID.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetAuthorizationModelIDParams, len(mmSetAuthorizationModelID.callArgs))
	copy(argCopy, mmSetAuthorizationModelID.callArgs)

	mmSetAuthorizationModelID.mutex.RUnlock()

	return argCopy
}

// MinimockSetAuthorizationModelIDDone returns true if the count of the SetAuthorizationModelID invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetAuthorizationModelIDDone() bool {
	if m.SetAuthorizationModelIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetAuthorizationModelIDMock.invocationsDone()
}

// MinimockSetAuthorizationModelIDInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetAuthorizationModelIDInspect() {
	for _, e := range m.SetAuthorizationModelIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetAuthorizationModelID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetAuthorizationModelIDCounter := mm_atomic.LoadUint64(&m.afterSetAuthorizationModelIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetAuthorizationModelIDMock.defaultExpectation != nil && afterSetAuthorizationModelIDCounter < 1 {
		if m.SetAuthorizationModelIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetAuthorizationModelID at\n%s", m.SetAuthorizationModelIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetAuthorizationModelID at\n%s with params: %#v", m.SetAuthorizationModelIDMock.defaultExpectation.expectationOrigins.origin, *m.SetAuthorizationModelIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetAuthorizationModelID != nil && afterSetAuthorizationModelIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetAuthorizationModelID at\n%s", m.funcSetAuthorizationModelIDOrigin)
	}

	if !m.SetAuthorizationModelIDMock.invocationsDone() && afterSetAuthorizationModelIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetAuthorizationModelID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetAuthorizationModelIDMock.expectedInvocations), m.SetAuthorizationModelIDMock.expectedInvocationsOrigin, afterSetAuthorizationModelIDCounter)
	}
}

type mACLClientInterfaceMockSetModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockSetModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockSetModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetModelPermissionExpectation specifies expectation struct of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockSetModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockSetModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockSetModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetModelPermissionParams contains parameters of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	user     string
	role     string
	enable   bool
}

// ACLClientInterfaceMockSetModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	user     *string
	role     *string
	enable   *bool
}

// ACLClientInterfaceMockSetModelPermissionResults contains results of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockSetModelPermissionOrigins contains origins of expectations of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originUser     string
	originRole     string
	originEnable   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Optional() *mACLClientInterfaceMockSetModelPermission {
	mmSetModelPermission.optional = true
	return mmSetModelPermission
}

// Expect sets up expected params for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Expect(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by ExpectParams functions")
	}

	mmSetModelPermission.defaultExpectation.params = &ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}
	mmSetModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetModelPermission.expectations {
		if minimock.Equal(e.params, mmSetModelPermission.defaultExpectation.params) {
			mmSetModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetModelPermission.defaultExpectation.params)
		}
	}

	return mmSetModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmSetModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectUserParam3(user string) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.user = &user
	mmSetModelPermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.role = &role
	mmSetModelPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectEnableParam5 sets up expected param enable for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectEnableParam5(enable bool) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.enable = &enable
	mmSetModelPermission.defaultExpectation.expectationOrigins.originEnable = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool)) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.inspectFuncSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetModelPermission")
	}

	mmSetModelPermission.mock.inspectFuncSetModelPermission = f

	return mmSetModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{mock: mmSetModelPermission.mock}
	}
	mmSetModelPermission.defaultExpectation.results = &ACLClientInterfaceMockSetModelPermissionResults{err}
	mmSetModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetModelPermission method
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error)) *ACLClientInterfaceMock {
	if mmSetModelPermission.defaultExpectation != nil {
		mmSetModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetModelPermission method")
	}

	if len(mmSetModelPermission.expectations) > 0 {
		mmSetModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetModelPermission method")
	}

	mmSetModelPermission.mock.funcSetModelPermission = f
	mmSetModelPermission.mock.funcSetModelPermissionOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission.mock
}

// When sets expectation for the ACLClientInterface.SetModelPermission which will trigger the result defined by the following
// Then helper
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) When(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) *ACLClientInterfaceMockSetModelPermissionExpectation {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetModelPermissionExpectation{
		mock:               mmSetModelPermission.mock,
		params:             &ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable},
		expectationOrigins: ACLClientInterfaceMockSetModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetModelPermission.expectations = append(mmSetModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetModelPermission should be invoked
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Times(n uint64) *mACLClientInterfaceMockSetModelPermission {
	if n == 0 {
		mmSetModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetModelPermission.expectedInvocations, n)
	mmSetModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission
}

func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) invocationsDone() bool {
	if len(mmSetModelPermission.expectations) == 0 && mmSetModelPermission.defaultExpectation == nil && mmSetModelPermission.mock.funcSetModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetModelPermission.mock.afterSetModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetModelPermission implements mm_acl.ACLClientInterface
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermission(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error) {
	mm_atomic.AddUint64(&mmSetModelPermission.beforeSetModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetModelPermission.afterSetModelPermissionCounter, 1)

	mmSetModelPermission.t.Helper()

	if mmSetModelPermission.inspectFuncSetModelPermission != nil {
		mmSetModelPermission.inspectFuncSetModelPermission(ctx, modelUID, user, role, enable)
	}

	mm_params := ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}

	// Record call args
	mmSetModelPermission.SetModelPermissionMock.mutex.Lock()
	mmSetModelPermission.SetModelPermissionMock.callArgs = append(mmSetModelPermission.SetModelPermissionMock.callArgs, &mm_params)
	mmSetModelPermission.SetModelPermissionMock.mutex.Unlock()

	for _, e := range mmSetModelPermission.SetModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetModelPermission.SetModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetModelPermission.SetModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.enable != nil && !minimock.Equal(*mm_want_ptrs.enable, mm_got.enable) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter enable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originEnable, *mm_want_ptrs.enable, mm_got.enable, minimock.Diff(*mm_want_ptrs.enable, mm_got.enable))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetModelPermission")
		}
		return (*mm_results).err
	}
	if mmSetModelPermission.funcSetModelPermission != nil {
		return mmSetModelPermission.funcSetModelPermission(ctx, modelUID, user, role, enable)
	}
	mmSetModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetModelPermission. %v %v %v %v %v", ctx, modelUID, user, role, enable)
	return
}

// SetModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetModelPermission invocations
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetModelPermission.afterSetModelPermissionCounter)
}

// SetModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetModelPermission invocations
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetModelPermission.beforeSetModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Calls() []*ACLClientInterfaceMockSetModelPermissionParams {
	mmSetModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetModelPermissionParams, len(mmSetModelPermission.callArgs))
	copy(argCopy, mmSetModelPermission.callArgs)

	mmSetModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetModelPermissionDone returns true if the count of the SetModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetModelPermissionDone() bool {
	if m.SetModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetModelPermissionMock.invocationsDone()
}

// MinimockSetModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetModelPermissionInspect() {
	for _, e := range m.SetModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetModelPermissionCounter := mm_atomic.LoadUint64(&m.afterSetModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetModelPermissionMock.defaultExpectation != nil && afterSetModelPermissionCounter < 1 {
		if m.SetModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s", m.SetModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s with params: %#v", m.SetModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetModelPermission != nil && afterSetModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s", m.funcSetModelPermissionOrigin)
	}

	if !m.SetModelPermissionMock.invocationsDone() && afterSetModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetModelPermissionMock.expectedInvocations), m.SetModelPermissionMock.expectedInvocationsOrigin, afterSetModelPermissionCounter)
	}
}

type mACLClientInterfaceMockSetOwner struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetOwnerExpectation
	expectations       []*ACLClientInterfaceMockSetOwnerExpectation

	callArgs []*ACLClientInterfaceMockSetOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetOwnerExpectation specifies expectation struct of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetOwnerParams
	paramPtrs          *ACLClientInterfaceMockSetOwnerParamPtrs
	expectationOrigins ACLClientInterfaceMockSetOwnerExpectationOrigins
	results            *ACLClientInterfaceMockSetOwnerResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetOwnerParams contains parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParams struct {
	ctx        context.Context
	objectType openfga.ObjectType
	objectUID  uuid.UUID
	ownerType  openfga.OwnerType
	ownerUID   uuid.UUID
}

// ACLClientInterfaceMockSetOwnerParamPtrs contains pointers to parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParamPtrs struct {
	ctx        *context.Context
	objectType *openfga.ObjectType
	objectUID  *uuid.UUID
	ownerType  *openfga.OwnerType
	ownerUID   *uuid.UUID
}

// ACLClientInterfaceMockSetOwnerResults contains results of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerResults struct {
	err error
}

// ACLClientInterfaceMockSetOwnerOrigins contains origins of expectations of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originOwnerType  string
	originOwnerUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Optional() *mACLClientInterfaceMockSetOwner {
	mmSetOwner.optional = true
	return mmSetOwner
}

// Expect sets up expected params for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Expect(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.paramPtrs != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by ExpectParams functions")
	}

	mmSetOwner.defaultExpectation.params = &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}
	mmSetOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOwner.expectations {
		if minimock.Equal(e.params, mmSetOwner.defaultExpectation.params) {
			mmSetOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOwner.defaultExpectation.params)
		}
	}

	return mmSetOwner
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectTypeParam2(objectType openfga.ObjectType) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectType = &objectType
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerTypeParam4 sets up expected param ownerType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerTypeParam4(ownerType openfga.OwnerType) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerType = &ownerType
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerUIDParam5 sets up expected param ownerUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerUIDParam5(ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Inspect(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID)) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.inspectFuncSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetOwner")
	}

	mmSetOwner.mock.inspectFuncSetOwner = f

	return mmSetOwner
}

// Return sets up results that will be returned by ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Return(err error) *ACLClientInterfaceMock {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{mock: mmSetOwner.mock}
	}
	mmSetOwner.defaultExpectation.results = &ACLClientInterfaceMockSetOwnerResults{err}
	mmSetOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// Set uses given function f to mock the ACLClientInterface.SetOwner method
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Set(f func(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetOwner.defaultExpectation != nil {
		mmSetOwner.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetOwner method")
	}

	if len(mmSetOwner.expectations) > 0 {
		mmSetOwner.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetOwner method")
	}

	mmSetOwner.mock.funcSetOwner = f
	mmSetOwner.mock.funcSetOwnerOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// When sets expectation for the ACLClientInterface.SetOwner which will trigger the result defined by the following
// Then helper
func (mmSetOwner *mACLClientInterfaceMockSetOwner) When(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) *ACLClientInterfaceMockSetOwnerExpectation {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetOwnerExpectation{
		mock:               mmSetOwner.mock,
		params:             &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID},
		expectationOrigins: ACLClientInterfaceMockSetOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOwner.expectations = append(mmSetOwner.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetOwner return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetOwnerExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetOwnerResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetOwner should be invoked
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Times(n uint64) *mACLClientInterfaceMockSetOwner {
	if n == 0 {
		mmSetOwner.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOwner.expectedInvocations, n)
	mmSetOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOwner
}

func (mmSetOwner *mACLClientInterfaceMockSetOwner) invocationsDone() bool {
	if len(mmSetOwner.expectations) == 0 && mmSetOwner.defaultExpectation == nil && mmSetOwner.mock.funcSetOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOwner.mock.afterSetOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOwner implements mm_acl.ACLClientInterface
func (mmSetOwner *ACLClientInterfaceMock) SetOwner(ctx context.Context, objectType openfga.ObjectType, objectUID uuid.UUID, ownerType openfga.OwnerType, ownerUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetOwner.beforeSetOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOwner.afterSetOwnerCounter, 1)

	mmSetOwner.t.Helper()

	if mmSetOwner.inspectFuncSetOwner != nil {
		mmSetOwner.inspectFuncSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}

	mm_params := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

	// Record call args
	mmSetOwner.SetOwnerMock.mutex.Lock()
	mmSetOwner.SetOwnerMock.callArgs = append(mmSetOwner.SetOwnerMock.callArgs, &mm_params)
	mmSetOwner.SetOwnerMock.mutex.Unlock()

	for _, e := range mmSetOwner.SetOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOwner.SetOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOwner.SetOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOwner.SetOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmSetOwner.SetOwnerMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.ownerType != nil && !minimock.Equal(*mm_want_ptrs.ownerType, mm_got.ownerType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerType, *mm_want_ptrs.ownerType, mm_got.ownerType, minimock.Diff(*mm_want_ptrs.ownerType, mm_got.ownerType))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOwner.SetOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOwner.t.Fatal("No results are set for the ACLClientInterfaceMock.SetOwner")
		}
		return (*mm_results).err
	}
	if mmSetOwner.funcSetOwner != nil {
		return mmSetOwner.funcSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}
	mmSetOwner.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetOwner. %v %v %v %v %v", ctx, objectType, objectUID, ownerType, ownerUID)
	return
}

// SetOwnerAfterCounter returns a count of finished ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.afterSetOwnerCounter)
}

// SetOwnerBeforeCounter returns a count of ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.beforeSetOwnerCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Calls() []*ACLClientInterfaceMockSetOwnerParams {
	mmSetOwner.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetOwnerParams, len(mmSetOwner.callArgs))
	copy(argCopy, mmSetOwner.callArgs)

	mmSetOwner.mutex.RUnlock()

	return argCopy
}

// MinimockSetOwnerDone returns true if the count of the SetOwner invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetOwnerDone() bool {
	if m.SetOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOwnerMock.invocationsDone()
}

// MinimockSetOwnerInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetOwnerInspect() {
	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOwnerCounter := mm_atomic.LoadUint64(&m.afterSetOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOwnerMock.defaultExpectation != nil && afterSetOwnerCounter < 1 {
		if m.SetOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.SetOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", m.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *m.SetOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOwner != nil && afterSetOwnerCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.funcSetOwnerOrigin)
	}

	if !m.SetOwnerMock.invocationsDone() && afterSetOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOwnerMock.expectedInvocations), m.SetOwnerMock.expectedInvocationsOrigin, afterSetOwnerCounter)
	}
}

type mACLClientInterfaceMockSetPublicModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPublicModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockSetPublicModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockSetPublicModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetPublicModelPermissionExpectation specifies expectation struct of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetPublicModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockSetPublicModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockSetPublicModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetPublicModelPermissionParams contains parameters of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// ACLClientInterfaceMockSetPublicModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// ACLClientInterfaceMockSetPublicModelPermissionResults contains results of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockSetPublicModelPermissionOrigins contains origins of expectations of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Optional() *mACLClientInterfaceMockSetPublicModelPermission {
	mmSetPublicModelPermission.optional = true
	return mmSetPublicModelPermission
}

// Expect sets up expected params for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Expect(ctx context.Context, modelUID uuid.UUID) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by ExpectParams functions")
	}

	mmSetPublicModelPermission.defaultExpectation.params = &ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPublicModelPermission.expectations {
		if minimock.Equal(e.params, mmSetPublicModelPermission.defaultExpectation.params) {
			mmSetPublicModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPublicModelPermission.defaultExpectation.params)
		}
	}

	return mmSetPublicModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.params != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Expect")
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetPublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPublicModelPermissionParamPtrs{}
	}
	mmSetPublicModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPublicModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.params != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Expect")
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetPublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPublicModelPermissionParamPtrs{}
	}
	mmSetPublicModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmSetPublicModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.inspectFuncSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPublicModelPermission")
	}

	mmSetPublicModelPermission.mock.inspectFuncSetPublicModelPermission = f

	return mmSetPublicModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{mock: mmSetPublicModelPermission.mock}
	}
	mmSetPublicModelPermission.defaultExpectation.results = &ACLClientInterfaceMockSetPublicModelPermissionResults{err}
	mmSetPublicModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPublicModelPermission method
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetPublicModelPermission.defaultExpectation != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPublicModelPermission method")
	}

	if len(mmSetPublicModelPermission.expectations) > 0 {
		mmSetPublicModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPublicModelPermission method")
	}

	mmSetPublicModelPermission.mock.funcSetPublicModelPermission = f
	mmSetPublicModelPermission.mock.funcSetPublicModelPermissionOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission.mock
}

// When sets expectation for the ACLClientInterface.SetPublicModelPermission which will trigger the result defined by the following
// Then helper
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) When(ctx context.Context, modelUID uuid.UUID) *ACLClientInterfaceMockSetPublicModelPermissionExpectation {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPublicModelPermissionExpectation{
		mock:               mmSetPublicModelPermission.mock,
		params:             &ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID},
		expectationOrigins: ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPublicModelPermission.expectations = append(mmSetPublicModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPublicModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPublicModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPublicModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPublicModelPermission should be invoked
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Times(n uint64) *mACLClientInterfaceMockSetPublicModelPermission {
	if n == 0 {
		mmSetPublicModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPublicModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPublicModelPermission.expectedInvocations, n)
	mmSetPublicModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission
}

func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) invocationsDone() bool {
	if len(mmSetPublicModelPermission.expectations) == 0 && mmSetPublicModelPermission.defaultExpectation == nil && mmSetPublicModelPermission.mock.funcSetPublicModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPublicModelPermission.mock.afterSetPublicModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPublicModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPublicModelPermission implements mm_acl.ACLClientInterface
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermission(ctx context.Context, modelUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetPublicModelPermission.beforeSetPublicModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPublicModelPermission.afterSetPublicModelPermissionCounter, 1)

	mmSetPublicModelPermission.t.Helper()

	if mmSetPublicModelPermission.inspectFuncSetPublicModelPermission != nil {
		mmSetPublicModelPermission.inspectFuncSetPublicModelPermission(ctx, modelUID)
	}

	mm_params := ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}

	// Record call args
	mmSetPublicModelPermission.SetPublicModelPermissionMock.mutex.Lock()
	mmSetPublicModelPermission.SetPublicModelPermissionMock.callArgs = append(mmSetPublicModelPermission.SetPublicModelPermissionMock.callArgs, &mm_params)
	mmSetPublicModelPermission.SetPublicModelPermissionMock.mutex.Unlock()

	for _, e := range mmSetPublicModelPermission.SetPublicModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPublicModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPublicModelPermission")
		}
		return (*mm_results).err
	}
	if mmSetPublicModelPermission.funcSetPublicModelPermission != nil {
		return mmSetPublicModelPermission.funcSetPublicModelPermission(ctx, modelUID)
	}
	mmSetPublicModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPublicModelPermission. %v %v", ctx, modelUID)
	return
}

// SetPublicModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetPublicModelPermission invocations
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPublicModelPermission.afterSetPublicModelPermissionCounter)
}

// SetPublicModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetPublicModelPermission invocations
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPublicModelPermission.beforeSetPublicModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPublicModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Calls() []*ACLClientInterfaceMockSetPublicModelPermissionParams {
	mmSetPublicModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPublicModelPermissionParams, len(mmSetPublicModelPermission.callArgs))
	copy(argCopy, mmSetPublicModelPermission.callArgs)

	mmSetPublicModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetPublicModelPermissionDone returns true if the count of the SetPublicModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPublicModelPermissionDone() bool {
	if m.SetPublicModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPublicModelPermissionMock.invocationsDone()
}

// MinimockSetPublicModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPublicModelPermissionInspect() {
	for _, e := range m.SetPublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPublicModelPermissionCounter := mm_atomic.LoadUint64(&m.afterSetPublicModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPublicModelPermissionMock.defaultExpectation != nil && afterSetPublicModelPermissionCounter < 1 {
		if m.SetPublicModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s", m.SetPublicModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s with params: %#v", m.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetPublicModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPublicModelPermission != nil && afterSetPublicModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s", m.funcSetPublicModelPermissionOrigin)
	}

	if !m.SetPublicModelPermissionMock.invocationsDone() && afterSetPublicModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPublicModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPublicModelPermissionMock.expectedInvocations), m.SetPublicModelPermissionMock.expectedInvocationsOrigin, afterSetPublicModelPermissionCounter)
	}
}

type mACLClientInterfaceMockSetStoreID struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetStoreIDExpectation
	expectations       []*ACLClientInterfaceMockSetStoreIDExpectation

	callArgs []*ACLClientInterfaceMockSetStoreIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetStoreIDExpectation specifies expectation struct of the ACLClientInterface.SetStoreID
type ACLClientInterfaceMockSetStoreIDExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetStoreIDParams
	paramPtrs          *ACLClientInterfaceMockSetStoreIDParamPtrs
	expectationOrigins ACLClientInterfaceMockSetStoreIDExpectationOrigins
	results            *ACLClientInterfaceMockSetStoreIDResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetStoreIDParams contains parameters of the ACLClientInterface.SetStoreID
type ACLClientInterfaceMockSetStoreIDParams struct {
	storeID string
}

// ACLClientInterfaceMockSetStoreIDParamPtrs contains pointers to parameters of the ACLClientInterface.SetStoreID
type ACLClientInterfaceMockSetStoreIDParamPtrs struct {
	storeID *string
}

// ACLClientInterfaceMockSetStoreIDResults contains results of the ACLClientInterface.SetStoreID
type ACLClientInterfaceMockSetStoreIDResults struct {
	err error
}

// ACLClientInterfaceMockSetStoreIDOrigins contains origins of expectations of the ACLClientInterface.SetStoreID
type ACLClientInterfaceMockSetStoreIDExpectationOrigins struct {
	origin        string
	originStoreID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Optional() *mACLClientInterfaceMockSetStoreID {
	mmSetStoreID.optional = true
	return mmSetStoreID
}

// Expect sets up expected params for ACLClientInterface.SetStoreID
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Expect(storeID string) *mACLClientInterfaceMockSetStoreID {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientInterfaceMockSetStoreIDExpectation{}
	}

	if mmSetStoreID.defaultExpectation.paramPtrs != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by ExpectParams functions")
	}

	mmSetStoreID.defaultExpectation.params = &ACLClientInterfaceMockSetStoreIDParams{storeID}
	mmSetStoreID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetStoreID.expectations {
		if minimock.Equal(e.params, mmSetStoreID.defaultExpectation.params) {
			mmSetStoreID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStoreID.defaultExpectation.params)
		}
	}

	return mmSetStoreID
}

// ExpectStoreIDParam1 sets up expected param storeID for ACLClientInterface.SetStoreID
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) ExpectStoreIDParam1(storeID string) *mACLClientInterfaceMockSetStoreID {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientInterfaceMockSetStoreIDExpectation{}
	}

	if mmSetStoreID.defaultExpectation.params != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by Expect")
	}

	if mmSetStoreID.defaultExpectation.paramPtrs == nil {
		mmSetStoreID.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetStoreIDParamPtrs{}
	}
	mmSetStoreID.defaultExpectation.paramPtrs.storeID = &storeID
	mmSetStoreID.defaultExpectation.expectationOrigins.originStoreID = minimock.CallerInfo(1)

	return mmSetStoreID
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetStoreID
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Inspect(f func(storeID string)) *mACLClientInterfaceMockSetStoreID {
	if mmSetStoreID.mock.inspectFuncSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetStoreID")
	}

	mmSetStoreID.mock.inspectFuncSetStoreID = f

	return mmSetStoreID
}

// Return sets up results that will be returned by ACLClientInterface.SetStoreID
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Return(err error) *ACLClientInterfaceMock {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by Set")
	}

	if mmSetStoreID.defaultExpectation == nil {
		mmSetStoreID.defaultExpectation = &ACLClientInterfaceMockSetStoreIDExpectation{mock: mmSetStoreID.mock}
	}
	mmSetStoreID.defaultExpectation.results = &ACLClientInterfaceMockSetStoreIDResults{err}
	mmSetStoreID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetStoreID.mock
}

// Set uses given function f to mock the ACLClientInterface.SetStoreID method
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Set(f func(storeID string) (err error)) *ACLClientInterfaceMock {
	if mmSetStoreID.defaultExpectation != nil {
		mmSetStoreID.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetStoreID method")
	}

	if len(mmSetStoreID.expectations) > 0 {
		mmSetStoreID.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetStoreID method")
	}

	mmSetStoreID.mock.funcSetStoreID = f
	mmSetStoreID.mock.funcSetStoreIDOrigin = minimock.CallerInfo(1)
	return mmSetStoreID.mock
}

// When sets expectation for the ACLClientInterface.SetStoreID which will trigger the result defined by the following
// Then helper
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) When(storeID string) *ACLClientInterfaceMockSetStoreIDExpectation {
	if mmSetStoreID.mock.funcSetStoreID != nil {
		mmSetStoreID.mock.t.Fatalf("ACLClientInterfaceMock.SetStoreID mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetStoreIDExpectation{
		mock:               mmSetStoreID.mock,
		params:             &ACLClientInterfaceMockSetStoreIDParams{storeID},
		expectationOrigins: ACLClientInterfaceMockSetStoreIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetStoreID.expectations = append(mmSetStoreID.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetStoreID return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetStoreIDExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetStoreIDResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetStoreID should be invoked
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Times(n uint64) *mACLClientInterfaceMockSetStoreID {
	if n == 0 {
		mmSetStoreID.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetStoreID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStoreID.expectedInvocations, n)
	mmSetStoreID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetStoreID
}

func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) invocationsDone() bool {
	if len(mmSetStoreID.expectations) == 0 && mmSetStoreID.defaultExpectation == nil && mmSetStoreID.mock.funcSetStoreID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStoreID.mock.afterSetStoreIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStoreID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStoreID implements mm_acl.ACLClientInterface
func (mmSetStoreID *ACLClientInterfaceMock) SetStoreID(storeID string) (err error) {
	mm_atomic.AddUint64(&mmSetStoreID.beforeSetStoreIDCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStoreID.afterSetStoreIDCounter, 1)

	mmSetStoreID.t.Helper()

	if mmSetStoreID.inspectFuncSetStoreID != nil {
		mmSetStoreID.inspectFuncSetStoreID(storeID)
	}

	mm_params := ACLClientInterfaceMockSetStoreIDParams{storeID}

	// Record call args
	mmSetStoreID.SetStoreIDMock.mutex.Lock()
	mmSetStoreID.SetStoreIDMock.callArgs = append(mmSetStoreID.SetStoreIDMock.callArgs, &mm_params)
	mmSetStoreID.SetStoreIDMock.mutex.Unlock()

	for _, e := range mmSetStoreID.SetStoreIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStoreID.SetStoreIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStoreID.SetStoreIDMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStoreID.SetStoreIDMock.defaultExpectation.params
		mm_want_ptrs := mmSetStoreID.SetStoreIDMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetStoreIDParams{storeID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.storeID != nil && !minimock.Equal(*mm_want_ptrs.storeID, mm_got.storeID) {
				mmSetStoreID.t.Errorf("ACLClientInterfaceMock.SetStoreID got unexpected parameter storeID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetStoreID.SetStoreIDMock.defaultExpectation.expectationOrigins.originStoreID, *mm_want_ptrs.storeID, mm_got.storeID, minimock.Diff(*mm_want_ptrs.storeID, mm_got.storeID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStoreID.t.Errorf("ACLClientInterfaceMock.SetStoreID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetStoreID.SetStoreIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStoreID.SetStoreIDMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStoreID.t.Fatal("No results are set for the ACLClientInterfaceMock.SetStoreID")
		}
		return (*mm_results).err
	}
	if mmSetStoreID.funcSetStoreID != nil {
		return mmSetStoreID.funcSetStoreID(storeID)
	}
	mmSetStoreID.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetStoreID. %v", storeID)
	return
}

// SetStoreIDAfterCounter returns a count of finished ACLClientInterfaceMock.SetStoreID invocations
func (mmSetStoreID *ACLClientInterfaceMock) SetStoreIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStoreID.afterSetStoreIDCounter)
}

// SetStoreIDBeforeCounter returns a count of ACLClientInterfaceMock.SetStoreID invocations
func (mmSetStoreID *ACLClientInterfaceMock) SetStoreIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStoreID.beforeSetStoreIDCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetStoreID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStoreID *mACLClientInterfaceMockSetStoreID) Calls() []*ACLClientInterfaceMockSetStoreIDParams {
	mmSetStoreID.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetStoreIDParams, len(mmSetStoreID.callArgs))
	copy(argCopy, mmSetStoreID.callArgs)

	mmSetStoreID.mutex.RUnlock()

	return argCopy
}

// MinimockSetStoreIDDone returns true if the count of the SetStoreID invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetStoreIDDone() bool {
	if m.SetStoreIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStoreIDMock.invocationsDone()
}

// MinimockSetStoreIDInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetStoreIDInspect() {
	for _, e := range m.SetStoreIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetStoreID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetStoreIDCounter := mm_atomic.LoadUint64(&m.afterSetStoreIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStoreIDMock.defaultExpectation != nil && afterSetStoreIDCounter < 1 {
		if m.SetStoreIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetStoreID at\n%s", m.SetStoreIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetStoreID at\n%s with params: %#v", m.SetStoreIDMock.defaultExpectation.expectationOrigins.origin, *m.SetStoreIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStoreID != nil && afterSetStoreIDCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetStoreID at\n%s", m.funcSetStoreIDOrigin)
	}

	if !m.SetStoreIDMock.invocationsDone() && afterSetStoreIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetStoreID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetStoreIDMock.expectedInvocations), m.SetStoreIDMock.expectedInvocationsOrigin, afterSetStoreIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ACLClientInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPermissionInspect()

			m.MinimockCheckPermissionByUserInspect()

			m.MinimockCheckPublicExecutableInspect()

			m.MinimockCloseInspect()

			m.MinimockDeleteModelPermissionInspect()

			m.MinimockDeletePublicModelPermissionInspect()

			m.MinimockGetAuthorizationModelIDInspect()

			m.MinimockGetStoreIDInspect()

			m.MinimockListPermissionsInspect()

			m.MinimockPurgeInspect()

			m.MinimockSDKClientInspect()

			m.MinimockSetAuthorizationModelIDInspect()

			m.MinimockSetModelPermissionInspect()

			m.MinimockSetOwnerInspect()

			m.MinimockSetPublicModelPermissionInspect()

			m.MinimockSetStoreIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ACLClientInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ACLClientInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPermissionDone() &&
		m.MinimockCheckPermissionByUserDone() &&
		m.MinimockCheckPublicExecutableDone() &&
		m.MinimockCloseDone() &&
		m.MinimockDeleteModelPermissionDone() &&
		m.MinimockDeletePublicModelPermissionDone() &&
		m.MinimockGetAuthorizationModelIDDone() &&
		m.MinimockGetStoreIDDone() &&
		m.MinimockListPermissionsDone() &&
		m.MinimockPurgeDone() &&
		m.MinimockSDKClientDone() &&
		m.MinimockSetAuthorizationModelIDDone() &&
		m.MinimockSetModelPermissionDone() &&
		m.MinimockSetOwnerDone() &&
		m.MinimockSetPublicModelPermissionDone() &&
		m.MinimockSetStoreIDDone()
}
