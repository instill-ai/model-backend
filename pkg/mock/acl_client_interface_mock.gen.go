// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gofrs/uuid"
	"github.com/gojuno/minimock/v3"
)

// ACLClientInterfaceMock implements mm_acl.ACLClientInterface
type ACLClientInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheckPermission          func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)
	funcCheckPermissionOrigin    string
	inspectFuncCheckPermission   func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)
	afterCheckPermissionCounter  uint64
	beforeCheckPermissionCounter uint64
	CheckPermissionMock          mACLClientInterfaceMockCheckPermission

	funcCheckPublicExecutable          func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)
	funcCheckPublicExecutableOrigin    string
	inspectFuncCheckPublicExecutable   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterCheckPublicExecutableCounter  uint64
	beforeCheckPublicExecutableCounter uint64
	CheckPublicExecutableMock          mACLClientInterfaceMockCheckPublicExecutable

	funcDeleteModelPermission          func(ctx context.Context, modelUID uuid.UUID, user string) (err error)
	funcDeleteModelPermissionOrigin    string
	inspectFuncDeleteModelPermission   func(ctx context.Context, modelUID uuid.UUID, user string)
	afterDeleteModelPermissionCounter  uint64
	beforeDeleteModelPermissionCounter uint64
	DeleteModelPermissionMock          mACLClientInterfaceMockDeleteModelPermission

	funcDeletePublicModelPermission          func(ctx context.Context, modelUID uuid.UUID) (err error)
	funcDeletePublicModelPermissionOrigin    string
	inspectFuncDeletePublicModelPermission   func(ctx context.Context, modelUID uuid.UUID)
	afterDeletePublicModelPermissionCounter  uint64
	beforeDeletePublicModelPermissionCounter uint64
	DeletePublicModelPermissionMock          mACLClientInterfaceMockDeletePublicModelPermission

	funcListPermissions          func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)
	funcListPermissionsOrigin    string
	inspectFuncListPermissions   func(ctx context.Context, objectType string, role string, isPublic bool)
	afterListPermissionsCounter  uint64
	beforeListPermissionsCounter uint64
	ListPermissionsMock          mACLClientInterfaceMockListPermissions

	funcPurge          func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)
	funcPurgeOrigin    string
	inspectFuncPurge   func(ctx context.Context, objectType string, objectUID uuid.UUID)
	afterPurgeCounter  uint64
	beforePurgeCounter uint64
	PurgeMock          mACLClientInterfaceMockPurge

	funcSetModelPermission          func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error)
	funcSetModelPermissionOrigin    string
	inspectFuncSetModelPermission   func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool)
	afterSetModelPermissionCounter  uint64
	beforeSetModelPermissionCounter uint64
	SetModelPermissionMock          mACLClientInterfaceMockSetModelPermission

	funcSetOwner          func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)
	funcSetOwnerOrigin    string
	inspectFuncSetOwner   func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)
	afterSetOwnerCounter  uint64
	beforeSetOwnerCounter uint64
	SetOwnerMock          mACLClientInterfaceMockSetOwner

	funcSetPublicModelPermission          func(ctx context.Context, modelUID uuid.UUID) (err error)
	funcSetPublicModelPermissionOrigin    string
	inspectFuncSetPublicModelPermission   func(ctx context.Context, modelUID uuid.UUID)
	afterSetPublicModelPermissionCounter  uint64
	beforeSetPublicModelPermissionCounter uint64
	SetPublicModelPermissionMock          mACLClientInterfaceMockSetPublicModelPermission
}

// NewACLClientInterfaceMock returns a mock for mm_acl.ACLClientInterface
func NewACLClientInterfaceMock(t minimock.Tester) *ACLClientInterfaceMock {
	m := &ACLClientInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckPermissionMock = mACLClientInterfaceMockCheckPermission{mock: m}
	m.CheckPermissionMock.callArgs = []*ACLClientInterfaceMockCheckPermissionParams{}

	m.CheckPublicExecutableMock = mACLClientInterfaceMockCheckPublicExecutable{mock: m}
	m.CheckPublicExecutableMock.callArgs = []*ACLClientInterfaceMockCheckPublicExecutableParams{}

	m.DeleteModelPermissionMock = mACLClientInterfaceMockDeleteModelPermission{mock: m}
	m.DeleteModelPermissionMock.callArgs = []*ACLClientInterfaceMockDeleteModelPermissionParams{}

	m.DeletePublicModelPermissionMock = mACLClientInterfaceMockDeletePublicModelPermission{mock: m}
	m.DeletePublicModelPermissionMock.callArgs = []*ACLClientInterfaceMockDeletePublicModelPermissionParams{}

	m.ListPermissionsMock = mACLClientInterfaceMockListPermissions{mock: m}
	m.ListPermissionsMock.callArgs = []*ACLClientInterfaceMockListPermissionsParams{}

	m.PurgeMock = mACLClientInterfaceMockPurge{mock: m}
	m.PurgeMock.callArgs = []*ACLClientInterfaceMockPurgeParams{}

	m.SetModelPermissionMock = mACLClientInterfaceMockSetModelPermission{mock: m}
	m.SetModelPermissionMock.callArgs = []*ACLClientInterfaceMockSetModelPermissionParams{}

	m.SetOwnerMock = mACLClientInterfaceMockSetOwner{mock: m}
	m.SetOwnerMock.callArgs = []*ACLClientInterfaceMockSetOwnerParams{}

	m.SetPublicModelPermissionMock = mACLClientInterfaceMockSetPublicModelPermission{mock: m}
	m.SetPublicModelPermissionMock.callArgs = []*ACLClientInterfaceMockSetPublicModelPermissionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mACLClientInterfaceMockCheckPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPermissionExpectation
	expectations       []*ACLClientInterfaceMockCheckPermissionExpectation

	callArgs []*ACLClientInterfaceMockCheckPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPermissionExpectation specifies expectation struct of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPermissionParams
	paramPtrs          *ACLClientInterfaceMockCheckPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPermissionExpectationOrigins
	results            *ACLClientInterfaceMockCheckPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPermissionParams contains parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	role       string
}

// ACLClientInterfaceMockCheckPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	role       *string
}

// ACLClientInterfaceMockCheckPermissionResults contains results of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPermissionOrigins contains origins of expectations of the ACLClientInterface.CheckPermission
type ACLClientInterfaceMockCheckPermissionExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originRole       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Optional() *mACLClientInterfaceMockCheckPermission {
	mmCheckPermission.optional = true
	return mmCheckPermission
}

// Expect sets up expected params for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.paramPtrs != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by ExpectParams functions")
	}

	mmCheckPermission.defaultExpectation.params = &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}
	mmCheckPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPermission.expectations {
		if minimock.Equal(e.params, mmCheckPermission.defaultExpectation.params) {
			mmCheckPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPermission.defaultExpectation.params)
		}
	}

	return mmCheckPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPermission.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{}
	}

	if mmCheckPermission.defaultExpectation.params != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Expect")
	}

	if mmCheckPermission.defaultExpectation.paramPtrs == nil {
		mmCheckPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPermissionParamPtrs{}
	}
	mmCheckPermission.defaultExpectation.paramPtrs.role = &role
	mmCheckPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmCheckPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string)) *mACLClientInterfaceMockCheckPermission {
	if mmCheckPermission.mock.inspectFuncCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPermission")
	}

	mmCheckPermission.mock.inspectFuncCheckPermission = f

	return mmCheckPermission
}

// Return sets up results that will be returned by ACLClientInterface.CheckPermission
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	if mmCheckPermission.defaultExpectation == nil {
		mmCheckPermission.defaultExpectation = &ACLClientInterfaceMockCheckPermissionExpectation{mock: mmCheckPermission.mock}
	}
	mmCheckPermission.defaultExpectation.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	mmCheckPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPermission method
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPermission.defaultExpectation != nil {
		mmCheckPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPermission method")
	}

	if len(mmCheckPermission.expectations) > 0 {
		mmCheckPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPermission method")
	}

	mmCheckPermission.mock.funcCheckPermission = f
	mmCheckPermission.mock.funcCheckPermissionOrigin = minimock.CallerInfo(1)
	return mmCheckPermission.mock
}

// When sets expectation for the ACLClientInterface.CheckPermission which will trigger the result defined by the following
// Then helper
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) When(ctx context.Context, objectType string, objectUID uuid.UUID, role string) *ACLClientInterfaceMockCheckPermissionExpectation {
	if mmCheckPermission.mock.funcCheckPermission != nil {
		mmCheckPermission.mock.t.Fatalf("ACLClientInterfaceMock.CheckPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPermissionExpectation{
		mock:               mmCheckPermission.mock,
		params:             &ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role},
		expectationOrigins: ACLClientInterfaceMockCheckPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPermission.expectations = append(mmCheckPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPermissionExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPermissionResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPermission should be invoked
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Times(n uint64) *mACLClientInterfaceMockCheckPermission {
	if n == 0 {
		mmCheckPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPermission.expectedInvocations, n)
	mmCheckPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPermission
}

func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) invocationsDone() bool {
	if len(mmCheckPermission.expectations) == 0 && mmCheckPermission.defaultExpectation == nil && mmCheckPermission.mock.funcCheckPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPermission.mock.afterCheckPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPermission implements mm_acl.ACLClientInterface
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermission(ctx context.Context, objectType string, objectUID uuid.UUID, role string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPermission.beforeCheckPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPermission.afterCheckPermissionCounter, 1)

	mmCheckPermission.t.Helper()

	if mmCheckPermission.inspectFuncCheckPermission != nil {
		mmCheckPermission.inspectFuncCheckPermission(ctx, objectType, objectUID, role)
	}

	mm_params := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

	// Record call args
	mmCheckPermission.CheckPermissionMock.mutex.Lock()
	mmCheckPermission.CheckPermissionMock.callArgs = append(mmCheckPermission.CheckPermissionMock.callArgs, &mm_params)
	mmCheckPermission.CheckPermissionMock.mutex.Unlock()

	for _, e := range mmCheckPermission.CheckPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPermission.CheckPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPermission.CheckPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPermission.CheckPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPermission.CheckPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPermissionParams{ctx, objectType, objectUID, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPermission.t.Errorf("ACLClientInterfaceMock.CheckPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPermission.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPermission.CheckPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPermission")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPermission.funcCheckPermission != nil {
		return mmCheckPermission.funcCheckPermission(ctx, objectType, objectUID, role)
	}
	mmCheckPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPermission. %v %v %v %v", ctx, objectType, objectUID, role)
	return
}

// CheckPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.afterCheckPermissionCounter)
}

// CheckPermissionBeforeCounter returns a count of ACLClientInterfaceMock.CheckPermission invocations
func (mmCheckPermission *ACLClientInterfaceMock) CheckPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPermission.beforeCheckPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPermission *mACLClientInterfaceMockCheckPermission) Calls() []*ACLClientInterfaceMockCheckPermissionParams {
	mmCheckPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPermissionParams, len(mmCheckPermission.callArgs))
	copy(argCopy, mmCheckPermission.callArgs)

	mmCheckPermission.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPermissionDone returns true if the count of the CheckPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPermissionDone() bool {
	if m.CheckPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPermissionMock.invocationsDone()
}

// MinimockCheckPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPermissionInspect() {
	for _, e := range m.CheckPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPermissionCounter := mm_atomic.LoadUint64(&m.afterCheckPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPermissionMock.defaultExpectation != nil && afterCheckPermissionCounter < 1 {
		if m.CheckPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.CheckPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s with params: %#v", m.CheckPermissionMock.defaultExpectation.expectationOrigins.origin, *m.CheckPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPermission != nil && afterCheckPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPermission at\n%s", m.funcCheckPermissionOrigin)
	}

	if !m.CheckPermissionMock.invocationsDone() && afterCheckPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPermissionMock.expectedInvocations), m.CheckPermissionMock.expectedInvocationsOrigin, afterCheckPermissionCounter)
	}
}

type mACLClientInterfaceMockCheckPublicExecutable struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockCheckPublicExecutableExpectation
	expectations       []*ACLClientInterfaceMockCheckPublicExecutableExpectation

	callArgs []*ACLClientInterfaceMockCheckPublicExecutableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockCheckPublicExecutableExpectation specifies expectation struct of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockCheckPublicExecutableParams
	paramPtrs          *ACLClientInterfaceMockCheckPublicExecutableParamPtrs
	expectationOrigins ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins
	results            *ACLClientInterfaceMockCheckPublicExecutableResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockCheckPublicExecutableParams contains parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableParamPtrs contains pointers to parameters of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockCheckPublicExecutableResults contains results of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableResults struct {
	b1  bool
	err error
}

// ACLClientInterfaceMockCheckPublicExecutableOrigins contains origins of expectations of the ACLClientInterface.CheckPublicExecutable
type ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Optional() *mACLClientInterfaceMockCheckPublicExecutable {
	mmCheckPublicExecutable.optional = true
	return mmCheckPublicExecutable
}

// Expect sets up expected params for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by ExpectParams functions")
	}

	mmCheckPublicExecutable.defaultExpectation.params = &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckPublicExecutable.expectations {
		if minimock.Equal(e.params, mmCheckPublicExecutable.defaultExpectation.params) {
			mmCheckPublicExecutable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckPublicExecutable.defaultExpectation.params)
		}
	}

	return mmCheckPublicExecutable
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectType = &objectType
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{}
	}

	if mmCheckPublicExecutable.defaultExpectation.params != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Expect")
	}

	if mmCheckPublicExecutable.defaultExpectation.paramPtrs == nil {
		mmCheckPublicExecutable.defaultExpectation.paramPtrs = &ACLClientInterfaceMockCheckPublicExecutableParamPtrs{}
	}
	mmCheckPublicExecutable.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmCheckPublicExecutable.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmCheckPublicExecutable
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockCheckPublicExecutable {
	if mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.CheckPublicExecutable")
	}

	mmCheckPublicExecutable.mock.inspectFuncCheckPublicExecutable = f

	return mmCheckPublicExecutable
}

// Return sets up results that will be returned by ACLClientInterface.CheckPublicExecutable
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Return(b1 bool, err error) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	if mmCheckPublicExecutable.defaultExpectation == nil {
		mmCheckPublicExecutable.defaultExpectation = &ACLClientInterfaceMockCheckPublicExecutableExpectation{mock: mmCheckPublicExecutable.mock}
	}
	mmCheckPublicExecutable.defaultExpectation.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	mmCheckPublicExecutable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// Set uses given function f to mock the ACLClientInterface.CheckPublicExecutable method
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error)) *ACLClientInterfaceMock {
	if mmCheckPublicExecutable.defaultExpectation != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	if len(mmCheckPublicExecutable.expectations) > 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.CheckPublicExecutable method")
	}

	mmCheckPublicExecutable.mock.funcCheckPublicExecutable = f
	mmCheckPublicExecutable.mock.funcCheckPublicExecutableOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable.mock
}

// When sets expectation for the ACLClientInterface.CheckPublicExecutable which will trigger the result defined by the following
// Then helper
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockCheckPublicExecutableExpectation {
	if mmCheckPublicExecutable.mock.funcCheckPublicExecutable != nil {
		mmCheckPublicExecutable.mock.t.Fatalf("ACLClientInterfaceMock.CheckPublicExecutable mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockCheckPublicExecutableExpectation{
		mock:               mmCheckPublicExecutable.mock,
		params:             &ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockCheckPublicExecutableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckPublicExecutable.expectations = append(mmCheckPublicExecutable.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.CheckPublicExecutable return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockCheckPublicExecutableExpectation) Then(b1 bool, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockCheckPublicExecutableResults{b1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.CheckPublicExecutable should be invoked
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Times(n uint64) *mACLClientInterfaceMockCheckPublicExecutable {
	if n == 0 {
		mmCheckPublicExecutable.mock.t.Fatalf("Times of ACLClientInterfaceMock.CheckPublicExecutable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckPublicExecutable.expectedInvocations, n)
	mmCheckPublicExecutable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckPublicExecutable
}

func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) invocationsDone() bool {
	if len(mmCheckPublicExecutable.expectations) == 0 && mmCheckPublicExecutable.defaultExpectation == nil && mmCheckPublicExecutable.mock.funcCheckPublicExecutable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.mock.afterCheckPublicExecutableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckPublicExecutable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CheckPublicExecutable implements mm_acl.ACLClientInterface
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutable(ctx context.Context, objectType string, objectUID uuid.UUID) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter, 1)

	mmCheckPublicExecutable.t.Helper()

	if mmCheckPublicExecutable.inspectFuncCheckPublicExecutable != nil {
		mmCheckPublicExecutable.inspectFuncCheckPublicExecutable(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

	// Record call args
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Lock()
	mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs = append(mmCheckPublicExecutable.CheckPublicExecutableMock.callArgs, &mm_params)
	mmCheckPublicExecutable.CheckPublicExecutableMock.mutex.Unlock()

	for _, e := range mmCheckPublicExecutable.CheckPublicExecutableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.params
		mm_want_ptrs := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockCheckPublicExecutableParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckPublicExecutable.t.Errorf("ACLClientInterfaceMock.CheckPublicExecutable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckPublicExecutable.CheckPublicExecutableMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckPublicExecutable.t.Fatal("No results are set for the ACLClientInterfaceMock.CheckPublicExecutable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckPublicExecutable.funcCheckPublicExecutable != nil {
		return mmCheckPublicExecutable.funcCheckPublicExecutable(ctx, objectType, objectUID)
	}
	mmCheckPublicExecutable.t.Fatalf("Unexpected call to ACLClientInterfaceMock.CheckPublicExecutable. %v %v %v", ctx, objectType, objectUID)
	return
}

// CheckPublicExecutableAfterCounter returns a count of finished ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.afterCheckPublicExecutableCounter)
}

// CheckPublicExecutableBeforeCounter returns a count of ACLClientInterfaceMock.CheckPublicExecutable invocations
func (mmCheckPublicExecutable *ACLClientInterfaceMock) CheckPublicExecutableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckPublicExecutable.beforeCheckPublicExecutableCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.CheckPublicExecutable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckPublicExecutable *mACLClientInterfaceMockCheckPublicExecutable) Calls() []*ACLClientInterfaceMockCheckPublicExecutableParams {
	mmCheckPublicExecutable.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockCheckPublicExecutableParams, len(mmCheckPublicExecutable.callArgs))
	copy(argCopy, mmCheckPublicExecutable.callArgs)

	mmCheckPublicExecutable.mutex.RUnlock()

	return argCopy
}

// MinimockCheckPublicExecutableDone returns true if the count of the CheckPublicExecutable invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableDone() bool {
	if m.CheckPublicExecutableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckPublicExecutableMock.invocationsDone()
}

// MinimockCheckPublicExecutableInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockCheckPublicExecutableInspect() {
	for _, e := range m.CheckPublicExecutableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckPublicExecutableCounter := mm_atomic.LoadUint64(&m.afterCheckPublicExecutableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckPublicExecutableMock.defaultExpectation != nil && afterCheckPublicExecutableCounter < 1 {
		if m.CheckPublicExecutableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.CheckPublicExecutableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s with params: %#v", m.CheckPublicExecutableMock.defaultExpectation.expectationOrigins.origin, *m.CheckPublicExecutableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckPublicExecutable != nil && afterCheckPublicExecutableCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.CheckPublicExecutable at\n%s", m.funcCheckPublicExecutableOrigin)
	}

	if !m.CheckPublicExecutableMock.invocationsDone() && afterCheckPublicExecutableCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.CheckPublicExecutable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckPublicExecutableMock.expectedInvocations), m.CheckPublicExecutableMock.expectedInvocationsOrigin, afterCheckPublicExecutableCounter)
	}
}

type mACLClientInterfaceMockDeleteModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeleteModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockDeleteModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockDeleteModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockDeleteModelPermissionExpectation specifies expectation struct of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockDeleteModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockDeleteModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockDeleteModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockDeleteModelPermissionParams contains parameters of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	user     string
}

// ACLClientInterfaceMockDeleteModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	user     *string
}

// ACLClientInterfaceMockDeleteModelPermissionResults contains results of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockDeleteModelPermissionOrigins contains origins of expectations of the ACLClientInterface.DeleteModelPermission
type ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originUser     string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Optional() *mACLClientInterfaceMockDeleteModelPermission {
	mmDeleteModelPermission.optional = true
	return mmDeleteModelPermission
}

// Expect sets up expected params for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Expect(ctx context.Context, modelUID uuid.UUID, user string) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by ExpectParams functions")
	}

	mmDeleteModelPermission.defaultExpectation.params = &ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteModelPermission.expectations {
		if minimock.Equal(e.params, mmDeleteModelPermission.defaultExpectation.params) {
			mmDeleteModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteModelPermission.defaultExpectation.params)
		}
	}

	return mmDeleteModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) ExpectUserParam3(user string) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{}
	}

	if mmDeleteModelPermission.defaultExpectation.params != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Expect")
	}

	if mmDeleteModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeleteModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeleteModelPermissionParamPtrs{}
	}
	mmDeleteModelPermission.defaultExpectation.paramPtrs.user = &user
	mmDeleteModelPermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmDeleteModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID, user string)) *mACLClientInterfaceMockDeleteModelPermission {
	if mmDeleteModelPermission.mock.inspectFuncDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeleteModelPermission")
	}

	mmDeleteModelPermission.mock.inspectFuncDeleteModelPermission = f

	return mmDeleteModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.DeleteModelPermission
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	if mmDeleteModelPermission.defaultExpectation == nil {
		mmDeleteModelPermission.defaultExpectation = &ACLClientInterfaceMockDeleteModelPermissionExpectation{mock: mmDeleteModelPermission.mock}
	}
	mmDeleteModelPermission.defaultExpectation.results = &ACLClientInterfaceMockDeleteModelPermissionResults{err}
	mmDeleteModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeleteModelPermission method
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID, user string) (err error)) *ACLClientInterfaceMock {
	if mmDeleteModelPermission.defaultExpectation != nil {
		mmDeleteModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeleteModelPermission method")
	}

	if len(mmDeleteModelPermission.expectations) > 0 {
		mmDeleteModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeleteModelPermission method")
	}

	mmDeleteModelPermission.mock.funcDeleteModelPermission = f
	mmDeleteModelPermission.mock.funcDeleteModelPermissionOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission.mock
}

// When sets expectation for the ACLClientInterface.DeleteModelPermission which will trigger the result defined by the following
// Then helper
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) When(ctx context.Context, modelUID uuid.UUID, user string) *ACLClientInterfaceMockDeleteModelPermissionExpectation {
	if mmDeleteModelPermission.mock.funcDeleteModelPermission != nil {
		mmDeleteModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeleteModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeleteModelPermissionExpectation{
		mock:               mmDeleteModelPermission.mock,
		params:             &ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user},
		expectationOrigins: ACLClientInterfaceMockDeleteModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteModelPermission.expectations = append(mmDeleteModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeleteModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeleteModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeleteModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeleteModelPermission should be invoked
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Times(n uint64) *mACLClientInterfaceMockDeleteModelPermission {
	if n == 0 {
		mmDeleteModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeleteModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteModelPermission.expectedInvocations, n)
	mmDeleteModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteModelPermission
}

func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) invocationsDone() bool {
	if len(mmDeleteModelPermission.expectations) == 0 && mmDeleteModelPermission.defaultExpectation == nil && mmDeleteModelPermission.mock.funcDeleteModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteModelPermission.mock.afterDeleteModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteModelPermission implements mm_acl.ACLClientInterface
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermission(ctx context.Context, modelUID uuid.UUID, user string) (err error) {
	mm_atomic.AddUint64(&mmDeleteModelPermission.beforeDeleteModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteModelPermission.afterDeleteModelPermissionCounter, 1)

	mmDeleteModelPermission.t.Helper()

	if mmDeleteModelPermission.inspectFuncDeleteModelPermission != nil {
		mmDeleteModelPermission.inspectFuncDeleteModelPermission(ctx, modelUID, user)
	}

	mm_params := ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}

	// Record call args
	mmDeleteModelPermission.DeleteModelPermissionMock.mutex.Lock()
	mmDeleteModelPermission.DeleteModelPermissionMock.callArgs = append(mmDeleteModelPermission.DeleteModelPermissionMock.callArgs, &mm_params)
	mmDeleteModelPermission.DeleteModelPermissionMock.mutex.Unlock()

	for _, e := range mmDeleteModelPermission.DeleteModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeleteModelPermissionParams{ctx, modelUID, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteModelPermission.t.Errorf("ACLClientInterfaceMock.DeleteModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteModelPermission.DeleteModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeleteModelPermission")
		}
		return (*mm_results).err
	}
	if mmDeleteModelPermission.funcDeleteModelPermission != nil {
		return mmDeleteModelPermission.funcDeleteModelPermission(ctx, modelUID, user)
	}
	mmDeleteModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeleteModelPermission. %v %v %v", ctx, modelUID, user)
	return
}

// DeleteModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeleteModelPermission invocations
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelPermission.afterDeleteModelPermissionCounter)
}

// DeleteModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeleteModelPermission invocations
func (mmDeleteModelPermission *ACLClientInterfaceMock) DeleteModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteModelPermission.beforeDeleteModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeleteModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteModelPermission *mACLClientInterfaceMockDeleteModelPermission) Calls() []*ACLClientInterfaceMockDeleteModelPermissionParams {
	mmDeleteModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeleteModelPermissionParams, len(mmDeleteModelPermission.callArgs))
	copy(argCopy, mmDeleteModelPermission.callArgs)

	mmDeleteModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteModelPermissionDone returns true if the count of the DeleteModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeleteModelPermissionDone() bool {
	if m.DeleteModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteModelPermissionMock.invocationsDone()
}

// MinimockDeleteModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeleteModelPermissionInspect() {
	for _, e := range m.DeleteModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteModelPermissionCounter := mm_atomic.LoadUint64(&m.afterDeleteModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteModelPermissionMock.defaultExpectation != nil && afterDeleteModelPermissionCounter < 1 {
		if m.DeleteModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s", m.DeleteModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s with params: %#v", m.DeleteModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeleteModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteModelPermission != nil && afterDeleteModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.DeleteModelPermission at\n%s", m.funcDeleteModelPermissionOrigin)
	}

	if !m.DeleteModelPermissionMock.invocationsDone() && afterDeleteModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeleteModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteModelPermissionMock.expectedInvocations), m.DeleteModelPermissionMock.expectedInvocationsOrigin, afterDeleteModelPermissionCounter)
	}
}

type mACLClientInterfaceMockDeletePublicModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockDeletePublicModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockDeletePublicModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockDeletePublicModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockDeletePublicModelPermissionExpectation specifies expectation struct of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockDeletePublicModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockDeletePublicModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockDeletePublicModelPermissionParams contains parameters of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// ACLClientInterfaceMockDeletePublicModelPermissionResults contains results of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockDeletePublicModelPermissionOrigins contains origins of expectations of the ACLClientInterface.DeletePublicModelPermission
type ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Optional() *mACLClientInterfaceMockDeletePublicModelPermission {
	mmDeletePublicModelPermission.optional = true
	return mmDeletePublicModelPermission
}

// Expect sets up expected params for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Expect(ctx context.Context, modelUID uuid.UUID) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by ExpectParams functions")
	}

	mmDeletePublicModelPermission.defaultExpectation.params = &ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeletePublicModelPermission.expectations {
		if minimock.Equal(e.params, mmDeletePublicModelPermission.defaultExpectation.params) {
			mmDeletePublicModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePublicModelPermission.defaultExpectation.params)
		}
	}

	return mmDeletePublicModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.params != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Expect")
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeletePublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs{}
	}
	mmDeletePublicModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeletePublicModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{}
	}

	if mmDeletePublicModelPermission.defaultExpectation.params != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Expect")
	}

	if mmDeletePublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmDeletePublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockDeletePublicModelPermissionParamPtrs{}
	}
	mmDeletePublicModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmDeletePublicModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmDeletePublicModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mACLClientInterfaceMockDeletePublicModelPermission {
	if mmDeletePublicModelPermission.mock.inspectFuncDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.DeletePublicModelPermission")
	}

	mmDeletePublicModelPermission.mock.inspectFuncDeletePublicModelPermission = f

	return mmDeletePublicModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.DeletePublicModelPermission
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	if mmDeletePublicModelPermission.defaultExpectation == nil {
		mmDeletePublicModelPermission.defaultExpectation = &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{mock: mmDeletePublicModelPermission.mock}
	}
	mmDeletePublicModelPermission.defaultExpectation.results = &ACLClientInterfaceMockDeletePublicModelPermissionResults{err}
	mmDeletePublicModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.DeletePublicModelPermission method
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmDeletePublicModelPermission.defaultExpectation != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.DeletePublicModelPermission method")
	}

	if len(mmDeletePublicModelPermission.expectations) > 0 {
		mmDeletePublicModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.DeletePublicModelPermission method")
	}

	mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission = f
	mmDeletePublicModelPermission.mock.funcDeletePublicModelPermissionOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission.mock
}

// When sets expectation for the ACLClientInterface.DeletePublicModelPermission which will trigger the result defined by the following
// Then helper
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) When(ctx context.Context, modelUID uuid.UUID) *ACLClientInterfaceMockDeletePublicModelPermissionExpectation {
	if mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.DeletePublicModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockDeletePublicModelPermissionExpectation{
		mock:               mmDeletePublicModelPermission.mock,
		params:             &ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID},
		expectationOrigins: ACLClientInterfaceMockDeletePublicModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeletePublicModelPermission.expectations = append(mmDeletePublicModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.DeletePublicModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockDeletePublicModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockDeletePublicModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.DeletePublicModelPermission should be invoked
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Times(n uint64) *mACLClientInterfaceMockDeletePublicModelPermission {
	if n == 0 {
		mmDeletePublicModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.DeletePublicModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeletePublicModelPermission.expectedInvocations, n)
	mmDeletePublicModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeletePublicModelPermission
}

func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) invocationsDone() bool {
	if len(mmDeletePublicModelPermission.expectations) == 0 && mmDeletePublicModelPermission.defaultExpectation == nil && mmDeletePublicModelPermission.mock.funcDeletePublicModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeletePublicModelPermission.mock.afterDeletePublicModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeletePublicModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeletePublicModelPermission implements mm_acl.ACLClientInterface
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermission(ctx context.Context, modelUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeletePublicModelPermission.beforeDeletePublicModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePublicModelPermission.afterDeletePublicModelPermissionCounter, 1)

	mmDeletePublicModelPermission.t.Helper()

	if mmDeletePublicModelPermission.inspectFuncDeletePublicModelPermission != nil {
		mmDeletePublicModelPermission.inspectFuncDeletePublicModelPermission(ctx, modelUID)
	}

	mm_params := ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}

	// Record call args
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.mutex.Lock()
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.callArgs = append(mmDeletePublicModelPermission.DeletePublicModelPermissionMock.callArgs, &mm_params)
	mmDeletePublicModelPermission.DeletePublicModelPermissionMock.mutex.Unlock()

	for _, e := range mmDeletePublicModelPermission.DeletePublicModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockDeletePublicModelPermissionParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePublicModelPermission.t.Errorf("ACLClientInterfaceMock.DeletePublicModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePublicModelPermission.DeletePublicModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePublicModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.DeletePublicModelPermission")
		}
		return (*mm_results).err
	}
	if mmDeletePublicModelPermission.funcDeletePublicModelPermission != nil {
		return mmDeletePublicModelPermission.funcDeletePublicModelPermission(ctx, modelUID)
	}
	mmDeletePublicModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.DeletePublicModelPermission. %v %v", ctx, modelUID)
	return
}

// DeletePublicModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.DeletePublicModelPermission invocations
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePublicModelPermission.afterDeletePublicModelPermissionCounter)
}

// DeletePublicModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.DeletePublicModelPermission invocations
func (mmDeletePublicModelPermission *ACLClientInterfaceMock) DeletePublicModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePublicModelPermission.beforeDeletePublicModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.DeletePublicModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePublicModelPermission *mACLClientInterfaceMockDeletePublicModelPermission) Calls() []*ACLClientInterfaceMockDeletePublicModelPermissionParams {
	mmDeletePublicModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockDeletePublicModelPermissionParams, len(mmDeletePublicModelPermission.callArgs))
	copy(argCopy, mmDeletePublicModelPermission.callArgs)

	mmDeletePublicModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePublicModelPermissionDone returns true if the count of the DeletePublicModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockDeletePublicModelPermissionDone() bool {
	if m.DeletePublicModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeletePublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeletePublicModelPermissionMock.invocationsDone()
}

// MinimockDeletePublicModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockDeletePublicModelPermissionInspect() {
	for _, e := range m.DeletePublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeletePublicModelPermissionCounter := mm_atomic.LoadUint64(&m.afterDeletePublicModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePublicModelPermissionMock.defaultExpectation != nil && afterDeletePublicModelPermissionCounter < 1 {
		if m.DeletePublicModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s", m.DeletePublicModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s with params: %#v", m.DeletePublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.DeletePublicModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePublicModelPermission != nil && afterDeletePublicModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s", m.funcDeletePublicModelPermissionOrigin)
	}

	if !m.DeletePublicModelPermissionMock.invocationsDone() && afterDeletePublicModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.DeletePublicModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeletePublicModelPermissionMock.expectedInvocations), m.DeletePublicModelPermissionMock.expectedInvocationsOrigin, afterDeletePublicModelPermissionCounter)
	}
}

type mACLClientInterfaceMockListPermissions struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockListPermissionsExpectation
	expectations       []*ACLClientInterfaceMockListPermissionsExpectation

	callArgs []*ACLClientInterfaceMockListPermissionsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockListPermissionsExpectation specifies expectation struct of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockListPermissionsParams
	paramPtrs          *ACLClientInterfaceMockListPermissionsParamPtrs
	expectationOrigins ACLClientInterfaceMockListPermissionsExpectationOrigins
	results            *ACLClientInterfaceMockListPermissionsResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockListPermissionsParams contains parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParams struct {
	ctx        context.Context
	objectType string
	role       string
	isPublic   bool
}

// ACLClientInterfaceMockListPermissionsParamPtrs contains pointers to parameters of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsParamPtrs struct {
	ctx        *context.Context
	objectType *string
	role       *string
	isPublic   *bool
}

// ACLClientInterfaceMockListPermissionsResults contains results of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsResults struct {
	ua1 []uuid.UUID
	err error
}

// ACLClientInterfaceMockListPermissionsOrigins contains origins of expectations of the ACLClientInterface.ListPermissions
type ACLClientInterfaceMockListPermissionsExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originRole       string
	originIsPublic   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Optional() *mACLClientInterfaceMockListPermissions {
	mmListPermissions.optional = true
	return mmListPermissions
}

// Expect sets up expected params for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Expect(ctx context.Context, objectType string, role string, isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.paramPtrs != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by ExpectParams functions")
	}

	mmListPermissions.defaultExpectation.params = &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}
	mmListPermissions.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListPermissions.expectations {
		if minimock.Equal(e.params, mmListPermissions.defaultExpectation.params) {
			mmListPermissions.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPermissions.defaultExpectation.params)
		}
	}

	return mmListPermissions
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.ctx = &ctx
	mmListPermissions.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.objectType = &objectType
	mmListPermissions.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectRoleParam3 sets up expected param role for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectRoleParam3(role string) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.role = &role
	mmListPermissions.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmListPermissions
}

// ExpectIsPublicParam4 sets up expected param isPublic for ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) ExpectIsPublicParam4(isPublic bool) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{}
	}

	if mmListPermissions.defaultExpectation.params != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Expect")
	}

	if mmListPermissions.defaultExpectation.paramPtrs == nil {
		mmListPermissions.defaultExpectation.paramPtrs = &ACLClientInterfaceMockListPermissionsParamPtrs{}
	}
	mmListPermissions.defaultExpectation.paramPtrs.isPublic = &isPublic
	mmListPermissions.defaultExpectation.expectationOrigins.originIsPublic = minimock.CallerInfo(1)

	return mmListPermissions
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Inspect(f func(ctx context.Context, objectType string, role string, isPublic bool)) *mACLClientInterfaceMockListPermissions {
	if mmListPermissions.mock.inspectFuncListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.ListPermissions")
	}

	mmListPermissions.mock.inspectFuncListPermissions = f

	return mmListPermissions
}

// Return sets up results that will be returned by ACLClientInterface.ListPermissions
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Return(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	if mmListPermissions.defaultExpectation == nil {
		mmListPermissions.defaultExpectation = &ACLClientInterfaceMockListPermissionsExpectation{mock: mmListPermissions.mock}
	}
	mmListPermissions.defaultExpectation.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	mmListPermissions.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// Set uses given function f to mock the ACLClientInterface.ListPermissions method
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Set(f func(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error)) *ACLClientInterfaceMock {
	if mmListPermissions.defaultExpectation != nil {
		mmListPermissions.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.ListPermissions method")
	}

	if len(mmListPermissions.expectations) > 0 {
		mmListPermissions.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.ListPermissions method")
	}

	mmListPermissions.mock.funcListPermissions = f
	mmListPermissions.mock.funcListPermissionsOrigin = minimock.CallerInfo(1)
	return mmListPermissions.mock
}

// When sets expectation for the ACLClientInterface.ListPermissions which will trigger the result defined by the following
// Then helper
func (mmListPermissions *mACLClientInterfaceMockListPermissions) When(ctx context.Context, objectType string, role string, isPublic bool) *ACLClientInterfaceMockListPermissionsExpectation {
	if mmListPermissions.mock.funcListPermissions != nil {
		mmListPermissions.mock.t.Fatalf("ACLClientInterfaceMock.ListPermissions mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockListPermissionsExpectation{
		mock:               mmListPermissions.mock,
		params:             &ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic},
		expectationOrigins: ACLClientInterfaceMockListPermissionsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListPermissions.expectations = append(mmListPermissions.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.ListPermissions return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockListPermissionsExpectation) Then(ua1 []uuid.UUID, err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockListPermissionsResults{ua1, err}
	return e.mock
}

// Times sets number of times ACLClientInterface.ListPermissions should be invoked
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Times(n uint64) *mACLClientInterfaceMockListPermissions {
	if n == 0 {
		mmListPermissions.mock.t.Fatalf("Times of ACLClientInterfaceMock.ListPermissions mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPermissions.expectedInvocations, n)
	mmListPermissions.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPermissions
}

func (mmListPermissions *mACLClientInterfaceMockListPermissions) invocationsDone() bool {
	if len(mmListPermissions.expectations) == 0 && mmListPermissions.defaultExpectation == nil && mmListPermissions.mock.funcListPermissions == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPermissions.mock.afterListPermissionsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPermissions.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPermissions implements mm_acl.ACLClientInterface
func (mmListPermissions *ACLClientInterfaceMock) ListPermissions(ctx context.Context, objectType string, role string, isPublic bool) (ua1 []uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmListPermissions.beforeListPermissionsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPermissions.afterListPermissionsCounter, 1)

	mmListPermissions.t.Helper()

	if mmListPermissions.inspectFuncListPermissions != nil {
		mmListPermissions.inspectFuncListPermissions(ctx, objectType, role, isPublic)
	}

	mm_params := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

	// Record call args
	mmListPermissions.ListPermissionsMock.mutex.Lock()
	mmListPermissions.ListPermissionsMock.callArgs = append(mmListPermissions.ListPermissionsMock.callArgs, &mm_params)
	mmListPermissions.ListPermissionsMock.mutex.Unlock()

	for _, e := range mmListPermissions.ListPermissionsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListPermissions.ListPermissionsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPermissions.ListPermissionsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPermissions.ListPermissionsMock.defaultExpectation.params
		mm_want_ptrs := mmListPermissions.ListPermissionsMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockListPermissionsParams{ctx, objectType, role, isPublic}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.isPublic != nil && !minimock.Equal(*mm_want_ptrs.isPublic, mm_got.isPublic) {
				mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameter isPublic, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.originIsPublic, *mm_want_ptrs.isPublic, mm_got.isPublic, minimock.Diff(*mm_want_ptrs.isPublic, mm_got.isPublic))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPermissions.t.Errorf("ACLClientInterfaceMock.ListPermissions got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListPermissions.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPermissions.ListPermissionsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPermissions.t.Fatal("No results are set for the ACLClientInterfaceMock.ListPermissions")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListPermissions.funcListPermissions != nil {
		return mmListPermissions.funcListPermissions(ctx, objectType, role, isPublic)
	}
	mmListPermissions.t.Fatalf("Unexpected call to ACLClientInterfaceMock.ListPermissions. %v %v %v %v", ctx, objectType, role, isPublic)
	return
}

// ListPermissionsAfterCounter returns a count of finished ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.afterListPermissionsCounter)
}

// ListPermissionsBeforeCounter returns a count of ACLClientInterfaceMock.ListPermissions invocations
func (mmListPermissions *ACLClientInterfaceMock) ListPermissionsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPermissions.beforeListPermissionsCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.ListPermissions.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPermissions *mACLClientInterfaceMockListPermissions) Calls() []*ACLClientInterfaceMockListPermissionsParams {
	mmListPermissions.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockListPermissionsParams, len(mmListPermissions.callArgs))
	copy(argCopy, mmListPermissions.callArgs)

	mmListPermissions.mutex.RUnlock()

	return argCopy
}

// MinimockListPermissionsDone returns true if the count of the ListPermissions invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockListPermissionsDone() bool {
	if m.ListPermissionsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPermissionsMock.invocationsDone()
}

// MinimockListPermissionsInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockListPermissionsInspect() {
	for _, e := range m.ListPermissionsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListPermissionsCounter := mm_atomic.LoadUint64(&m.afterListPermissionsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPermissionsMock.defaultExpectation != nil && afterListPermissionsCounter < 1 {
		if m.ListPermissionsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.ListPermissionsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s with params: %#v", m.ListPermissionsMock.defaultExpectation.expectationOrigins.origin, *m.ListPermissionsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPermissions != nil && afterListPermissionsCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.ListPermissions at\n%s", m.funcListPermissionsOrigin)
	}

	if !m.ListPermissionsMock.invocationsDone() && afterListPermissionsCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.ListPermissions at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPermissionsMock.expectedInvocations), m.ListPermissionsMock.expectedInvocationsOrigin, afterListPermissionsCounter)
	}
}

type mACLClientInterfaceMockPurge struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockPurgeExpectation
	expectations       []*ACLClientInterfaceMockPurgeExpectation

	callArgs []*ACLClientInterfaceMockPurgeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockPurgeExpectation specifies expectation struct of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockPurgeParams
	paramPtrs          *ACLClientInterfaceMockPurgeParamPtrs
	expectationOrigins ACLClientInterfaceMockPurgeExpectationOrigins
	results            *ACLClientInterfaceMockPurgeResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockPurgeParams contains parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
}

// ACLClientInterfaceMockPurgeParamPtrs contains pointers to parameters of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
}

// ACLClientInterfaceMockPurgeResults contains results of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeResults struct {
	err error
}

// ACLClientInterfaceMockPurgeOrigins contains origins of expectations of the ACLClientInterface.Purge
type ACLClientInterfaceMockPurgeExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPurge *mACLClientInterfaceMockPurge) Optional() *mACLClientInterfaceMockPurge {
	mmPurge.optional = true
	return mmPurge
}

// Expect sets up expected params for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Expect(ctx context.Context, objectType string, objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.paramPtrs != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by ExpectParams functions")
	}

	mmPurge.defaultExpectation.params = &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}
	mmPurge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPurge.expectations {
		if minimock.Equal(e.params, mmPurge.defaultExpectation.params) {
			mmPurge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPurge.defaultExpectation.params)
		}
	}

	return mmPurge
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.ctx = &ctx
	mmPurge.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectType = &objectType
	mmPurge.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmPurge
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{}
	}

	if mmPurge.defaultExpectation.params != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Expect")
	}

	if mmPurge.defaultExpectation.paramPtrs == nil {
		mmPurge.defaultExpectation.paramPtrs = &ACLClientInterfaceMockPurgeParamPtrs{}
	}
	mmPurge.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmPurge.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmPurge
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID)) *mACLClientInterfaceMockPurge {
	if mmPurge.mock.inspectFuncPurge != nil {
		mmPurge.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.Purge")
	}

	mmPurge.mock.inspectFuncPurge = f

	return mmPurge
}

// Return sets up results that will be returned by ACLClientInterface.Purge
func (mmPurge *mACLClientInterfaceMockPurge) Return(err error) *ACLClientInterfaceMock {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	if mmPurge.defaultExpectation == nil {
		mmPurge.defaultExpectation = &ACLClientInterfaceMockPurgeExpectation{mock: mmPurge.mock}
	}
	mmPurge.defaultExpectation.results = &ACLClientInterfaceMockPurgeResults{err}
	mmPurge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// Set uses given function f to mock the ACLClientInterface.Purge method
func (mmPurge *mACLClientInterfaceMockPurge) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmPurge.defaultExpectation != nil {
		mmPurge.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.Purge method")
	}

	if len(mmPurge.expectations) > 0 {
		mmPurge.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.Purge method")
	}

	mmPurge.mock.funcPurge = f
	mmPurge.mock.funcPurgeOrigin = minimock.CallerInfo(1)
	return mmPurge.mock
}

// When sets expectation for the ACLClientInterface.Purge which will trigger the result defined by the following
// Then helper
func (mmPurge *mACLClientInterfaceMockPurge) When(ctx context.Context, objectType string, objectUID uuid.UUID) *ACLClientInterfaceMockPurgeExpectation {
	if mmPurge.mock.funcPurge != nil {
		mmPurge.mock.t.Fatalf("ACLClientInterfaceMock.Purge mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockPurgeExpectation{
		mock:               mmPurge.mock,
		params:             &ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID},
		expectationOrigins: ACLClientInterfaceMockPurgeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPurge.expectations = append(mmPurge.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.Purge return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockPurgeExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockPurgeResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.Purge should be invoked
func (mmPurge *mACLClientInterfaceMockPurge) Times(n uint64) *mACLClientInterfaceMockPurge {
	if n == 0 {
		mmPurge.mock.t.Fatalf("Times of ACLClientInterfaceMock.Purge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPurge.expectedInvocations, n)
	mmPurge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPurge
}

func (mmPurge *mACLClientInterfaceMockPurge) invocationsDone() bool {
	if len(mmPurge.expectations) == 0 && mmPurge.defaultExpectation == nil && mmPurge.mock.funcPurge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPurge.mock.afterPurgeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPurge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Purge implements mm_acl.ACLClientInterface
func (mmPurge *ACLClientInterfaceMock) Purge(ctx context.Context, objectType string, objectUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmPurge.beforePurgeCounter, 1)
	defer mm_atomic.AddUint64(&mmPurge.afterPurgeCounter, 1)

	mmPurge.t.Helper()

	if mmPurge.inspectFuncPurge != nil {
		mmPurge.inspectFuncPurge(ctx, objectType, objectUID)
	}

	mm_params := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

	// Record call args
	mmPurge.PurgeMock.mutex.Lock()
	mmPurge.PurgeMock.callArgs = append(mmPurge.PurgeMock.callArgs, &mm_params)
	mmPurge.PurgeMock.mutex.Unlock()

	for _, e := range mmPurge.PurgeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPurge.PurgeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPurge.PurgeMock.defaultExpectation.Counter, 1)
		mm_want := mmPurge.PurgeMock.defaultExpectation.params
		mm_want_ptrs := mmPurge.PurgeMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockPurgeParams{ctx, objectType, objectUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPurge.PurgeMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPurge.t.Errorf("ACLClientInterfaceMock.Purge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPurge.PurgeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPurge.PurgeMock.defaultExpectation.results
		if mm_results == nil {
			mmPurge.t.Fatal("No results are set for the ACLClientInterfaceMock.Purge")
		}
		return (*mm_results).err
	}
	if mmPurge.funcPurge != nil {
		return mmPurge.funcPurge(ctx, objectType, objectUID)
	}
	mmPurge.t.Fatalf("Unexpected call to ACLClientInterfaceMock.Purge. %v %v %v", ctx, objectType, objectUID)
	return
}

// PurgeAfterCounter returns a count of finished ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.afterPurgeCounter)
}

// PurgeBeforeCounter returns a count of ACLClientInterfaceMock.Purge invocations
func (mmPurge *ACLClientInterfaceMock) PurgeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPurge.beforePurgeCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.Purge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPurge *mACLClientInterfaceMockPurge) Calls() []*ACLClientInterfaceMockPurgeParams {
	mmPurge.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockPurgeParams, len(mmPurge.callArgs))
	copy(argCopy, mmPurge.callArgs)

	mmPurge.mutex.RUnlock()

	return argCopy
}

// MinimockPurgeDone returns true if the count of the Purge invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockPurgeDone() bool {
	if m.PurgeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PurgeMock.invocationsDone()
}

// MinimockPurgeInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockPurgeInspect() {
	for _, e := range m.PurgeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPurgeCounter := mm_atomic.LoadUint64(&m.afterPurgeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PurgeMock.defaultExpectation != nil && afterPurgeCounter < 1 {
		if m.PurgeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.PurgeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s with params: %#v", m.PurgeMock.defaultExpectation.expectationOrigins.origin, *m.PurgeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPurge != nil && afterPurgeCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.Purge at\n%s", m.funcPurgeOrigin)
	}

	if !m.PurgeMock.invocationsDone() && afterPurgeCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.Purge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PurgeMock.expectedInvocations), m.PurgeMock.expectedInvocationsOrigin, afterPurgeCounter)
	}
}

type mACLClientInterfaceMockSetModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockSetModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockSetModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetModelPermissionExpectation specifies expectation struct of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockSetModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockSetModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockSetModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetModelPermissionParams contains parameters of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
	user     string
	role     string
	enable   bool
}

// ACLClientInterfaceMockSetModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
	user     *string
	role     *string
	enable   *bool
}

// ACLClientInterfaceMockSetModelPermissionResults contains results of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockSetModelPermissionOrigins contains origins of expectations of the ACLClientInterface.SetModelPermission
type ACLClientInterfaceMockSetModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
	originUser     string
	originRole     string
	originEnable   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Optional() *mACLClientInterfaceMockSetModelPermission {
	mmSetModelPermission.optional = true
	return mmSetModelPermission
}

// Expect sets up expected params for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Expect(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by ExpectParams functions")
	}

	mmSetModelPermission.defaultExpectation.params = &ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}
	mmSetModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetModelPermission.expectations {
		if minimock.Equal(e.params, mmSetModelPermission.defaultExpectation.params) {
			mmSetModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetModelPermission.defaultExpectation.params)
		}
	}

	return mmSetModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmSetModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectUserParam3 sets up expected param user for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectUserParam3(user string) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.user = &user
	mmSetModelPermission.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectRoleParam4 sets up expected param role for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectRoleParam4(role string) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.role = &role
	mmSetModelPermission.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// ExpectEnableParam5 sets up expected param enable for ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) ExpectEnableParam5(enable bool) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{}
	}

	if mmSetModelPermission.defaultExpectation.params != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Expect")
	}

	if mmSetModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetModelPermissionParamPtrs{}
	}
	mmSetModelPermission.defaultExpectation.paramPtrs.enable = &enable
	mmSetModelPermission.defaultExpectation.expectationOrigins.originEnable = minimock.CallerInfo(1)

	return mmSetModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool)) *mACLClientInterfaceMockSetModelPermission {
	if mmSetModelPermission.mock.inspectFuncSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetModelPermission")
	}

	mmSetModelPermission.mock.inspectFuncSetModelPermission = f

	return mmSetModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.SetModelPermission
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	if mmSetModelPermission.defaultExpectation == nil {
		mmSetModelPermission.defaultExpectation = &ACLClientInterfaceMockSetModelPermissionExpectation{mock: mmSetModelPermission.mock}
	}
	mmSetModelPermission.defaultExpectation.results = &ACLClientInterfaceMockSetModelPermissionResults{err}
	mmSetModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetModelPermission method
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error)) *ACLClientInterfaceMock {
	if mmSetModelPermission.defaultExpectation != nil {
		mmSetModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetModelPermission method")
	}

	if len(mmSetModelPermission.expectations) > 0 {
		mmSetModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetModelPermission method")
	}

	mmSetModelPermission.mock.funcSetModelPermission = f
	mmSetModelPermission.mock.funcSetModelPermissionOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission.mock
}

// When sets expectation for the ACLClientInterface.SetModelPermission which will trigger the result defined by the following
// Then helper
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) When(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) *ACLClientInterfaceMockSetModelPermissionExpectation {
	if mmSetModelPermission.mock.funcSetModelPermission != nil {
		mmSetModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetModelPermissionExpectation{
		mock:               mmSetModelPermission.mock,
		params:             &ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable},
		expectationOrigins: ACLClientInterfaceMockSetModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetModelPermission.expectations = append(mmSetModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetModelPermission should be invoked
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Times(n uint64) *mACLClientInterfaceMockSetModelPermission {
	if n == 0 {
		mmSetModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetModelPermission.expectedInvocations, n)
	mmSetModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetModelPermission
}

func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) invocationsDone() bool {
	if len(mmSetModelPermission.expectations) == 0 && mmSetModelPermission.defaultExpectation == nil && mmSetModelPermission.mock.funcSetModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetModelPermission.mock.afterSetModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetModelPermission implements mm_acl.ACLClientInterface
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermission(ctx context.Context, modelUID uuid.UUID, user string, role string, enable bool) (err error) {
	mm_atomic.AddUint64(&mmSetModelPermission.beforeSetModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetModelPermission.afterSetModelPermissionCounter, 1)

	mmSetModelPermission.t.Helper()

	if mmSetModelPermission.inspectFuncSetModelPermission != nil {
		mmSetModelPermission.inspectFuncSetModelPermission(ctx, modelUID, user, role, enable)
	}

	mm_params := ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}

	// Record call args
	mmSetModelPermission.SetModelPermissionMock.mutex.Lock()
	mmSetModelPermission.SetModelPermissionMock.callArgs = append(mmSetModelPermission.SetModelPermissionMock.callArgs, &mm_params)
	mmSetModelPermission.SetModelPermissionMock.mutex.Unlock()

	for _, e := range mmSetModelPermission.SetModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetModelPermission.SetModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetModelPermission.SetModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetModelPermissionParams{ctx, modelUID, user, role, enable}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

			if mm_want_ptrs.enable != nil && !minimock.Equal(*mm_want_ptrs.enable, mm_got.enable) {
				mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameter enable, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.originEnable, *mm_want_ptrs.enable, mm_got.enable, minimock.Diff(*mm_want_ptrs.enable, mm_got.enable))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetModelPermission.t.Errorf("ACLClientInterfaceMock.SetModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetModelPermission.SetModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetModelPermission.SetModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetModelPermission")
		}
		return (*mm_results).err
	}
	if mmSetModelPermission.funcSetModelPermission != nil {
		return mmSetModelPermission.funcSetModelPermission(ctx, modelUID, user, role, enable)
	}
	mmSetModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetModelPermission. %v %v %v %v %v", ctx, modelUID, user, role, enable)
	return
}

// SetModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetModelPermission invocations
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetModelPermission.afterSetModelPermissionCounter)
}

// SetModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetModelPermission invocations
func (mmSetModelPermission *ACLClientInterfaceMock) SetModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetModelPermission.beforeSetModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetModelPermission *mACLClientInterfaceMockSetModelPermission) Calls() []*ACLClientInterfaceMockSetModelPermissionParams {
	mmSetModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetModelPermissionParams, len(mmSetModelPermission.callArgs))
	copy(argCopy, mmSetModelPermission.callArgs)

	mmSetModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetModelPermissionDone returns true if the count of the SetModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetModelPermissionDone() bool {
	if m.SetModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetModelPermissionMock.invocationsDone()
}

// MinimockSetModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetModelPermissionInspect() {
	for _, e := range m.SetModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetModelPermissionCounter := mm_atomic.LoadUint64(&m.afterSetModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetModelPermissionMock.defaultExpectation != nil && afterSetModelPermissionCounter < 1 {
		if m.SetModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s", m.SetModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s with params: %#v", m.SetModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetModelPermission != nil && afterSetModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetModelPermission at\n%s", m.funcSetModelPermissionOrigin)
	}

	if !m.SetModelPermissionMock.invocationsDone() && afterSetModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetModelPermissionMock.expectedInvocations), m.SetModelPermissionMock.expectedInvocationsOrigin, afterSetModelPermissionCounter)
	}
}

type mACLClientInterfaceMockSetOwner struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetOwnerExpectation
	expectations       []*ACLClientInterfaceMockSetOwnerExpectation

	callArgs []*ACLClientInterfaceMockSetOwnerParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetOwnerExpectation specifies expectation struct of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetOwnerParams
	paramPtrs          *ACLClientInterfaceMockSetOwnerParamPtrs
	expectationOrigins ACLClientInterfaceMockSetOwnerExpectationOrigins
	results            *ACLClientInterfaceMockSetOwnerResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetOwnerParams contains parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParams struct {
	ctx        context.Context
	objectType string
	objectUID  uuid.UUID
	ownerType  string
	ownerUID   uuid.UUID
}

// ACLClientInterfaceMockSetOwnerParamPtrs contains pointers to parameters of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerParamPtrs struct {
	ctx        *context.Context
	objectType *string
	objectUID  *uuid.UUID
	ownerType  *string
	ownerUID   *uuid.UUID
}

// ACLClientInterfaceMockSetOwnerResults contains results of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerResults struct {
	err error
}

// ACLClientInterfaceMockSetOwnerOrigins contains origins of expectations of the ACLClientInterface.SetOwner
type ACLClientInterfaceMockSetOwnerExpectationOrigins struct {
	origin           string
	originCtx        string
	originObjectType string
	originObjectUID  string
	originOwnerType  string
	originOwnerUID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Optional() *mACLClientInterfaceMockSetOwner {
	mmSetOwner.optional = true
	return mmSetOwner
}

// Expect sets up expected params for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Expect(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.paramPtrs != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by ExpectParams functions")
	}

	mmSetOwner.defaultExpectation.params = &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}
	mmSetOwner.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOwner.expectations {
		if minimock.Equal(e.params, mmSetOwner.defaultExpectation.params) {
			mmSetOwner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOwner.defaultExpectation.params)
		}
	}

	return mmSetOwner
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetOwner.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectTypeParam2 sets up expected param objectType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectTypeParam2(objectType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectType = &objectType
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectObjectUIDParam3 sets up expected param objectUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectObjectUIDParam3(objectUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.objectUID = &objectUID
	mmSetOwner.defaultExpectation.expectationOrigins.originObjectUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerTypeParam4 sets up expected param ownerType for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerTypeParam4(ownerType string) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerType = &ownerType
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerType = minimock.CallerInfo(1)

	return mmSetOwner
}

// ExpectOwnerUIDParam5 sets up expected param ownerUID for ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) ExpectOwnerUIDParam5(ownerUID uuid.UUID) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{}
	}

	if mmSetOwner.defaultExpectation.params != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Expect")
	}

	if mmSetOwner.defaultExpectation.paramPtrs == nil {
		mmSetOwner.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetOwnerParamPtrs{}
	}
	mmSetOwner.defaultExpectation.paramPtrs.ownerUID = &ownerUID
	mmSetOwner.defaultExpectation.expectationOrigins.originOwnerUID = minimock.CallerInfo(1)

	return mmSetOwner
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Inspect(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID)) *mACLClientInterfaceMockSetOwner {
	if mmSetOwner.mock.inspectFuncSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetOwner")
	}

	mmSetOwner.mock.inspectFuncSetOwner = f

	return mmSetOwner
}

// Return sets up results that will be returned by ACLClientInterface.SetOwner
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Return(err error) *ACLClientInterfaceMock {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	if mmSetOwner.defaultExpectation == nil {
		mmSetOwner.defaultExpectation = &ACLClientInterfaceMockSetOwnerExpectation{mock: mmSetOwner.mock}
	}
	mmSetOwner.defaultExpectation.results = &ACLClientInterfaceMockSetOwnerResults{err}
	mmSetOwner.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// Set uses given function f to mock the ACLClientInterface.SetOwner method
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Set(f func(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetOwner.defaultExpectation != nil {
		mmSetOwner.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetOwner method")
	}

	if len(mmSetOwner.expectations) > 0 {
		mmSetOwner.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetOwner method")
	}

	mmSetOwner.mock.funcSetOwner = f
	mmSetOwner.mock.funcSetOwnerOrigin = minimock.CallerInfo(1)
	return mmSetOwner.mock
}

// When sets expectation for the ACLClientInterface.SetOwner which will trigger the result defined by the following
// Then helper
func (mmSetOwner *mACLClientInterfaceMockSetOwner) When(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) *ACLClientInterfaceMockSetOwnerExpectation {
	if mmSetOwner.mock.funcSetOwner != nil {
		mmSetOwner.mock.t.Fatalf("ACLClientInterfaceMock.SetOwner mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetOwnerExpectation{
		mock:               mmSetOwner.mock,
		params:             &ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID},
		expectationOrigins: ACLClientInterfaceMockSetOwnerExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOwner.expectations = append(mmSetOwner.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetOwner return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetOwnerExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetOwnerResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetOwner should be invoked
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Times(n uint64) *mACLClientInterfaceMockSetOwner {
	if n == 0 {
		mmSetOwner.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetOwner mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOwner.expectedInvocations, n)
	mmSetOwner.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOwner
}

func (mmSetOwner *mACLClientInterfaceMockSetOwner) invocationsDone() bool {
	if len(mmSetOwner.expectations) == 0 && mmSetOwner.defaultExpectation == nil && mmSetOwner.mock.funcSetOwner == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOwner.mock.afterSetOwnerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOwner.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOwner implements mm_acl.ACLClientInterface
func (mmSetOwner *ACLClientInterfaceMock) SetOwner(ctx context.Context, objectType string, objectUID uuid.UUID, ownerType string, ownerUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetOwner.beforeSetOwnerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOwner.afterSetOwnerCounter, 1)

	mmSetOwner.t.Helper()

	if mmSetOwner.inspectFuncSetOwner != nil {
		mmSetOwner.inspectFuncSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}

	mm_params := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

	// Record call args
	mmSetOwner.SetOwnerMock.mutex.Lock()
	mmSetOwner.SetOwnerMock.callArgs = append(mmSetOwner.SetOwnerMock.callArgs, &mm_params)
	mmSetOwner.SetOwnerMock.mutex.Unlock()

	for _, e := range mmSetOwner.SetOwnerMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOwner.SetOwnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOwner.SetOwnerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOwner.SetOwnerMock.defaultExpectation.params
		mm_want_ptrs := mmSetOwner.SetOwnerMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetOwnerParams{ctx, objectType, objectUID, ownerType, ownerUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.objectType != nil && !minimock.Equal(*mm_want_ptrs.objectType, mm_got.objectType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectType, *mm_want_ptrs.objectType, mm_got.objectType, minimock.Diff(*mm_want_ptrs.objectType, mm_got.objectType))
			}

			if mm_want_ptrs.objectUID != nil && !minimock.Equal(*mm_want_ptrs.objectUID, mm_got.objectUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter objectUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originObjectUID, *mm_want_ptrs.objectUID, mm_got.objectUID, minimock.Diff(*mm_want_ptrs.objectUID, mm_got.objectUID))
			}

			if mm_want_ptrs.ownerType != nil && !minimock.Equal(*mm_want_ptrs.ownerType, mm_got.ownerType) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerType, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerType, *mm_want_ptrs.ownerType, mm_got.ownerType, minimock.Diff(*mm_want_ptrs.ownerType, mm_got.ownerType))
			}

			if mm_want_ptrs.ownerUID != nil && !minimock.Equal(*mm_want_ptrs.ownerUID, mm_got.ownerUID) {
				mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameter ownerUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.originOwnerUID, *mm_want_ptrs.ownerUID, mm_got.ownerUID, minimock.Diff(*mm_want_ptrs.ownerUID, mm_got.ownerUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOwner.t.Errorf("ACLClientInterfaceMock.SetOwner got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOwner.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOwner.SetOwnerMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOwner.t.Fatal("No results are set for the ACLClientInterfaceMock.SetOwner")
		}
		return (*mm_results).err
	}
	if mmSetOwner.funcSetOwner != nil {
		return mmSetOwner.funcSetOwner(ctx, objectType, objectUID, ownerType, ownerUID)
	}
	mmSetOwner.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetOwner. %v %v %v %v %v", ctx, objectType, objectUID, ownerType, ownerUID)
	return
}

// SetOwnerAfterCounter returns a count of finished ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.afterSetOwnerCounter)
}

// SetOwnerBeforeCounter returns a count of ACLClientInterfaceMock.SetOwner invocations
func (mmSetOwner *ACLClientInterfaceMock) SetOwnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOwner.beforeSetOwnerCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetOwner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOwner *mACLClientInterfaceMockSetOwner) Calls() []*ACLClientInterfaceMockSetOwnerParams {
	mmSetOwner.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetOwnerParams, len(mmSetOwner.callArgs))
	copy(argCopy, mmSetOwner.callArgs)

	mmSetOwner.mutex.RUnlock()

	return argCopy
}

// MinimockSetOwnerDone returns true if the count of the SetOwner invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetOwnerDone() bool {
	if m.SetOwnerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOwnerMock.invocationsDone()
}

// MinimockSetOwnerInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetOwnerInspect() {
	for _, e := range m.SetOwnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOwnerCounter := mm_atomic.LoadUint64(&m.afterSetOwnerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOwnerMock.defaultExpectation != nil && afterSetOwnerCounter < 1 {
		if m.SetOwnerMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.SetOwnerMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s with params: %#v", m.SetOwnerMock.defaultExpectation.expectationOrigins.origin, *m.SetOwnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOwner != nil && afterSetOwnerCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetOwner at\n%s", m.funcSetOwnerOrigin)
	}

	if !m.SetOwnerMock.invocationsDone() && afterSetOwnerCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetOwner at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOwnerMock.expectedInvocations), m.SetOwnerMock.expectedInvocationsOrigin, afterSetOwnerCounter)
	}
}

type mACLClientInterfaceMockSetPublicModelPermission struct {
	optional           bool
	mock               *ACLClientInterfaceMock
	defaultExpectation *ACLClientInterfaceMockSetPublicModelPermissionExpectation
	expectations       []*ACLClientInterfaceMockSetPublicModelPermissionExpectation

	callArgs []*ACLClientInterfaceMockSetPublicModelPermissionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ACLClientInterfaceMockSetPublicModelPermissionExpectation specifies expectation struct of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionExpectation struct {
	mock               *ACLClientInterfaceMock
	params             *ACLClientInterfaceMockSetPublicModelPermissionParams
	paramPtrs          *ACLClientInterfaceMockSetPublicModelPermissionParamPtrs
	expectationOrigins ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins
	results            *ACLClientInterfaceMockSetPublicModelPermissionResults
	returnOrigin       string
	Counter            uint64
}

// ACLClientInterfaceMockSetPublicModelPermissionParams contains parameters of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionParams struct {
	ctx      context.Context
	modelUID uuid.UUID
}

// ACLClientInterfaceMockSetPublicModelPermissionParamPtrs contains pointers to parameters of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionParamPtrs struct {
	ctx      *context.Context
	modelUID *uuid.UUID
}

// ACLClientInterfaceMockSetPublicModelPermissionResults contains results of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionResults struct {
	err error
}

// ACLClientInterfaceMockSetPublicModelPermissionOrigins contains origins of expectations of the ACLClientInterface.SetPublicModelPermission
type ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins struct {
	origin         string
	originCtx      string
	originModelUID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Optional() *mACLClientInterfaceMockSetPublicModelPermission {
	mmSetPublicModelPermission.optional = true
	return mmSetPublicModelPermission
}

// Expect sets up expected params for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Expect(ctx context.Context, modelUID uuid.UUID) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by ExpectParams functions")
	}

	mmSetPublicModelPermission.defaultExpectation.params = &ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetPublicModelPermission.expectations {
		if minimock.Equal(e.params, mmSetPublicModelPermission.defaultExpectation.params) {
			mmSetPublicModelPermission.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPublicModelPermission.defaultExpectation.params)
		}
	}

	return mmSetPublicModelPermission
}

// ExpectCtxParam1 sets up expected param ctx for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) ExpectCtxParam1(ctx context.Context) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.params != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Expect")
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetPublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPublicModelPermissionParamPtrs{}
	}
	mmSetPublicModelPermission.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetPublicModelPermission
}

// ExpectModelUIDParam2 sets up expected param modelUID for ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) ExpectModelUIDParam2(modelUID uuid.UUID) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{}
	}

	if mmSetPublicModelPermission.defaultExpectation.params != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Expect")
	}

	if mmSetPublicModelPermission.defaultExpectation.paramPtrs == nil {
		mmSetPublicModelPermission.defaultExpectation.paramPtrs = &ACLClientInterfaceMockSetPublicModelPermissionParamPtrs{}
	}
	mmSetPublicModelPermission.defaultExpectation.paramPtrs.modelUID = &modelUID
	mmSetPublicModelPermission.defaultExpectation.expectationOrigins.originModelUID = minimock.CallerInfo(1)

	return mmSetPublicModelPermission
}

// Inspect accepts an inspector function that has same arguments as the ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Inspect(f func(ctx context.Context, modelUID uuid.UUID)) *mACLClientInterfaceMockSetPublicModelPermission {
	if mmSetPublicModelPermission.mock.inspectFuncSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("Inspect function is already set for ACLClientInterfaceMock.SetPublicModelPermission")
	}

	mmSetPublicModelPermission.mock.inspectFuncSetPublicModelPermission = f

	return mmSetPublicModelPermission
}

// Return sets up results that will be returned by ACLClientInterface.SetPublicModelPermission
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Return(err error) *ACLClientInterfaceMock {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	if mmSetPublicModelPermission.defaultExpectation == nil {
		mmSetPublicModelPermission.defaultExpectation = &ACLClientInterfaceMockSetPublicModelPermissionExpectation{mock: mmSetPublicModelPermission.mock}
	}
	mmSetPublicModelPermission.defaultExpectation.results = &ACLClientInterfaceMockSetPublicModelPermissionResults{err}
	mmSetPublicModelPermission.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission.mock
}

// Set uses given function f to mock the ACLClientInterface.SetPublicModelPermission method
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Set(f func(ctx context.Context, modelUID uuid.UUID) (err error)) *ACLClientInterfaceMock {
	if mmSetPublicModelPermission.defaultExpectation != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("Default expectation is already set for the ACLClientInterface.SetPublicModelPermission method")
	}

	if len(mmSetPublicModelPermission.expectations) > 0 {
		mmSetPublicModelPermission.mock.t.Fatalf("Some expectations are already set for the ACLClientInterface.SetPublicModelPermission method")
	}

	mmSetPublicModelPermission.mock.funcSetPublicModelPermission = f
	mmSetPublicModelPermission.mock.funcSetPublicModelPermissionOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission.mock
}

// When sets expectation for the ACLClientInterface.SetPublicModelPermission which will trigger the result defined by the following
// Then helper
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) When(ctx context.Context, modelUID uuid.UUID) *ACLClientInterfaceMockSetPublicModelPermissionExpectation {
	if mmSetPublicModelPermission.mock.funcSetPublicModelPermission != nil {
		mmSetPublicModelPermission.mock.t.Fatalf("ACLClientInterfaceMock.SetPublicModelPermission mock is already set by Set")
	}

	expectation := &ACLClientInterfaceMockSetPublicModelPermissionExpectation{
		mock:               mmSetPublicModelPermission.mock,
		params:             &ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID},
		expectationOrigins: ACLClientInterfaceMockSetPublicModelPermissionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetPublicModelPermission.expectations = append(mmSetPublicModelPermission.expectations, expectation)
	return expectation
}

// Then sets up ACLClientInterface.SetPublicModelPermission return parameters for the expectation previously defined by the When method
func (e *ACLClientInterfaceMockSetPublicModelPermissionExpectation) Then(err error) *ACLClientInterfaceMock {
	e.results = &ACLClientInterfaceMockSetPublicModelPermissionResults{err}
	return e.mock
}

// Times sets number of times ACLClientInterface.SetPublicModelPermission should be invoked
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Times(n uint64) *mACLClientInterfaceMockSetPublicModelPermission {
	if n == 0 {
		mmSetPublicModelPermission.mock.t.Fatalf("Times of ACLClientInterfaceMock.SetPublicModelPermission mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetPublicModelPermission.expectedInvocations, n)
	mmSetPublicModelPermission.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetPublicModelPermission
}

func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) invocationsDone() bool {
	if len(mmSetPublicModelPermission.expectations) == 0 && mmSetPublicModelPermission.defaultExpectation == nil && mmSetPublicModelPermission.mock.funcSetPublicModelPermission == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetPublicModelPermission.mock.afterSetPublicModelPermissionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetPublicModelPermission.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetPublicModelPermission implements mm_acl.ACLClientInterface
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermission(ctx context.Context, modelUID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmSetPublicModelPermission.beforeSetPublicModelPermissionCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPublicModelPermission.afterSetPublicModelPermissionCounter, 1)

	mmSetPublicModelPermission.t.Helper()

	if mmSetPublicModelPermission.inspectFuncSetPublicModelPermission != nil {
		mmSetPublicModelPermission.inspectFuncSetPublicModelPermission(ctx, modelUID)
	}

	mm_params := ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}

	// Record call args
	mmSetPublicModelPermission.SetPublicModelPermissionMock.mutex.Lock()
	mmSetPublicModelPermission.SetPublicModelPermissionMock.callArgs = append(mmSetPublicModelPermission.SetPublicModelPermissionMock.callArgs, &mm_params)
	mmSetPublicModelPermission.SetPublicModelPermissionMock.mutex.Unlock()

	for _, e := range mmSetPublicModelPermission.SetPublicModelPermissionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.params
		mm_want_ptrs := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.paramPtrs

		mm_got := ACLClientInterfaceMockSetPublicModelPermissionParams{ctx, modelUID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelUID != nil && !minimock.Equal(*mm_want_ptrs.modelUID, mm_got.modelUID) {
				mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameter modelUID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.originModelUID, *mm_want_ptrs.modelUID, mm_got.modelUID, minimock.Diff(*mm_want_ptrs.modelUID, mm_got.modelUID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPublicModelPermission.t.Errorf("ACLClientInterfaceMock.SetPublicModelPermission got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPublicModelPermission.SetPublicModelPermissionMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPublicModelPermission.t.Fatal("No results are set for the ACLClientInterfaceMock.SetPublicModelPermission")
		}
		return (*mm_results).err
	}
	if mmSetPublicModelPermission.funcSetPublicModelPermission != nil {
		return mmSetPublicModelPermission.funcSetPublicModelPermission(ctx, modelUID)
	}
	mmSetPublicModelPermission.t.Fatalf("Unexpected call to ACLClientInterfaceMock.SetPublicModelPermission. %v %v", ctx, modelUID)
	return
}

// SetPublicModelPermissionAfterCounter returns a count of finished ACLClientInterfaceMock.SetPublicModelPermission invocations
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermissionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPublicModelPermission.afterSetPublicModelPermissionCounter)
}

// SetPublicModelPermissionBeforeCounter returns a count of ACLClientInterfaceMock.SetPublicModelPermission invocations
func (mmSetPublicModelPermission *ACLClientInterfaceMock) SetPublicModelPermissionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPublicModelPermission.beforeSetPublicModelPermissionCounter)
}

// Calls returns a list of arguments used in each call to ACLClientInterfaceMock.SetPublicModelPermission.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPublicModelPermission *mACLClientInterfaceMockSetPublicModelPermission) Calls() []*ACLClientInterfaceMockSetPublicModelPermissionParams {
	mmSetPublicModelPermission.mutex.RLock()

	argCopy := make([]*ACLClientInterfaceMockSetPublicModelPermissionParams, len(mmSetPublicModelPermission.callArgs))
	copy(argCopy, mmSetPublicModelPermission.callArgs)

	mmSetPublicModelPermission.mutex.RUnlock()

	return argCopy
}

// MinimockSetPublicModelPermissionDone returns true if the count of the SetPublicModelPermission invocations corresponds
// the number of defined expectations
func (m *ACLClientInterfaceMock) MinimockSetPublicModelPermissionDone() bool {
	if m.SetPublicModelPermissionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetPublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetPublicModelPermissionMock.invocationsDone()
}

// MinimockSetPublicModelPermissionInspect logs each unmet expectation
func (m *ACLClientInterfaceMock) MinimockSetPublicModelPermissionInspect() {
	for _, e := range m.SetPublicModelPermissionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetPublicModelPermissionCounter := mm_atomic.LoadUint64(&m.afterSetPublicModelPermissionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetPublicModelPermissionMock.defaultExpectation != nil && afterSetPublicModelPermissionCounter < 1 {
		if m.SetPublicModelPermissionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s", m.SetPublicModelPermissionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s with params: %#v", m.SetPublicModelPermissionMock.defaultExpectation.expectationOrigins.origin, *m.SetPublicModelPermissionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPublicModelPermission != nil && afterSetPublicModelPermissionCounter < 1 {
		m.t.Errorf("Expected call to ACLClientInterfaceMock.SetPublicModelPermission at\n%s", m.funcSetPublicModelPermissionOrigin)
	}

	if !m.SetPublicModelPermissionMock.invocationsDone() && afterSetPublicModelPermissionCounter > 0 {
		m.t.Errorf("Expected %d calls to ACLClientInterfaceMock.SetPublicModelPermission at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetPublicModelPermissionMock.expectedInvocations), m.SetPublicModelPermissionMock.expectedInvocationsOrigin, afterSetPublicModelPermissionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ACLClientInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckPermissionInspect()

			m.MinimockCheckPublicExecutableInspect()

			m.MinimockDeleteModelPermissionInspect()

			m.MinimockDeletePublicModelPermissionInspect()

			m.MinimockListPermissionsInspect()

			m.MinimockPurgeInspect()

			m.MinimockSetModelPermissionInspect()

			m.MinimockSetOwnerInspect()

			m.MinimockSetPublicModelPermissionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ACLClientInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ACLClientInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckPermissionDone() &&
		m.MinimockCheckPublicExecutableDone() &&
		m.MinimockDeleteModelPermissionDone() &&
		m.MinimockDeletePublicModelPermissionDone() &&
		m.MinimockListPermissionsDone() &&
		m.MinimockPurgeDone() &&
		m.MinimockSetModelPermissionDone() &&
		m.MinimockSetOwnerDone() &&
		m.MinimockSetPublicModelPermissionDone()
}
