// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"context"
	"sync"

	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"

	"github.com/instill-ai/model-backend/pkg/ray/rayserver"

	mm_ray "github.com/instill-ai/model-backend/pkg/ray"
	commonpb "github.com/instill-ai/protogen-go/common/task/v1alpha"
	modelpb "github.com/instill-ai/protogen-go/model/model/v1alpha"
)

// RayMock implements mm_ray.Ray
type RayMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRayMockClose

	funcInit          func()
	funcInitOrigin    string
	inspectFuncInit   func()
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mRayMockInit

	funcIsRayServerReady          func(ctx context.Context) (b1 bool)
	funcIsRayServerReadyOrigin    string
	inspectFuncIsRayServerReady   func(ctx context.Context)
	afterIsRayServerReadyCounter  uint64
	beforeIsRayServerReadyCounter uint64
	IsRayServerReadyMock          mRayMockIsRayServerReady

	funcModelInferRequest          func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayserver.CallResponse, err error)
	funcModelInferRequestOrigin    string
	inspectFuncModelInferRequest   func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string)
	afterModelInferRequestCounter  uint64
	beforeModelInferRequestCounter uint64
	ModelInferRequestMock          mRayMockModelInferRequest

	funcModelReady          func(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error)
	funcModelReadyOrigin    string
	inspectFuncModelReady   func(ctx context.Context, modelName string, version string)
	afterModelReadyCounter  uint64
	beforeModelReadyCounter uint64
	ModelReadyMock          mRayMockModelReady

	funcUpdateContainerizedModel          func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string) (err error)
	funcUpdateContainerizedModelOrigin    string
	inspectFuncUpdateContainerizedModel   func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string)
	afterUpdateContainerizedModelCounter  uint64
	beforeUpdateContainerizedModelCounter uint64
	UpdateContainerizedModelMock          mRayMockUpdateContainerizedModel
}

// NewRayMock returns a mock for mm_ray.Ray
func NewRayMock(t minimock.Tester) *RayMock {
	m := &RayMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRayMockClose{mock: m}

	m.InitMock = mRayMockInit{mock: m}

	m.IsRayServerReadyMock = mRayMockIsRayServerReady{mock: m}
	m.IsRayServerReadyMock.callArgs = []*RayMockIsRayServerReadyParams{}

	m.ModelInferRequestMock = mRayMockModelInferRequest{mock: m}
	m.ModelInferRequestMock.callArgs = []*RayMockModelInferRequestParams{}

	m.ModelReadyMock = mRayMockModelReady{mock: m}
	m.ModelReadyMock.callArgs = []*RayMockModelReadyParams{}

	m.UpdateContainerizedModelMock = mRayMockUpdateContainerizedModel{mock: m}
	m.UpdateContainerizedModelMock.callArgs = []*RayMockUpdateContainerizedModelParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRayMockClose struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockCloseExpectation
	expectations       []*RayMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockCloseExpectation specifies expectation struct of the Ray.Close
type RayMockCloseExpectation struct {
	mock *RayMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mRayMockClose) Optional() *mRayMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Ray.Close
func (mmClose *mRayMockClose) Expect() *mRayMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RayMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RayMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Ray.Close
func (mmClose *mRayMockClose) Inspect(f func()) *mRayMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RayMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Ray.Close
func (mmClose *mRayMockClose) Return() *RayMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RayMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RayMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Ray.Close method
func (mmClose *mRayMockClose) Set(f func()) *RayMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Ray.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Ray.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Ray.Close should be invoked
func (mmClose *mRayMockClose) Times(n uint64) *mRayMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of RayMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mRayMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_ray.Ray
func (mmClose *RayMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to RayMock.Close.")

}

// CloseAfterCounter returns a count of finished RayMock.Close invocations
func (mmClose *RayMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RayMock.Close invocations
func (mmClose *RayMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *RayMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RayMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mRayMockInit struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockInitExpectation
	expectations       []*RayMockInitExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockInitExpectation specifies expectation struct of the Ray.Init
type RayMockInitExpectation struct {
	mock *RayMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInit *mRayMockInit) Optional() *mRayMockInit {
	mmInit.optional = true
	return mmInit
}

// Expect sets up expected params for Ray.Init
func (mmInit *mRayMockInit) Expect() *mRayMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RayMockInitExpectation{}
	}

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the Ray.Init
func (mmInit *mRayMockInit) Inspect(f func()) *mRayMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for RayMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by Ray.Init
func (mmInit *mRayMockInit) Return() *RayMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RayMockInitExpectation{mock: mmInit.mock}
	}

	mmInit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInit.mock
}

// Set uses given function f to mock the Ray.Init method
func (mmInit *mRayMockInit) Set(f func()) *RayMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the Ray.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the Ray.Init method")
	}

	mmInit.mock.funcInit = f
	mmInit.mock.funcInitOrigin = minimock.CallerInfo(1)
	return mmInit.mock
}

// Times sets number of times Ray.Init should be invoked
func (mmInit *mRayMockInit) Times(n uint64) *mRayMockInit {
	if n == 0 {
		mmInit.mock.t.Fatalf("Times of RayMock.Init mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInit.expectedInvocations, n)
	mmInit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInit
}

func (mmInit *mRayMockInit) invocationsDone() bool {
	if len(mmInit.expectations) == 0 && mmInit.defaultExpectation == nil && mmInit.mock.funcInit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInit.mock.afterInitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Init implements mm_ray.Ray
func (mmInit *RayMock) Init() {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	mmInit.t.Helper()

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit()
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)

		return

	}
	if mmInit.funcInit != nil {
		mmInit.funcInit()
		return
	}
	mmInit.t.Fatalf("Unexpected call to RayMock.Init.")

}

// InitAfterCounter returns a count of finished RayMock.Init invocations
func (mmInit *RayMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of RayMock.Init invocations
func (mmInit *RayMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockInitDone() bool {
	if m.InitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitMock.invocationsDone()
}

// MinimockInitInspect logs each unmet expectation
func (m *RayMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RayMock.Init")
		}
	}

	afterInitCounter := mm_atomic.LoadUint64(&m.afterInitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && afterInitCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Init at\n%s", m.InitMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && afterInitCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Init at\n%s", m.funcInitOrigin)
	}

	if !m.InitMock.invocationsDone() && afterInitCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.Init at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitMock.expectedInvocations), m.InitMock.expectedInvocationsOrigin, afterInitCounter)
	}
}

type mRayMockIsRayServerReady struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockIsRayServerReadyExpectation
	expectations       []*RayMockIsRayServerReadyExpectation

	callArgs []*RayMockIsRayServerReadyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockIsRayServerReadyExpectation specifies expectation struct of the Ray.IsRayServerReady
type RayMockIsRayServerReadyExpectation struct {
	mock               *RayMock
	params             *RayMockIsRayServerReadyParams
	paramPtrs          *RayMockIsRayServerReadyParamPtrs
	expectationOrigins RayMockIsRayServerReadyExpectationOrigins
	results            *RayMockIsRayServerReadyResults
	returnOrigin       string
	Counter            uint64
}

// RayMockIsRayServerReadyParams contains parameters of the Ray.IsRayServerReady
type RayMockIsRayServerReadyParams struct {
	ctx context.Context
}

// RayMockIsRayServerReadyParamPtrs contains pointers to parameters of the Ray.IsRayServerReady
type RayMockIsRayServerReadyParamPtrs struct {
	ctx *context.Context
}

// RayMockIsRayServerReadyResults contains results of the Ray.IsRayServerReady
type RayMockIsRayServerReadyResults struct {
	b1 bool
}

// RayMockIsRayServerReadyOrigins contains origins of expectations of the Ray.IsRayServerReady
type RayMockIsRayServerReadyExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsRayServerReady *mRayMockIsRayServerReady) Optional() *mRayMockIsRayServerReady {
	mmIsRayServerReady.optional = true
	return mmIsRayServerReady
}

// Expect sets up expected params for Ray.IsRayServerReady
func (mmIsRayServerReady *mRayMockIsRayServerReady) Expect(ctx context.Context) *mRayMockIsRayServerReady {
	if mmIsRayServerReady.mock.funcIsRayServerReady != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by Set")
	}

	if mmIsRayServerReady.defaultExpectation == nil {
		mmIsRayServerReady.defaultExpectation = &RayMockIsRayServerReadyExpectation{}
	}

	if mmIsRayServerReady.defaultExpectation.paramPtrs != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by ExpectParams functions")
	}

	mmIsRayServerReady.defaultExpectation.params = &RayMockIsRayServerReadyParams{ctx}
	mmIsRayServerReady.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsRayServerReady.expectations {
		if minimock.Equal(e.params, mmIsRayServerReady.defaultExpectation.params) {
			mmIsRayServerReady.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsRayServerReady.defaultExpectation.params)
		}
	}

	return mmIsRayServerReady
}

// ExpectCtxParam1 sets up expected param ctx for Ray.IsRayServerReady
func (mmIsRayServerReady *mRayMockIsRayServerReady) ExpectCtxParam1(ctx context.Context) *mRayMockIsRayServerReady {
	if mmIsRayServerReady.mock.funcIsRayServerReady != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by Set")
	}

	if mmIsRayServerReady.defaultExpectation == nil {
		mmIsRayServerReady.defaultExpectation = &RayMockIsRayServerReadyExpectation{}
	}

	if mmIsRayServerReady.defaultExpectation.params != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by Expect")
	}

	if mmIsRayServerReady.defaultExpectation.paramPtrs == nil {
		mmIsRayServerReady.defaultExpectation.paramPtrs = &RayMockIsRayServerReadyParamPtrs{}
	}
	mmIsRayServerReady.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsRayServerReady.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsRayServerReady
}

// Inspect accepts an inspector function that has same arguments as the Ray.IsRayServerReady
func (mmIsRayServerReady *mRayMockIsRayServerReady) Inspect(f func(ctx context.Context)) *mRayMockIsRayServerReady {
	if mmIsRayServerReady.mock.inspectFuncIsRayServerReady != nil {
		mmIsRayServerReady.mock.t.Fatalf("Inspect function is already set for RayMock.IsRayServerReady")
	}

	mmIsRayServerReady.mock.inspectFuncIsRayServerReady = f

	return mmIsRayServerReady
}

// Return sets up results that will be returned by Ray.IsRayServerReady
func (mmIsRayServerReady *mRayMockIsRayServerReady) Return(b1 bool) *RayMock {
	if mmIsRayServerReady.mock.funcIsRayServerReady != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by Set")
	}

	if mmIsRayServerReady.defaultExpectation == nil {
		mmIsRayServerReady.defaultExpectation = &RayMockIsRayServerReadyExpectation{mock: mmIsRayServerReady.mock}
	}
	mmIsRayServerReady.defaultExpectation.results = &RayMockIsRayServerReadyResults{b1}
	mmIsRayServerReady.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsRayServerReady.mock
}

// Set uses given function f to mock the Ray.IsRayServerReady method
func (mmIsRayServerReady *mRayMockIsRayServerReady) Set(f func(ctx context.Context) (b1 bool)) *RayMock {
	if mmIsRayServerReady.defaultExpectation != nil {
		mmIsRayServerReady.mock.t.Fatalf("Default expectation is already set for the Ray.IsRayServerReady method")
	}

	if len(mmIsRayServerReady.expectations) > 0 {
		mmIsRayServerReady.mock.t.Fatalf("Some expectations are already set for the Ray.IsRayServerReady method")
	}

	mmIsRayServerReady.mock.funcIsRayServerReady = f
	mmIsRayServerReady.mock.funcIsRayServerReadyOrigin = minimock.CallerInfo(1)
	return mmIsRayServerReady.mock
}

// When sets expectation for the Ray.IsRayServerReady which will trigger the result defined by the following
// Then helper
func (mmIsRayServerReady *mRayMockIsRayServerReady) When(ctx context.Context) *RayMockIsRayServerReadyExpectation {
	if mmIsRayServerReady.mock.funcIsRayServerReady != nil {
		mmIsRayServerReady.mock.t.Fatalf("RayMock.IsRayServerReady mock is already set by Set")
	}

	expectation := &RayMockIsRayServerReadyExpectation{
		mock:               mmIsRayServerReady.mock,
		params:             &RayMockIsRayServerReadyParams{ctx},
		expectationOrigins: RayMockIsRayServerReadyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsRayServerReady.expectations = append(mmIsRayServerReady.expectations, expectation)
	return expectation
}

// Then sets up Ray.IsRayServerReady return parameters for the expectation previously defined by the When method
func (e *RayMockIsRayServerReadyExpectation) Then(b1 bool) *RayMock {
	e.results = &RayMockIsRayServerReadyResults{b1}
	return e.mock
}

// Times sets number of times Ray.IsRayServerReady should be invoked
func (mmIsRayServerReady *mRayMockIsRayServerReady) Times(n uint64) *mRayMockIsRayServerReady {
	if n == 0 {
		mmIsRayServerReady.mock.t.Fatalf("Times of RayMock.IsRayServerReady mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsRayServerReady.expectedInvocations, n)
	mmIsRayServerReady.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsRayServerReady
}

func (mmIsRayServerReady *mRayMockIsRayServerReady) invocationsDone() bool {
	if len(mmIsRayServerReady.expectations) == 0 && mmIsRayServerReady.defaultExpectation == nil && mmIsRayServerReady.mock.funcIsRayServerReady == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsRayServerReady.mock.afterIsRayServerReadyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsRayServerReady.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsRayServerReady implements mm_ray.Ray
func (mmIsRayServerReady *RayMock) IsRayServerReady(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmIsRayServerReady.beforeIsRayServerReadyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRayServerReady.afterIsRayServerReadyCounter, 1)

	mmIsRayServerReady.t.Helper()

	if mmIsRayServerReady.inspectFuncIsRayServerReady != nil {
		mmIsRayServerReady.inspectFuncIsRayServerReady(ctx)
	}

	mm_params := RayMockIsRayServerReadyParams{ctx}

	// Record call args
	mmIsRayServerReady.IsRayServerReadyMock.mutex.Lock()
	mmIsRayServerReady.IsRayServerReadyMock.callArgs = append(mmIsRayServerReady.IsRayServerReadyMock.callArgs, &mm_params)
	mmIsRayServerReady.IsRayServerReadyMock.mutex.Unlock()

	for _, e := range mmIsRayServerReady.IsRayServerReadyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.Counter, 1)
		mm_want := mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.params
		mm_want_ptrs := mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.paramPtrs

		mm_got := RayMockIsRayServerReadyParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsRayServerReady.t.Errorf("RayMock.IsRayServerReady got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsRayServerReady.t.Errorf("RayMock.IsRayServerReady got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsRayServerReady.IsRayServerReadyMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRayServerReady.t.Fatal("No results are set for the RayMock.IsRayServerReady")
		}
		return (*mm_results).b1
	}
	if mmIsRayServerReady.funcIsRayServerReady != nil {
		return mmIsRayServerReady.funcIsRayServerReady(ctx)
	}
	mmIsRayServerReady.t.Fatalf("Unexpected call to RayMock.IsRayServerReady. %v", ctx)
	return
}

// IsRayServerReadyAfterCounter returns a count of finished RayMock.IsRayServerReady invocations
func (mmIsRayServerReady *RayMock) IsRayServerReadyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRayServerReady.afterIsRayServerReadyCounter)
}

// IsRayServerReadyBeforeCounter returns a count of RayMock.IsRayServerReady invocations
func (mmIsRayServerReady *RayMock) IsRayServerReadyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRayServerReady.beforeIsRayServerReadyCounter)
}

// Calls returns a list of arguments used in each call to RayMock.IsRayServerReady.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsRayServerReady *mRayMockIsRayServerReady) Calls() []*RayMockIsRayServerReadyParams {
	mmIsRayServerReady.mutex.RLock()

	argCopy := make([]*RayMockIsRayServerReadyParams, len(mmIsRayServerReady.callArgs))
	copy(argCopy, mmIsRayServerReady.callArgs)

	mmIsRayServerReady.mutex.RUnlock()

	return argCopy
}

// MinimockIsRayServerReadyDone returns true if the count of the IsRayServerReady invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockIsRayServerReadyDone() bool {
	if m.IsRayServerReadyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsRayServerReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsRayServerReadyMock.invocationsDone()
}

// MinimockIsRayServerReadyInspect logs each unmet expectation
func (m *RayMock) MinimockIsRayServerReadyInspect() {
	for _, e := range m.IsRayServerReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.IsRayServerReady at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsRayServerReadyCounter := mm_atomic.LoadUint64(&m.afterIsRayServerReadyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsRayServerReadyMock.defaultExpectation != nil && afterIsRayServerReadyCounter < 1 {
		if m.IsRayServerReadyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.IsRayServerReady at\n%s", m.IsRayServerReadyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.IsRayServerReady at\n%s with params: %#v", m.IsRayServerReadyMock.defaultExpectation.expectationOrigins.origin, *m.IsRayServerReadyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRayServerReady != nil && afterIsRayServerReadyCounter < 1 {
		m.t.Errorf("Expected call to RayMock.IsRayServerReady at\n%s", m.funcIsRayServerReadyOrigin)
	}

	if !m.IsRayServerReadyMock.invocationsDone() && afterIsRayServerReadyCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.IsRayServerReady at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsRayServerReadyMock.expectedInvocations), m.IsRayServerReadyMock.expectedInvocationsOrigin, afterIsRayServerReadyCounter)
	}
}

type mRayMockModelInferRequest struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockModelInferRequestExpectation
	expectations       []*RayMockModelInferRequestExpectation

	callArgs []*RayMockModelInferRequestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockModelInferRequestExpectation specifies expectation struct of the Ray.ModelInferRequest
type RayMockModelInferRequestExpectation struct {
	mock               *RayMock
	params             *RayMockModelInferRequestParams
	paramPtrs          *RayMockModelInferRequestParamPtrs
	expectationOrigins RayMockModelInferRequestExpectationOrigins
	results            *RayMockModelInferRequestResults
	returnOrigin       string
	Counter            uint64
}

// RayMockModelInferRequestParams contains parameters of the Ray.ModelInferRequest
type RayMockModelInferRequestParams struct {
	ctx       context.Context
	task      commonpb.Task
	req       *modelpb.TriggerNamespaceModelRequest
	modelName string
	version   string
}

// RayMockModelInferRequestParamPtrs contains pointers to parameters of the Ray.ModelInferRequest
type RayMockModelInferRequestParamPtrs struct {
	ctx       *context.Context
	task      *commonpb.Task
	req       **modelpb.TriggerNamespaceModelRequest
	modelName *string
	version   *string
}

// RayMockModelInferRequestResults contains results of the Ray.ModelInferRequest
type RayMockModelInferRequestResults struct {
	cp1 *rayserver.CallResponse
	err error
}

// RayMockModelInferRequestOrigins contains origins of expectations of the Ray.ModelInferRequest
type RayMockModelInferRequestExpectationOrigins struct {
	origin          string
	originCtx       string
	originTask      string
	originReq       string
	originModelName string
	originVersion   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmModelInferRequest *mRayMockModelInferRequest) Optional() *mRayMockModelInferRequest {
	mmModelInferRequest.optional = true
	return mmModelInferRequest
}

// Expect sets up expected params for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Expect(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by ExpectParams functions")
	}

	mmModelInferRequest.defaultExpectation.params = &RayMockModelInferRequestParams{ctx, task, req, modelName, version}
	mmModelInferRequest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmModelInferRequest.expectations {
		if minimock.Equal(e.params, mmModelInferRequest.defaultExpectation.params) {
			mmModelInferRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmModelInferRequest.defaultExpectation.params)
		}
	}

	return mmModelInferRequest
}

// ExpectCtxParam1 sets up expected param ctx for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectCtxParam1(ctx context.Context) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.ctx = &ctx
	mmModelInferRequest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectTaskParam2 sets up expected param task for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectTaskParam2(task commonpb.Task) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.task = &task
	mmModelInferRequest.defaultExpectation.expectationOrigins.originTask = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectReqParam3 sets up expected param req for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectReqParam3(req *modelpb.TriggerNamespaceModelRequest) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.req = &req
	mmModelInferRequest.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectModelNameParam4 sets up expected param modelName for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectModelNameParam4(modelName string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.modelName = &modelName
	mmModelInferRequest.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectVersionParam5 sets up expected param version for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectVersionParam5(version string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.version = &version
	mmModelInferRequest.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// Inspect accepts an inspector function that has same arguments as the Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Inspect(f func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string)) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.inspectFuncModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("Inspect function is already set for RayMock.ModelInferRequest")
	}

	mmModelInferRequest.mock.inspectFuncModelInferRequest = f

	return mmModelInferRequest
}

// Return sets up results that will be returned by Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Return(cp1 *rayserver.CallResponse, err error) *RayMock {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{mock: mmModelInferRequest.mock}
	}
	mmModelInferRequest.defaultExpectation.results = &RayMockModelInferRequestResults{cp1, err}
	mmModelInferRequest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest.mock
}

// Set uses given function f to mock the Ray.ModelInferRequest method
func (mmModelInferRequest *mRayMockModelInferRequest) Set(f func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayserver.CallResponse, err error)) *RayMock {
	if mmModelInferRequest.defaultExpectation != nil {
		mmModelInferRequest.mock.t.Fatalf("Default expectation is already set for the Ray.ModelInferRequest method")
	}

	if len(mmModelInferRequest.expectations) > 0 {
		mmModelInferRequest.mock.t.Fatalf("Some expectations are already set for the Ray.ModelInferRequest method")
	}

	mmModelInferRequest.mock.funcModelInferRequest = f
	mmModelInferRequest.mock.funcModelInferRequestOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest.mock
}

// When sets expectation for the Ray.ModelInferRequest which will trigger the result defined by the following
// Then helper
func (mmModelInferRequest *mRayMockModelInferRequest) When(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) *RayMockModelInferRequestExpectation {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	expectation := &RayMockModelInferRequestExpectation{
		mock:               mmModelInferRequest.mock,
		params:             &RayMockModelInferRequestParams{ctx, task, req, modelName, version},
		expectationOrigins: RayMockModelInferRequestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmModelInferRequest.expectations = append(mmModelInferRequest.expectations, expectation)
	return expectation
}

// Then sets up Ray.ModelInferRequest return parameters for the expectation previously defined by the When method
func (e *RayMockModelInferRequestExpectation) Then(cp1 *rayserver.CallResponse, err error) *RayMock {
	e.results = &RayMockModelInferRequestResults{cp1, err}
	return e.mock
}

// Times sets number of times Ray.ModelInferRequest should be invoked
func (mmModelInferRequest *mRayMockModelInferRequest) Times(n uint64) *mRayMockModelInferRequest {
	if n == 0 {
		mmModelInferRequest.mock.t.Fatalf("Times of RayMock.ModelInferRequest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmModelInferRequest.expectedInvocations, n)
	mmModelInferRequest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest
}

func (mmModelInferRequest *mRayMockModelInferRequest) invocationsDone() bool {
	if len(mmModelInferRequest.expectations) == 0 && mmModelInferRequest.defaultExpectation == nil && mmModelInferRequest.mock.funcModelInferRequest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmModelInferRequest.mock.afterModelInferRequestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmModelInferRequest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ModelInferRequest implements mm_ray.Ray
func (mmModelInferRequest *RayMock) ModelInferRequest(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayserver.CallResponse, err error) {
	mm_atomic.AddUint64(&mmModelInferRequest.beforeModelInferRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmModelInferRequest.afterModelInferRequestCounter, 1)

	mmModelInferRequest.t.Helper()

	if mmModelInferRequest.inspectFuncModelInferRequest != nil {
		mmModelInferRequest.inspectFuncModelInferRequest(ctx, task, req, modelName, version)
	}

	mm_params := RayMockModelInferRequestParams{ctx, task, req, modelName, version}

	// Record call args
	mmModelInferRequest.ModelInferRequestMock.mutex.Lock()
	mmModelInferRequest.ModelInferRequestMock.callArgs = append(mmModelInferRequest.ModelInferRequestMock.callArgs, &mm_params)
	mmModelInferRequest.ModelInferRequestMock.mutex.Unlock()

	for _, e := range mmModelInferRequest.ModelInferRequestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmModelInferRequest.ModelInferRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmModelInferRequest.ModelInferRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.params
		mm_want_ptrs := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.paramPtrs

		mm_got := RayMockModelInferRequestParams{ctx, task, req, modelName, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.task != nil && !minimock.Equal(*mm_want_ptrs.task, mm_got.task) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter task, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originTask, *mm_want_ptrs.task, mm_got.task, minimock.Diff(*mm_want_ptrs.task, mm_got.task))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmModelInferRequest.t.Fatal("No results are set for the RayMock.ModelInferRequest")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmModelInferRequest.funcModelInferRequest != nil {
		return mmModelInferRequest.funcModelInferRequest(ctx, task, req, modelName, version)
	}
	mmModelInferRequest.t.Fatalf("Unexpected call to RayMock.ModelInferRequest. %v %v %v %v %v", ctx, task, req, modelName, version)
	return
}

// ModelInferRequestAfterCounter returns a count of finished RayMock.ModelInferRequest invocations
func (mmModelInferRequest *RayMock) ModelInferRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelInferRequest.afterModelInferRequestCounter)
}

// ModelInferRequestBeforeCounter returns a count of RayMock.ModelInferRequest invocations
func (mmModelInferRequest *RayMock) ModelInferRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelInferRequest.beforeModelInferRequestCounter)
}

// Calls returns a list of arguments used in each call to RayMock.ModelInferRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmModelInferRequest *mRayMockModelInferRequest) Calls() []*RayMockModelInferRequestParams {
	mmModelInferRequest.mutex.RLock()

	argCopy := make([]*RayMockModelInferRequestParams, len(mmModelInferRequest.callArgs))
	copy(argCopy, mmModelInferRequest.callArgs)

	mmModelInferRequest.mutex.RUnlock()

	return argCopy
}

// MinimockModelInferRequestDone returns true if the count of the ModelInferRequest invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockModelInferRequestDone() bool {
	if m.ModelInferRequestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ModelInferRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ModelInferRequestMock.invocationsDone()
}

// MinimockModelInferRequestInspect logs each unmet expectation
func (m *RayMock) MinimockModelInferRequestInspect() {
	for _, e := range m.ModelInferRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterModelInferRequestCounter := mm_atomic.LoadUint64(&m.afterModelInferRequestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ModelInferRequestMock.defaultExpectation != nil && afterModelInferRequestCounter < 1 {
		if m.ModelInferRequestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s", m.ModelInferRequestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s with params: %#v", m.ModelInferRequestMock.defaultExpectation.expectationOrigins.origin, *m.ModelInferRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcModelInferRequest != nil && afterModelInferRequestCounter < 1 {
		m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s", m.funcModelInferRequestOrigin)
	}

	if !m.ModelInferRequestMock.invocationsDone() && afterModelInferRequestCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.ModelInferRequest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ModelInferRequestMock.expectedInvocations), m.ModelInferRequestMock.expectedInvocationsOrigin, afterModelInferRequestCounter)
	}
}

type mRayMockModelReady struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockModelReadyExpectation
	expectations       []*RayMockModelReadyExpectation

	callArgs []*RayMockModelReadyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockModelReadyExpectation specifies expectation struct of the Ray.ModelReady
type RayMockModelReadyExpectation struct {
	mock               *RayMock
	params             *RayMockModelReadyParams
	paramPtrs          *RayMockModelReadyParamPtrs
	expectationOrigins RayMockModelReadyExpectationOrigins
	results            *RayMockModelReadyResults
	returnOrigin       string
	Counter            uint64
}

// RayMockModelReadyParams contains parameters of the Ray.ModelReady
type RayMockModelReadyParams struct {
	ctx       context.Context
	modelName string
	version   string
}

// RayMockModelReadyParamPtrs contains pointers to parameters of the Ray.ModelReady
type RayMockModelReadyParamPtrs struct {
	ctx       *context.Context
	modelName *string
	version   *string
}

// RayMockModelReadyResults contains results of the Ray.ModelReady
type RayMockModelReadyResults struct {
	sp1 *modelpb.State
	s1  string
	i1  int
	err error
}

// RayMockModelReadyOrigins contains origins of expectations of the Ray.ModelReady
type RayMockModelReadyExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelName string
	originVersion   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmModelReady *mRayMockModelReady) Optional() *mRayMockModelReady {
	mmModelReady.optional = true
	return mmModelReady
}

// Expect sets up expected params for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Expect(ctx context.Context, modelName string, version string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.paramPtrs != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by ExpectParams functions")
	}

	mmModelReady.defaultExpectation.params = &RayMockModelReadyParams{ctx, modelName, version}
	mmModelReady.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmModelReady.expectations {
		if minimock.Equal(e.params, mmModelReady.defaultExpectation.params) {
			mmModelReady.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmModelReady.defaultExpectation.params)
		}
	}

	return mmModelReady
}

// ExpectCtxParam1 sets up expected param ctx for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectCtxParam1(ctx context.Context) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.ctx = &ctx
	mmModelReady.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmModelReady
}

// ExpectModelNameParam2 sets up expected param modelName for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectModelNameParam2(modelName string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.modelName = &modelName
	mmModelReady.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmModelReady
}

// ExpectVersionParam3 sets up expected param version for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectVersionParam3(version string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.version = &version
	mmModelReady.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmModelReady
}

// Inspect accepts an inspector function that has same arguments as the Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Inspect(f func(ctx context.Context, modelName string, version string)) *mRayMockModelReady {
	if mmModelReady.mock.inspectFuncModelReady != nil {
		mmModelReady.mock.t.Fatalf("Inspect function is already set for RayMock.ModelReady")
	}

	mmModelReady.mock.inspectFuncModelReady = f

	return mmModelReady
}

// Return sets up results that will be returned by Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Return(sp1 *modelpb.State, s1 string, i1 int, err error) *RayMock {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{mock: mmModelReady.mock}
	}
	mmModelReady.defaultExpectation.results = &RayMockModelReadyResults{sp1, s1, i1, err}
	mmModelReady.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmModelReady.mock
}

// Set uses given function f to mock the Ray.ModelReady method
func (mmModelReady *mRayMockModelReady) Set(f func(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error)) *RayMock {
	if mmModelReady.defaultExpectation != nil {
		mmModelReady.mock.t.Fatalf("Default expectation is already set for the Ray.ModelReady method")
	}

	if len(mmModelReady.expectations) > 0 {
		mmModelReady.mock.t.Fatalf("Some expectations are already set for the Ray.ModelReady method")
	}

	mmModelReady.mock.funcModelReady = f
	mmModelReady.mock.funcModelReadyOrigin = minimock.CallerInfo(1)
	return mmModelReady.mock
}

// When sets expectation for the Ray.ModelReady which will trigger the result defined by the following
// Then helper
func (mmModelReady *mRayMockModelReady) When(ctx context.Context, modelName string, version string) *RayMockModelReadyExpectation {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	expectation := &RayMockModelReadyExpectation{
		mock:               mmModelReady.mock,
		params:             &RayMockModelReadyParams{ctx, modelName, version},
		expectationOrigins: RayMockModelReadyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmModelReady.expectations = append(mmModelReady.expectations, expectation)
	return expectation
}

// Then sets up Ray.ModelReady return parameters for the expectation previously defined by the When method
func (e *RayMockModelReadyExpectation) Then(sp1 *modelpb.State, s1 string, i1 int, err error) *RayMock {
	e.results = &RayMockModelReadyResults{sp1, s1, i1, err}
	return e.mock
}

// Times sets number of times Ray.ModelReady should be invoked
func (mmModelReady *mRayMockModelReady) Times(n uint64) *mRayMockModelReady {
	if n == 0 {
		mmModelReady.mock.t.Fatalf("Times of RayMock.ModelReady mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmModelReady.expectedInvocations, n)
	mmModelReady.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmModelReady
}

func (mmModelReady *mRayMockModelReady) invocationsDone() bool {
	if len(mmModelReady.expectations) == 0 && mmModelReady.defaultExpectation == nil && mmModelReady.mock.funcModelReady == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmModelReady.mock.afterModelReadyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmModelReady.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ModelReady implements mm_ray.Ray
func (mmModelReady *RayMock) ModelReady(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error) {
	mm_atomic.AddUint64(&mmModelReady.beforeModelReadyCounter, 1)
	defer mm_atomic.AddUint64(&mmModelReady.afterModelReadyCounter, 1)

	mmModelReady.t.Helper()

	if mmModelReady.inspectFuncModelReady != nil {
		mmModelReady.inspectFuncModelReady(ctx, modelName, version)
	}

	mm_params := RayMockModelReadyParams{ctx, modelName, version}

	// Record call args
	mmModelReady.ModelReadyMock.mutex.Lock()
	mmModelReady.ModelReadyMock.callArgs = append(mmModelReady.ModelReadyMock.callArgs, &mm_params)
	mmModelReady.ModelReadyMock.mutex.Unlock()

	for _, e := range mmModelReady.ModelReadyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.i1, e.results.err
		}
	}

	if mmModelReady.ModelReadyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmModelReady.ModelReadyMock.defaultExpectation.Counter, 1)
		mm_want := mmModelReady.ModelReadyMock.defaultExpectation.params
		mm_want_ptrs := mmModelReady.ModelReadyMock.defaultExpectation.paramPtrs

		mm_got := RayMockModelReadyParams{ctx, modelName, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmModelReady.ModelReadyMock.defaultExpectation.results
		if mm_results == nil {
			mmModelReady.t.Fatal("No results are set for the RayMock.ModelReady")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).i1, (*mm_results).err
	}
	if mmModelReady.funcModelReady != nil {
		return mmModelReady.funcModelReady(ctx, modelName, version)
	}
	mmModelReady.t.Fatalf("Unexpected call to RayMock.ModelReady. %v %v %v", ctx, modelName, version)
	return
}

// ModelReadyAfterCounter returns a count of finished RayMock.ModelReady invocations
func (mmModelReady *RayMock) ModelReadyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelReady.afterModelReadyCounter)
}

// ModelReadyBeforeCounter returns a count of RayMock.ModelReady invocations
func (mmModelReady *RayMock) ModelReadyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelReady.beforeModelReadyCounter)
}

// Calls returns a list of arguments used in each call to RayMock.ModelReady.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmModelReady *mRayMockModelReady) Calls() []*RayMockModelReadyParams {
	mmModelReady.mutex.RLock()

	argCopy := make([]*RayMockModelReadyParams, len(mmModelReady.callArgs))
	copy(argCopy, mmModelReady.callArgs)

	mmModelReady.mutex.RUnlock()

	return argCopy
}

// MinimockModelReadyDone returns true if the count of the ModelReady invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockModelReadyDone() bool {
	if m.ModelReadyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ModelReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ModelReadyMock.invocationsDone()
}

// MinimockModelReadyInspect logs each unmet expectation
func (m *RayMock) MinimockModelReadyInspect() {
	for _, e := range m.ModelReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterModelReadyCounter := mm_atomic.LoadUint64(&m.afterModelReadyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ModelReadyMock.defaultExpectation != nil && afterModelReadyCounter < 1 {
		if m.ModelReadyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s", m.ModelReadyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s with params: %#v", m.ModelReadyMock.defaultExpectation.expectationOrigins.origin, *m.ModelReadyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcModelReady != nil && afterModelReadyCounter < 1 {
		m.t.Errorf("Expected call to RayMock.ModelReady at\n%s", m.funcModelReadyOrigin)
	}

	if !m.ModelReadyMock.invocationsDone() && afterModelReadyCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.ModelReady at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ModelReadyMock.expectedInvocations), m.ModelReadyMock.expectedInvocationsOrigin, afterModelReadyCounter)
	}
}

type mRayMockUpdateContainerizedModel struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockUpdateContainerizedModelExpectation
	expectations       []*RayMockUpdateContainerizedModelExpectation

	callArgs []*RayMockUpdateContainerizedModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockUpdateContainerizedModelExpectation specifies expectation struct of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelExpectation struct {
	mock               *RayMock
	params             *RayMockUpdateContainerizedModelParams
	paramPtrs          *RayMockUpdateContainerizedModelParamPtrs
	expectationOrigins RayMockUpdateContainerizedModelExpectationOrigins
	results            *RayMockUpdateContainerizedModelResults
	returnOrigin       string
	Counter            uint64
}

// RayMockUpdateContainerizedModelParams contains parameters of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelParams struct {
	ctx           context.Context
	modelName     string
	userID        string
	imageName     string
	version       string
	hardware      string
	action        mm_ray.Action
	scalingConfig []string
}

// RayMockUpdateContainerizedModelParamPtrs contains pointers to parameters of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelParamPtrs struct {
	ctx           *context.Context
	modelName     *string
	userID        *string
	imageName     *string
	version       *string
	hardware      *string
	action        *mm_ray.Action
	scalingConfig *[]string
}

// RayMockUpdateContainerizedModelResults contains results of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelResults struct {
	err error
}

// RayMockUpdateContainerizedModelOrigins contains origins of expectations of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelExpectationOrigins struct {
	origin              string
	originCtx           string
	originModelName     string
	originUserID        string
	originImageName     string
	originVersion       string
	originHardware      string
	originAction        string
	originScalingConfig string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Optional() *mRayMockUpdateContainerizedModel {
	mmUpdateContainerizedModel.optional = true
	return mmUpdateContainerizedModel
}

// Expect sets up expected params for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Expect(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by ExpectParams functions")
	}

	mmUpdateContainerizedModel.defaultExpectation.params = &RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, scalingConfig}
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateContainerizedModel.expectations {
		if minimock.Equal(e.params, mmUpdateContainerizedModel.defaultExpectation.params) {
			mmUpdateContainerizedModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateContainerizedModel.defaultExpectation.params)
		}
	}

	return mmUpdateContainerizedModel
}

// ExpectCtxParam1 sets up expected param ctx for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectCtxParam1(ctx context.Context) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectModelNameParam2 sets up expected param modelName for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectModelNameParam2(modelName string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.modelName = &modelName
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectUserIDParam3 sets up expected param userID for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectUserIDParam3(userID string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectImageNameParam4 sets up expected param imageName for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectImageNameParam4(imageName string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.imageName = &imageName
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originImageName = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectVersionParam5 sets up expected param version for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectVersionParam5(version string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.version = &version
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectHardwareParam6 sets up expected param hardware for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectHardwareParam6(hardware string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.hardware = &hardware
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originHardware = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectActionParam7 sets up expected param action for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectActionParam7(action mm_ray.Action) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.action = &action
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originAction = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectScalingConfigParam8 sets up expected param scalingConfig for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectScalingConfigParam8(scalingConfig []string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.scalingConfig = &scalingConfig
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originScalingConfig = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// Inspect accepts an inspector function that has same arguments as the Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Inspect(f func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string)) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.inspectFuncUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("Inspect function is already set for RayMock.UpdateContainerizedModel")
	}

	mmUpdateContainerizedModel.mock.inspectFuncUpdateContainerizedModel = f

	return mmUpdateContainerizedModel
}

// Return sets up results that will be returned by Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Return(err error) *RayMock {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{mock: mmUpdateContainerizedModel.mock}
	}
	mmUpdateContainerizedModel.defaultExpectation.results = &RayMockUpdateContainerizedModelResults{err}
	mmUpdateContainerizedModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel.mock
}

// Set uses given function f to mock the Ray.UpdateContainerizedModel method
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Set(f func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string) (err error)) *RayMock {
	if mmUpdateContainerizedModel.defaultExpectation != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("Default expectation is already set for the Ray.UpdateContainerizedModel method")
	}

	if len(mmUpdateContainerizedModel.expectations) > 0 {
		mmUpdateContainerizedModel.mock.t.Fatalf("Some expectations are already set for the Ray.UpdateContainerizedModel method")
	}

	mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel = f
	mmUpdateContainerizedModel.mock.funcUpdateContainerizedModelOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel.mock
}

// When sets expectation for the Ray.UpdateContainerizedModel which will trigger the result defined by the following
// Then helper
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) When(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string) *RayMockUpdateContainerizedModelExpectation {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	expectation := &RayMockUpdateContainerizedModelExpectation{
		mock:               mmUpdateContainerizedModel.mock,
		params:             &RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, scalingConfig},
		expectationOrigins: RayMockUpdateContainerizedModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateContainerizedModel.expectations = append(mmUpdateContainerizedModel.expectations, expectation)
	return expectation
}

// Then sets up Ray.UpdateContainerizedModel return parameters for the expectation previously defined by the When method
func (e *RayMockUpdateContainerizedModelExpectation) Then(err error) *RayMock {
	e.results = &RayMockUpdateContainerizedModelResults{err}
	return e.mock
}

// Times sets number of times Ray.UpdateContainerizedModel should be invoked
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Times(n uint64) *mRayMockUpdateContainerizedModel {
	if n == 0 {
		mmUpdateContainerizedModel.mock.t.Fatalf("Times of RayMock.UpdateContainerizedModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateContainerizedModel.expectedInvocations, n)
	mmUpdateContainerizedModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel
}

func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) invocationsDone() bool {
	if len(mmUpdateContainerizedModel.expectations) == 0 && mmUpdateContainerizedModel.defaultExpectation == nil && mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateContainerizedModel.mock.afterUpdateContainerizedModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateContainerizedModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateContainerizedModel implements mm_ray.Ray
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModel(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, scalingConfig []string) (err error) {
	mm_atomic.AddUint64(&mmUpdateContainerizedModel.beforeUpdateContainerizedModelCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateContainerizedModel.afterUpdateContainerizedModelCounter, 1)

	mmUpdateContainerizedModel.t.Helper()

	if mmUpdateContainerizedModel.inspectFuncUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.inspectFuncUpdateContainerizedModel(ctx, modelName, userID, imageName, version, hardware, action, scalingConfig)
	}

	mm_params := RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, scalingConfig}

	// Record call args
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.mutex.Lock()
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.callArgs = append(mmUpdateContainerizedModel.UpdateContainerizedModelMock.callArgs, &mm_params)
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.mutex.Unlock()

	for _, e := range mmUpdateContainerizedModel.UpdateContainerizedModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.paramPtrs

		mm_got := RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, scalingConfig}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.imageName != nil && !minimock.Equal(*mm_want_ptrs.imageName, mm_got.imageName) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter imageName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originImageName, *mm_want_ptrs.imageName, mm_got.imageName, minimock.Diff(*mm_want_ptrs.imageName, mm_got.imageName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

			if mm_want_ptrs.hardware != nil && !minimock.Equal(*mm_want_ptrs.hardware, mm_got.hardware) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter hardware, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originHardware, *mm_want_ptrs.hardware, mm_got.hardware, minimock.Diff(*mm_want_ptrs.hardware, mm_got.hardware))
			}

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter action, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originAction, *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

			if mm_want_ptrs.scalingConfig != nil && !minimock.Equal(*mm_want_ptrs.scalingConfig, mm_got.scalingConfig) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter scalingConfig, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originScalingConfig, *mm_want_ptrs.scalingConfig, mm_got.scalingConfig, minimock.Diff(*mm_want_ptrs.scalingConfig, mm_got.scalingConfig))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateContainerizedModel.t.Fatal("No results are set for the RayMock.UpdateContainerizedModel")
		}
		return (*mm_results).err
	}
	if mmUpdateContainerizedModel.funcUpdateContainerizedModel != nil {
		return mmUpdateContainerizedModel.funcUpdateContainerizedModel(ctx, modelName, userID, imageName, version, hardware, action, scalingConfig)
	}
	mmUpdateContainerizedModel.t.Fatalf("Unexpected call to RayMock.UpdateContainerizedModel. %v %v %v %v %v %v %v %v", ctx, modelName, userID, imageName, version, hardware, action, scalingConfig)
	return
}

// UpdateContainerizedModelAfterCounter returns a count of finished RayMock.UpdateContainerizedModel invocations
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContainerizedModel.afterUpdateContainerizedModelCounter)
}

// UpdateContainerizedModelBeforeCounter returns a count of RayMock.UpdateContainerizedModel invocations
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContainerizedModel.beforeUpdateContainerizedModelCounter)
}

// Calls returns a list of arguments used in each call to RayMock.UpdateContainerizedModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Calls() []*RayMockUpdateContainerizedModelParams {
	mmUpdateContainerizedModel.mutex.RLock()

	argCopy := make([]*RayMockUpdateContainerizedModelParams, len(mmUpdateContainerizedModel.callArgs))
	copy(argCopy, mmUpdateContainerizedModel.callArgs)

	mmUpdateContainerizedModel.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateContainerizedModelDone returns true if the count of the UpdateContainerizedModel invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockUpdateContainerizedModelDone() bool {
	if m.UpdateContainerizedModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateContainerizedModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateContainerizedModelMock.invocationsDone()
}

// MinimockUpdateContainerizedModelInspect logs each unmet expectation
func (m *RayMock) MinimockUpdateContainerizedModelInspect() {
	for _, e := range m.UpdateContainerizedModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateContainerizedModelCounter := mm_atomic.LoadUint64(&m.afterUpdateContainerizedModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateContainerizedModelMock.defaultExpectation != nil && afterUpdateContainerizedModelCounter < 1 {
		if m.UpdateContainerizedModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s", m.UpdateContainerizedModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s with params: %#v", m.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.origin, *m.UpdateContainerizedModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateContainerizedModel != nil && afterUpdateContainerizedModelCounter < 1 {
		m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s", m.funcUpdateContainerizedModelOrigin)
	}

	if !m.UpdateContainerizedModelMock.invocationsDone() && afterUpdateContainerizedModelCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.UpdateContainerizedModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateContainerizedModelMock.expectedInvocations), m.UpdateContainerizedModelMock.expectedInvocationsOrigin, afterUpdateContainerizedModelCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RayMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockInitInspect()

			m.MinimockIsRayServerReadyInspect()

			m.MinimockModelInferRequestInspect()

			m.MinimockModelReadyInspect()

			m.MinimockUpdateContainerizedModelInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RayMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RayMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockInitDone() &&
		m.MinimockIsRayServerReadyDone() &&
		m.MinimockModelInferRequestDone() &&
		m.MinimockModelReadyDone() &&
		m.MinimockUpdateContainerizedModelDone()
}
