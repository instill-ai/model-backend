// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_ray "github.com/instill-ai/model-backend/pkg/ray"
	commonpb "github.com/instill-ai/protogen-go/common/task/v1alpha"
	modelpb "github.com/instill-ai/protogen-go/model/model/v1alpha"
	rayuserdefinedpb "github.com/instill-ai/protogen-go/model/ray/v1alpha"
	"github.com/redis/go-redis/v9"
)

// RayMock implements mm_ray.Ray
type RayMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func()
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRayMockClose

	funcInit          func(rc *redis.Client)
	funcInitOrigin    string
	inspectFuncInit   func(rc *redis.Client)
	afterInitCounter  uint64
	beforeInitCounter uint64
	InitMock          mRayMockInit

	funcIsRayReady          func(ctx context.Context) (b1 bool)
	funcIsRayReadyOrigin    string
	inspectFuncIsRayReady   func(ctx context.Context)
	afterIsRayReadyCounter  uint64
	beforeIsRayReadyCounter uint64
	IsRayReadyMock          mRayMockIsRayReady

	funcModelInferRequest          func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayuserdefinedpb.CallResponse, err error)
	funcModelInferRequestOrigin    string
	inspectFuncModelInferRequest   func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string)
	afterModelInferRequestCounter  uint64
	beforeModelInferRequestCounter uint64
	ModelInferRequestMock          mRayMockModelInferRequest

	funcModelReady          func(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error)
	funcModelReadyOrigin    string
	inspectFuncModelReady   func(ctx context.Context, modelName string, version string)
	afterModelReadyCounter  uint64
	beforeModelReadyCounter uint64
	ModelReadyMock          mRayMockModelReady

	funcUpdateContainerizedModel          func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string) (err error)
	funcUpdateContainerizedModelOrigin    string
	inspectFuncUpdateContainerizedModel   func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string)
	afterUpdateContainerizedModelCounter  uint64
	beforeUpdateContainerizedModelCounter uint64
	UpdateContainerizedModelMock          mRayMockUpdateContainerizedModel
}

// NewRayMock returns a mock for mm_ray.Ray
func NewRayMock(t minimock.Tester) *RayMock {
	m := &RayMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mRayMockClose{mock: m}

	m.InitMock = mRayMockInit{mock: m}
	m.InitMock.callArgs = []*RayMockInitParams{}

	m.IsRayReadyMock = mRayMockIsRayReady{mock: m}
	m.IsRayReadyMock.callArgs = []*RayMockIsRayReadyParams{}

	m.ModelInferRequestMock = mRayMockModelInferRequest{mock: m}
	m.ModelInferRequestMock.callArgs = []*RayMockModelInferRequestParams{}

	m.ModelReadyMock = mRayMockModelReady{mock: m}
	m.ModelReadyMock.callArgs = []*RayMockModelReadyParams{}

	m.UpdateContainerizedModelMock = mRayMockUpdateContainerizedModel{mock: m}
	m.UpdateContainerizedModelMock.callArgs = []*RayMockUpdateContainerizedModelParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRayMockClose struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockCloseExpectation
	expectations       []*RayMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockCloseExpectation specifies expectation struct of the Ray.Close
type RayMockCloseExpectation struct {
	mock *RayMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mRayMockClose) Optional() *mRayMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Ray.Close
func (mmClose *mRayMockClose) Expect() *mRayMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RayMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RayMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Ray.Close
func (mmClose *mRayMockClose) Inspect(f func()) *mRayMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RayMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Ray.Close
func (mmClose *mRayMockClose) Return() *RayMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RayMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RayMockCloseExpectation{mock: mmClose.mock}
	}

	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the Ray.Close method
func (mmClose *mRayMockClose) Set(f func()) *RayMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Ray.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Ray.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times Ray.Close should be invoked
func (mmClose *mRayMockClose) Times(n uint64) *mRayMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of RayMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mRayMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_ray.Ray
func (mmClose *RayMock) Close() {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClose.funcClose != nil {
		mmClose.funcClose()
		return
	}
	mmClose.t.Fatalf("Unexpected call to RayMock.Close.")

}

// CloseAfterCounter returns a count of finished RayMock.Close invocations
func (mmClose *RayMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RayMock.Close invocations
func (mmClose *RayMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *RayMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RayMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mRayMockInit struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockInitExpectation
	expectations       []*RayMockInitExpectation

	callArgs []*RayMockInitParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockInitExpectation specifies expectation struct of the Ray.Init
type RayMockInitExpectation struct {
	mock               *RayMock
	params             *RayMockInitParams
	paramPtrs          *RayMockInitParamPtrs
	expectationOrigins RayMockInitExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RayMockInitParams contains parameters of the Ray.Init
type RayMockInitParams struct {
	rc *redis.Client
}

// RayMockInitParamPtrs contains pointers to parameters of the Ray.Init
type RayMockInitParamPtrs struct {
	rc **redis.Client
}

// RayMockInitOrigins contains origins of expectations of the Ray.Init
type RayMockInitExpectationOrigins struct {
	origin   string
	originRc string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInit *mRayMockInit) Optional() *mRayMockInit {
	mmInit.optional = true
	return mmInit
}

// Expect sets up expected params for Ray.Init
func (mmInit *mRayMockInit) Expect(rc *redis.Client) *mRayMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RayMockInitExpectation{}
	}

	if mmInit.defaultExpectation.paramPtrs != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by ExpectParams functions")
	}

	mmInit.defaultExpectation.params = &RayMockInitParams{rc}
	mmInit.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInit.expectations {
		if minimock.Equal(e.params, mmInit.defaultExpectation.params) {
			mmInit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInit.defaultExpectation.params)
		}
	}

	return mmInit
}

// ExpectRcParam1 sets up expected param rc for Ray.Init
func (mmInit *mRayMockInit) ExpectRcParam1(rc *redis.Client) *mRayMockInit {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RayMockInitExpectation{}
	}

	if mmInit.defaultExpectation.params != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Expect")
	}

	if mmInit.defaultExpectation.paramPtrs == nil {
		mmInit.defaultExpectation.paramPtrs = &RayMockInitParamPtrs{}
	}
	mmInit.defaultExpectation.paramPtrs.rc = &rc
	mmInit.defaultExpectation.expectationOrigins.originRc = minimock.CallerInfo(1)

	return mmInit
}

// Inspect accepts an inspector function that has same arguments as the Ray.Init
func (mmInit *mRayMockInit) Inspect(f func(rc *redis.Client)) *mRayMockInit {
	if mmInit.mock.inspectFuncInit != nil {
		mmInit.mock.t.Fatalf("Inspect function is already set for RayMock.Init")
	}

	mmInit.mock.inspectFuncInit = f

	return mmInit
}

// Return sets up results that will be returned by Ray.Init
func (mmInit *mRayMockInit) Return() *RayMock {
	if mmInit.mock.funcInit != nil {
		mmInit.mock.t.Fatalf("RayMock.Init mock is already set by Set")
	}

	if mmInit.defaultExpectation == nil {
		mmInit.defaultExpectation = &RayMockInitExpectation{mock: mmInit.mock}
	}

	mmInit.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInit.mock
}

// Set uses given function f to mock the Ray.Init method
func (mmInit *mRayMockInit) Set(f func(rc *redis.Client)) *RayMock {
	if mmInit.defaultExpectation != nil {
		mmInit.mock.t.Fatalf("Default expectation is already set for the Ray.Init method")
	}

	if len(mmInit.expectations) > 0 {
		mmInit.mock.t.Fatalf("Some expectations are already set for the Ray.Init method")
	}

	mmInit.mock.funcInit = f
	mmInit.mock.funcInitOrigin = minimock.CallerInfo(1)
	return mmInit.mock
}

// Times sets number of times Ray.Init should be invoked
func (mmInit *mRayMockInit) Times(n uint64) *mRayMockInit {
	if n == 0 {
		mmInit.mock.t.Fatalf("Times of RayMock.Init mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInit.expectedInvocations, n)
	mmInit.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInit
}

func (mmInit *mRayMockInit) invocationsDone() bool {
	if len(mmInit.expectations) == 0 && mmInit.defaultExpectation == nil && mmInit.mock.funcInit == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInit.mock.afterInitCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInit.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Init implements mm_ray.Ray
func (mmInit *RayMock) Init(rc *redis.Client) {
	mm_atomic.AddUint64(&mmInit.beforeInitCounter, 1)
	defer mm_atomic.AddUint64(&mmInit.afterInitCounter, 1)

	mmInit.t.Helper()

	if mmInit.inspectFuncInit != nil {
		mmInit.inspectFuncInit(rc)
	}

	mm_params := RayMockInitParams{rc}

	// Record call args
	mmInit.InitMock.mutex.Lock()
	mmInit.InitMock.callArgs = append(mmInit.InitMock.callArgs, &mm_params)
	mmInit.InitMock.mutex.Unlock()

	for _, e := range mmInit.InitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmInit.InitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInit.InitMock.defaultExpectation.Counter, 1)
		mm_want := mmInit.InitMock.defaultExpectation.params
		mm_want_ptrs := mmInit.InitMock.defaultExpectation.paramPtrs

		mm_got := RayMockInitParams{rc}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.rc != nil && !minimock.Equal(*mm_want_ptrs.rc, mm_got.rc) {
				mmInit.t.Errorf("RayMock.Init got unexpected parameter rc, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInit.InitMock.defaultExpectation.expectationOrigins.originRc, *mm_want_ptrs.rc, mm_got.rc, minimock.Diff(*mm_want_ptrs.rc, mm_got.rc))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInit.t.Errorf("RayMock.Init got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInit.InitMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmInit.funcInit != nil {
		mmInit.funcInit(rc)
		return
	}
	mmInit.t.Fatalf("Unexpected call to RayMock.Init. %v", rc)

}

// InitAfterCounter returns a count of finished RayMock.Init invocations
func (mmInit *RayMock) InitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.afterInitCounter)
}

// InitBeforeCounter returns a count of RayMock.Init invocations
func (mmInit *RayMock) InitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInit.beforeInitCounter)
}

// Calls returns a list of arguments used in each call to RayMock.Init.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInit *mRayMockInit) Calls() []*RayMockInitParams {
	mmInit.mutex.RLock()

	argCopy := make([]*RayMockInitParams, len(mmInit.callArgs))
	copy(argCopy, mmInit.callArgs)

	mmInit.mutex.RUnlock()

	return argCopy
}

// MinimockInitDone returns true if the count of the Init invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockInitDone() bool {
	if m.InitMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InitMock.invocationsDone()
}

// MinimockInitInspect logs each unmet expectation
func (m *RayMock) MinimockInitInspect() {
	for _, e := range m.InitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.Init at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInitCounter := mm_atomic.LoadUint64(&m.afterInitCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InitMock.defaultExpectation != nil && afterInitCounter < 1 {
		if m.InitMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.Init at\n%s", m.InitMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.Init at\n%s with params: %#v", m.InitMock.defaultExpectation.expectationOrigins.origin, *m.InitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInit != nil && afterInitCounter < 1 {
		m.t.Errorf("Expected call to RayMock.Init at\n%s", m.funcInitOrigin)
	}

	if !m.InitMock.invocationsDone() && afterInitCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.Init at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InitMock.expectedInvocations), m.InitMock.expectedInvocationsOrigin, afterInitCounter)
	}
}

type mRayMockIsRayReady struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockIsRayReadyExpectation
	expectations       []*RayMockIsRayReadyExpectation

	callArgs []*RayMockIsRayReadyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockIsRayReadyExpectation specifies expectation struct of the Ray.IsRayReady
type RayMockIsRayReadyExpectation struct {
	mock               *RayMock
	params             *RayMockIsRayReadyParams
	paramPtrs          *RayMockIsRayReadyParamPtrs
	expectationOrigins RayMockIsRayReadyExpectationOrigins
	results            *RayMockIsRayReadyResults
	returnOrigin       string
	Counter            uint64
}

// RayMockIsRayReadyParams contains parameters of the Ray.IsRayReady
type RayMockIsRayReadyParams struct {
	ctx context.Context
}

// RayMockIsRayReadyParamPtrs contains pointers to parameters of the Ray.IsRayReady
type RayMockIsRayReadyParamPtrs struct {
	ctx *context.Context
}

// RayMockIsRayReadyResults contains results of the Ray.IsRayReady
type RayMockIsRayReadyResults struct {
	b1 bool
}

// RayMockIsRayReadyOrigins contains origins of expectations of the Ray.IsRayReady
type RayMockIsRayReadyExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsRayReady *mRayMockIsRayReady) Optional() *mRayMockIsRayReady {
	mmIsRayReady.optional = true
	return mmIsRayReady
}

// Expect sets up expected params for Ray.IsRayReady
func (mmIsRayReady *mRayMockIsRayReady) Expect(ctx context.Context) *mRayMockIsRayReady {
	if mmIsRayReady.mock.funcIsRayReady != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by Set")
	}

	if mmIsRayReady.defaultExpectation == nil {
		mmIsRayReady.defaultExpectation = &RayMockIsRayReadyExpectation{}
	}

	if mmIsRayReady.defaultExpectation.paramPtrs != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by ExpectParams functions")
	}

	mmIsRayReady.defaultExpectation.params = &RayMockIsRayReadyParams{ctx}
	mmIsRayReady.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsRayReady.expectations {
		if minimock.Equal(e.params, mmIsRayReady.defaultExpectation.params) {
			mmIsRayReady.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsRayReady.defaultExpectation.params)
		}
	}

	return mmIsRayReady
}

// ExpectCtxParam1 sets up expected param ctx for Ray.IsRayReady
func (mmIsRayReady *mRayMockIsRayReady) ExpectCtxParam1(ctx context.Context) *mRayMockIsRayReady {
	if mmIsRayReady.mock.funcIsRayReady != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by Set")
	}

	if mmIsRayReady.defaultExpectation == nil {
		mmIsRayReady.defaultExpectation = &RayMockIsRayReadyExpectation{}
	}

	if mmIsRayReady.defaultExpectation.params != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by Expect")
	}

	if mmIsRayReady.defaultExpectation.paramPtrs == nil {
		mmIsRayReady.defaultExpectation.paramPtrs = &RayMockIsRayReadyParamPtrs{}
	}
	mmIsRayReady.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsRayReady.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsRayReady
}

// Inspect accepts an inspector function that has same arguments as the Ray.IsRayReady
func (mmIsRayReady *mRayMockIsRayReady) Inspect(f func(ctx context.Context)) *mRayMockIsRayReady {
	if mmIsRayReady.mock.inspectFuncIsRayReady != nil {
		mmIsRayReady.mock.t.Fatalf("Inspect function is already set for RayMock.IsRayReady")
	}

	mmIsRayReady.mock.inspectFuncIsRayReady = f

	return mmIsRayReady
}

// Return sets up results that will be returned by Ray.IsRayReady
func (mmIsRayReady *mRayMockIsRayReady) Return(b1 bool) *RayMock {
	if mmIsRayReady.mock.funcIsRayReady != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by Set")
	}

	if mmIsRayReady.defaultExpectation == nil {
		mmIsRayReady.defaultExpectation = &RayMockIsRayReadyExpectation{mock: mmIsRayReady.mock}
	}
	mmIsRayReady.defaultExpectation.results = &RayMockIsRayReadyResults{b1}
	mmIsRayReady.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsRayReady.mock
}

// Set uses given function f to mock the Ray.IsRayReady method
func (mmIsRayReady *mRayMockIsRayReady) Set(f func(ctx context.Context) (b1 bool)) *RayMock {
	if mmIsRayReady.defaultExpectation != nil {
		mmIsRayReady.mock.t.Fatalf("Default expectation is already set for the Ray.IsRayReady method")
	}

	if len(mmIsRayReady.expectations) > 0 {
		mmIsRayReady.mock.t.Fatalf("Some expectations are already set for the Ray.IsRayReady method")
	}

	mmIsRayReady.mock.funcIsRayReady = f
	mmIsRayReady.mock.funcIsRayReadyOrigin = minimock.CallerInfo(1)
	return mmIsRayReady.mock
}

// When sets expectation for the Ray.IsRayReady which will trigger the result defined by the following
// Then helper
func (mmIsRayReady *mRayMockIsRayReady) When(ctx context.Context) *RayMockIsRayReadyExpectation {
	if mmIsRayReady.mock.funcIsRayReady != nil {
		mmIsRayReady.mock.t.Fatalf("RayMock.IsRayReady mock is already set by Set")
	}

	expectation := &RayMockIsRayReadyExpectation{
		mock:               mmIsRayReady.mock,
		params:             &RayMockIsRayReadyParams{ctx},
		expectationOrigins: RayMockIsRayReadyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsRayReady.expectations = append(mmIsRayReady.expectations, expectation)
	return expectation
}

// Then sets up Ray.IsRayReady return parameters for the expectation previously defined by the When method
func (e *RayMockIsRayReadyExpectation) Then(b1 bool) *RayMock {
	e.results = &RayMockIsRayReadyResults{b1}
	return e.mock
}

// Times sets number of times Ray.IsRayReady should be invoked
func (mmIsRayReady *mRayMockIsRayReady) Times(n uint64) *mRayMockIsRayReady {
	if n == 0 {
		mmIsRayReady.mock.t.Fatalf("Times of RayMock.IsRayReady mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsRayReady.expectedInvocations, n)
	mmIsRayReady.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsRayReady
}

func (mmIsRayReady *mRayMockIsRayReady) invocationsDone() bool {
	if len(mmIsRayReady.expectations) == 0 && mmIsRayReady.defaultExpectation == nil && mmIsRayReady.mock.funcIsRayReady == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsRayReady.mock.afterIsRayReadyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsRayReady.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsRayReady implements mm_ray.Ray
func (mmIsRayReady *RayMock) IsRayReady(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmIsRayReady.beforeIsRayReadyCounter, 1)
	defer mm_atomic.AddUint64(&mmIsRayReady.afterIsRayReadyCounter, 1)

	mmIsRayReady.t.Helper()

	if mmIsRayReady.inspectFuncIsRayReady != nil {
		mmIsRayReady.inspectFuncIsRayReady(ctx)
	}

	mm_params := RayMockIsRayReadyParams{ctx}

	// Record call args
	mmIsRayReady.IsRayReadyMock.mutex.Lock()
	mmIsRayReady.IsRayReadyMock.callArgs = append(mmIsRayReady.IsRayReadyMock.callArgs, &mm_params)
	mmIsRayReady.IsRayReadyMock.mutex.Unlock()

	for _, e := range mmIsRayReady.IsRayReadyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsRayReady.IsRayReadyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsRayReady.IsRayReadyMock.defaultExpectation.Counter, 1)
		mm_want := mmIsRayReady.IsRayReadyMock.defaultExpectation.params
		mm_want_ptrs := mmIsRayReady.IsRayReadyMock.defaultExpectation.paramPtrs

		mm_got := RayMockIsRayReadyParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsRayReady.t.Errorf("RayMock.IsRayReady got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsRayReady.IsRayReadyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsRayReady.t.Errorf("RayMock.IsRayReady got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsRayReady.IsRayReadyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsRayReady.IsRayReadyMock.defaultExpectation.results
		if mm_results == nil {
			mmIsRayReady.t.Fatal("No results are set for the RayMock.IsRayReady")
		}
		return (*mm_results).b1
	}
	if mmIsRayReady.funcIsRayReady != nil {
		return mmIsRayReady.funcIsRayReady(ctx)
	}
	mmIsRayReady.t.Fatalf("Unexpected call to RayMock.IsRayReady. %v", ctx)
	return
}

// IsRayReadyAfterCounter returns a count of finished RayMock.IsRayReady invocations
func (mmIsRayReady *RayMock) IsRayReadyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRayReady.afterIsRayReadyCounter)
}

// IsRayReadyBeforeCounter returns a count of RayMock.IsRayReady invocations
func (mmIsRayReady *RayMock) IsRayReadyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsRayReady.beforeIsRayReadyCounter)
}

// Calls returns a list of arguments used in each call to RayMock.IsRayReady.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsRayReady *mRayMockIsRayReady) Calls() []*RayMockIsRayReadyParams {
	mmIsRayReady.mutex.RLock()

	argCopy := make([]*RayMockIsRayReadyParams, len(mmIsRayReady.callArgs))
	copy(argCopy, mmIsRayReady.callArgs)

	mmIsRayReady.mutex.RUnlock()

	return argCopy
}

// MinimockIsRayReadyDone returns true if the count of the IsRayReady invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockIsRayReadyDone() bool {
	if m.IsRayReadyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsRayReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsRayReadyMock.invocationsDone()
}

// MinimockIsRayReadyInspect logs each unmet expectation
func (m *RayMock) MinimockIsRayReadyInspect() {
	for _, e := range m.IsRayReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.IsRayReady at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsRayReadyCounter := mm_atomic.LoadUint64(&m.afterIsRayReadyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsRayReadyMock.defaultExpectation != nil && afterIsRayReadyCounter < 1 {
		if m.IsRayReadyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.IsRayReady at\n%s", m.IsRayReadyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.IsRayReady at\n%s with params: %#v", m.IsRayReadyMock.defaultExpectation.expectationOrigins.origin, *m.IsRayReadyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsRayReady != nil && afterIsRayReadyCounter < 1 {
		m.t.Errorf("Expected call to RayMock.IsRayReady at\n%s", m.funcIsRayReadyOrigin)
	}

	if !m.IsRayReadyMock.invocationsDone() && afterIsRayReadyCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.IsRayReady at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsRayReadyMock.expectedInvocations), m.IsRayReadyMock.expectedInvocationsOrigin, afterIsRayReadyCounter)
	}
}

type mRayMockModelInferRequest struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockModelInferRequestExpectation
	expectations       []*RayMockModelInferRequestExpectation

	callArgs []*RayMockModelInferRequestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockModelInferRequestExpectation specifies expectation struct of the Ray.ModelInferRequest
type RayMockModelInferRequestExpectation struct {
	mock               *RayMock
	params             *RayMockModelInferRequestParams
	paramPtrs          *RayMockModelInferRequestParamPtrs
	expectationOrigins RayMockModelInferRequestExpectationOrigins
	results            *RayMockModelInferRequestResults
	returnOrigin       string
	Counter            uint64
}

// RayMockModelInferRequestParams contains parameters of the Ray.ModelInferRequest
type RayMockModelInferRequestParams struct {
	ctx       context.Context
	task      commonpb.Task
	req       *modelpb.TriggerNamespaceModelRequest
	modelName string
	version   string
}

// RayMockModelInferRequestParamPtrs contains pointers to parameters of the Ray.ModelInferRequest
type RayMockModelInferRequestParamPtrs struct {
	ctx       *context.Context
	task      *commonpb.Task
	req       **modelpb.TriggerNamespaceModelRequest
	modelName *string
	version   *string
}

// RayMockModelInferRequestResults contains results of the Ray.ModelInferRequest
type RayMockModelInferRequestResults struct {
	cp1 *rayuserdefinedpb.CallResponse
	err error
}

// RayMockModelInferRequestOrigins contains origins of expectations of the Ray.ModelInferRequest
type RayMockModelInferRequestExpectationOrigins struct {
	origin          string
	originCtx       string
	originTask      string
	originReq       string
	originModelName string
	originVersion   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmModelInferRequest *mRayMockModelInferRequest) Optional() *mRayMockModelInferRequest {
	mmModelInferRequest.optional = true
	return mmModelInferRequest
}

// Expect sets up expected params for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Expect(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by ExpectParams functions")
	}

	mmModelInferRequest.defaultExpectation.params = &RayMockModelInferRequestParams{ctx, task, req, modelName, version}
	mmModelInferRequest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmModelInferRequest.expectations {
		if minimock.Equal(e.params, mmModelInferRequest.defaultExpectation.params) {
			mmModelInferRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmModelInferRequest.defaultExpectation.params)
		}
	}

	return mmModelInferRequest
}

// ExpectCtxParam1 sets up expected param ctx for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectCtxParam1(ctx context.Context) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.ctx = &ctx
	mmModelInferRequest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectTaskParam2 sets up expected param task for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectTaskParam2(task commonpb.Task) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.task = &task
	mmModelInferRequest.defaultExpectation.expectationOrigins.originTask = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectReqParam3 sets up expected param req for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectReqParam3(req *modelpb.TriggerNamespaceModelRequest) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.req = &req
	mmModelInferRequest.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectModelNameParam4 sets up expected param modelName for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectModelNameParam4(modelName string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.modelName = &modelName
	mmModelInferRequest.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// ExpectVersionParam5 sets up expected param version for Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) ExpectVersionParam5(version string) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{}
	}

	if mmModelInferRequest.defaultExpectation.params != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Expect")
	}

	if mmModelInferRequest.defaultExpectation.paramPtrs == nil {
		mmModelInferRequest.defaultExpectation.paramPtrs = &RayMockModelInferRequestParamPtrs{}
	}
	mmModelInferRequest.defaultExpectation.paramPtrs.version = &version
	mmModelInferRequest.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmModelInferRequest
}

// Inspect accepts an inspector function that has same arguments as the Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Inspect(f func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string)) *mRayMockModelInferRequest {
	if mmModelInferRequest.mock.inspectFuncModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("Inspect function is already set for RayMock.ModelInferRequest")
	}

	mmModelInferRequest.mock.inspectFuncModelInferRequest = f

	return mmModelInferRequest
}

// Return sets up results that will be returned by Ray.ModelInferRequest
func (mmModelInferRequest *mRayMockModelInferRequest) Return(cp1 *rayuserdefinedpb.CallResponse, err error) *RayMock {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	if mmModelInferRequest.defaultExpectation == nil {
		mmModelInferRequest.defaultExpectation = &RayMockModelInferRequestExpectation{mock: mmModelInferRequest.mock}
	}
	mmModelInferRequest.defaultExpectation.results = &RayMockModelInferRequestResults{cp1, err}
	mmModelInferRequest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest.mock
}

// Set uses given function f to mock the Ray.ModelInferRequest method
func (mmModelInferRequest *mRayMockModelInferRequest) Set(f func(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayuserdefinedpb.CallResponse, err error)) *RayMock {
	if mmModelInferRequest.defaultExpectation != nil {
		mmModelInferRequest.mock.t.Fatalf("Default expectation is already set for the Ray.ModelInferRequest method")
	}

	if len(mmModelInferRequest.expectations) > 0 {
		mmModelInferRequest.mock.t.Fatalf("Some expectations are already set for the Ray.ModelInferRequest method")
	}

	mmModelInferRequest.mock.funcModelInferRequest = f
	mmModelInferRequest.mock.funcModelInferRequestOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest.mock
}

// When sets expectation for the Ray.ModelInferRequest which will trigger the result defined by the following
// Then helper
func (mmModelInferRequest *mRayMockModelInferRequest) When(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) *RayMockModelInferRequestExpectation {
	if mmModelInferRequest.mock.funcModelInferRequest != nil {
		mmModelInferRequest.mock.t.Fatalf("RayMock.ModelInferRequest mock is already set by Set")
	}

	expectation := &RayMockModelInferRequestExpectation{
		mock:               mmModelInferRequest.mock,
		params:             &RayMockModelInferRequestParams{ctx, task, req, modelName, version},
		expectationOrigins: RayMockModelInferRequestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmModelInferRequest.expectations = append(mmModelInferRequest.expectations, expectation)
	return expectation
}

// Then sets up Ray.ModelInferRequest return parameters for the expectation previously defined by the When method
func (e *RayMockModelInferRequestExpectation) Then(cp1 *rayuserdefinedpb.CallResponse, err error) *RayMock {
	e.results = &RayMockModelInferRequestResults{cp1, err}
	return e.mock
}

// Times sets number of times Ray.ModelInferRequest should be invoked
func (mmModelInferRequest *mRayMockModelInferRequest) Times(n uint64) *mRayMockModelInferRequest {
	if n == 0 {
		mmModelInferRequest.mock.t.Fatalf("Times of RayMock.ModelInferRequest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmModelInferRequest.expectedInvocations, n)
	mmModelInferRequest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmModelInferRequest
}

func (mmModelInferRequest *mRayMockModelInferRequest) invocationsDone() bool {
	if len(mmModelInferRequest.expectations) == 0 && mmModelInferRequest.defaultExpectation == nil && mmModelInferRequest.mock.funcModelInferRequest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmModelInferRequest.mock.afterModelInferRequestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmModelInferRequest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ModelInferRequest implements mm_ray.Ray
func (mmModelInferRequest *RayMock) ModelInferRequest(ctx context.Context, task commonpb.Task, req *modelpb.TriggerNamespaceModelRequest, modelName string, version string) (cp1 *rayuserdefinedpb.CallResponse, err error) {
	mm_atomic.AddUint64(&mmModelInferRequest.beforeModelInferRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmModelInferRequest.afterModelInferRequestCounter, 1)

	mmModelInferRequest.t.Helper()

	if mmModelInferRequest.inspectFuncModelInferRequest != nil {
		mmModelInferRequest.inspectFuncModelInferRequest(ctx, task, req, modelName, version)
	}

	mm_params := RayMockModelInferRequestParams{ctx, task, req, modelName, version}

	// Record call args
	mmModelInferRequest.ModelInferRequestMock.mutex.Lock()
	mmModelInferRequest.ModelInferRequestMock.callArgs = append(mmModelInferRequest.ModelInferRequestMock.callArgs, &mm_params)
	mmModelInferRequest.ModelInferRequestMock.mutex.Unlock()

	for _, e := range mmModelInferRequest.ModelInferRequestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmModelInferRequest.ModelInferRequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmModelInferRequest.ModelInferRequestMock.defaultExpectation.Counter, 1)
		mm_want := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.params
		mm_want_ptrs := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.paramPtrs

		mm_got := RayMockModelInferRequestParams{ctx, task, req, modelName, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.task != nil && !minimock.Equal(*mm_want_ptrs.task, mm_got.task) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter task, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originTask, *mm_want_ptrs.task, mm_got.task, minimock.Diff(*mm_want_ptrs.task, mm_got.task))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmModelInferRequest.t.Errorf("RayMock.ModelInferRequest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmModelInferRequest.ModelInferRequestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmModelInferRequest.ModelInferRequestMock.defaultExpectation.results
		if mm_results == nil {
			mmModelInferRequest.t.Fatal("No results are set for the RayMock.ModelInferRequest")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmModelInferRequest.funcModelInferRequest != nil {
		return mmModelInferRequest.funcModelInferRequest(ctx, task, req, modelName, version)
	}
	mmModelInferRequest.t.Fatalf("Unexpected call to RayMock.ModelInferRequest. %v %v %v %v %v", ctx, task, req, modelName, version)
	return
}

// ModelInferRequestAfterCounter returns a count of finished RayMock.ModelInferRequest invocations
func (mmModelInferRequest *RayMock) ModelInferRequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelInferRequest.afterModelInferRequestCounter)
}

// ModelInferRequestBeforeCounter returns a count of RayMock.ModelInferRequest invocations
func (mmModelInferRequest *RayMock) ModelInferRequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelInferRequest.beforeModelInferRequestCounter)
}

// Calls returns a list of arguments used in each call to RayMock.ModelInferRequest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmModelInferRequest *mRayMockModelInferRequest) Calls() []*RayMockModelInferRequestParams {
	mmModelInferRequest.mutex.RLock()

	argCopy := make([]*RayMockModelInferRequestParams, len(mmModelInferRequest.callArgs))
	copy(argCopy, mmModelInferRequest.callArgs)

	mmModelInferRequest.mutex.RUnlock()

	return argCopy
}

// MinimockModelInferRequestDone returns true if the count of the ModelInferRequest invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockModelInferRequestDone() bool {
	if m.ModelInferRequestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ModelInferRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ModelInferRequestMock.invocationsDone()
}

// MinimockModelInferRequestInspect logs each unmet expectation
func (m *RayMock) MinimockModelInferRequestInspect() {
	for _, e := range m.ModelInferRequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterModelInferRequestCounter := mm_atomic.LoadUint64(&m.afterModelInferRequestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ModelInferRequestMock.defaultExpectation != nil && afterModelInferRequestCounter < 1 {
		if m.ModelInferRequestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s", m.ModelInferRequestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s with params: %#v", m.ModelInferRequestMock.defaultExpectation.expectationOrigins.origin, *m.ModelInferRequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcModelInferRequest != nil && afterModelInferRequestCounter < 1 {
		m.t.Errorf("Expected call to RayMock.ModelInferRequest at\n%s", m.funcModelInferRequestOrigin)
	}

	if !m.ModelInferRequestMock.invocationsDone() && afterModelInferRequestCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.ModelInferRequest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ModelInferRequestMock.expectedInvocations), m.ModelInferRequestMock.expectedInvocationsOrigin, afterModelInferRequestCounter)
	}
}

type mRayMockModelReady struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockModelReadyExpectation
	expectations       []*RayMockModelReadyExpectation

	callArgs []*RayMockModelReadyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockModelReadyExpectation specifies expectation struct of the Ray.ModelReady
type RayMockModelReadyExpectation struct {
	mock               *RayMock
	params             *RayMockModelReadyParams
	paramPtrs          *RayMockModelReadyParamPtrs
	expectationOrigins RayMockModelReadyExpectationOrigins
	results            *RayMockModelReadyResults
	returnOrigin       string
	Counter            uint64
}

// RayMockModelReadyParams contains parameters of the Ray.ModelReady
type RayMockModelReadyParams struct {
	ctx       context.Context
	modelName string
	version   string
}

// RayMockModelReadyParamPtrs contains pointers to parameters of the Ray.ModelReady
type RayMockModelReadyParamPtrs struct {
	ctx       *context.Context
	modelName *string
	version   *string
}

// RayMockModelReadyResults contains results of the Ray.ModelReady
type RayMockModelReadyResults struct {
	sp1 *modelpb.State
	s1  string
	i1  int
	err error
}

// RayMockModelReadyOrigins contains origins of expectations of the Ray.ModelReady
type RayMockModelReadyExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelName string
	originVersion   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmModelReady *mRayMockModelReady) Optional() *mRayMockModelReady {
	mmModelReady.optional = true
	return mmModelReady
}

// Expect sets up expected params for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Expect(ctx context.Context, modelName string, version string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.paramPtrs != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by ExpectParams functions")
	}

	mmModelReady.defaultExpectation.params = &RayMockModelReadyParams{ctx, modelName, version}
	mmModelReady.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmModelReady.expectations {
		if minimock.Equal(e.params, mmModelReady.defaultExpectation.params) {
			mmModelReady.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmModelReady.defaultExpectation.params)
		}
	}

	return mmModelReady
}

// ExpectCtxParam1 sets up expected param ctx for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectCtxParam1(ctx context.Context) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.ctx = &ctx
	mmModelReady.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmModelReady
}

// ExpectModelNameParam2 sets up expected param modelName for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectModelNameParam2(modelName string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.modelName = &modelName
	mmModelReady.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmModelReady
}

// ExpectVersionParam3 sets up expected param version for Ray.ModelReady
func (mmModelReady *mRayMockModelReady) ExpectVersionParam3(version string) *mRayMockModelReady {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{}
	}

	if mmModelReady.defaultExpectation.params != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Expect")
	}

	if mmModelReady.defaultExpectation.paramPtrs == nil {
		mmModelReady.defaultExpectation.paramPtrs = &RayMockModelReadyParamPtrs{}
	}
	mmModelReady.defaultExpectation.paramPtrs.version = &version
	mmModelReady.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmModelReady
}

// Inspect accepts an inspector function that has same arguments as the Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Inspect(f func(ctx context.Context, modelName string, version string)) *mRayMockModelReady {
	if mmModelReady.mock.inspectFuncModelReady != nil {
		mmModelReady.mock.t.Fatalf("Inspect function is already set for RayMock.ModelReady")
	}

	mmModelReady.mock.inspectFuncModelReady = f

	return mmModelReady
}

// Return sets up results that will be returned by Ray.ModelReady
func (mmModelReady *mRayMockModelReady) Return(sp1 *modelpb.State, s1 string, i1 int, err error) *RayMock {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	if mmModelReady.defaultExpectation == nil {
		mmModelReady.defaultExpectation = &RayMockModelReadyExpectation{mock: mmModelReady.mock}
	}
	mmModelReady.defaultExpectation.results = &RayMockModelReadyResults{sp1, s1, i1, err}
	mmModelReady.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmModelReady.mock
}

// Set uses given function f to mock the Ray.ModelReady method
func (mmModelReady *mRayMockModelReady) Set(f func(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error)) *RayMock {
	if mmModelReady.defaultExpectation != nil {
		mmModelReady.mock.t.Fatalf("Default expectation is already set for the Ray.ModelReady method")
	}

	if len(mmModelReady.expectations) > 0 {
		mmModelReady.mock.t.Fatalf("Some expectations are already set for the Ray.ModelReady method")
	}

	mmModelReady.mock.funcModelReady = f
	mmModelReady.mock.funcModelReadyOrigin = minimock.CallerInfo(1)
	return mmModelReady.mock
}

// When sets expectation for the Ray.ModelReady which will trigger the result defined by the following
// Then helper
func (mmModelReady *mRayMockModelReady) When(ctx context.Context, modelName string, version string) *RayMockModelReadyExpectation {
	if mmModelReady.mock.funcModelReady != nil {
		mmModelReady.mock.t.Fatalf("RayMock.ModelReady mock is already set by Set")
	}

	expectation := &RayMockModelReadyExpectation{
		mock:               mmModelReady.mock,
		params:             &RayMockModelReadyParams{ctx, modelName, version},
		expectationOrigins: RayMockModelReadyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmModelReady.expectations = append(mmModelReady.expectations, expectation)
	return expectation
}

// Then sets up Ray.ModelReady return parameters for the expectation previously defined by the When method
func (e *RayMockModelReadyExpectation) Then(sp1 *modelpb.State, s1 string, i1 int, err error) *RayMock {
	e.results = &RayMockModelReadyResults{sp1, s1, i1, err}
	return e.mock
}

// Times sets number of times Ray.ModelReady should be invoked
func (mmModelReady *mRayMockModelReady) Times(n uint64) *mRayMockModelReady {
	if n == 0 {
		mmModelReady.mock.t.Fatalf("Times of RayMock.ModelReady mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmModelReady.expectedInvocations, n)
	mmModelReady.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmModelReady
}

func (mmModelReady *mRayMockModelReady) invocationsDone() bool {
	if len(mmModelReady.expectations) == 0 && mmModelReady.defaultExpectation == nil && mmModelReady.mock.funcModelReady == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmModelReady.mock.afterModelReadyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmModelReady.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ModelReady implements mm_ray.Ray
func (mmModelReady *RayMock) ModelReady(ctx context.Context, modelName string, version string) (sp1 *modelpb.State, s1 string, i1 int, err error) {
	mm_atomic.AddUint64(&mmModelReady.beforeModelReadyCounter, 1)
	defer mm_atomic.AddUint64(&mmModelReady.afterModelReadyCounter, 1)

	mmModelReady.t.Helper()

	if mmModelReady.inspectFuncModelReady != nil {
		mmModelReady.inspectFuncModelReady(ctx, modelName, version)
	}

	mm_params := RayMockModelReadyParams{ctx, modelName, version}

	// Record call args
	mmModelReady.ModelReadyMock.mutex.Lock()
	mmModelReady.ModelReadyMock.callArgs = append(mmModelReady.ModelReadyMock.callArgs, &mm_params)
	mmModelReady.ModelReadyMock.mutex.Unlock()

	for _, e := range mmModelReady.ModelReadyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.s1, e.results.i1, e.results.err
		}
	}

	if mmModelReady.ModelReadyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmModelReady.ModelReadyMock.defaultExpectation.Counter, 1)
		mm_want := mmModelReady.ModelReadyMock.defaultExpectation.params
		mm_want_ptrs := mmModelReady.ModelReadyMock.defaultExpectation.paramPtrs

		mm_got := RayMockModelReadyParams{ctx, modelName, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmModelReady.t.Errorf("RayMock.ModelReady got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmModelReady.ModelReadyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmModelReady.ModelReadyMock.defaultExpectation.results
		if mm_results == nil {
			mmModelReady.t.Fatal("No results are set for the RayMock.ModelReady")
		}
		return (*mm_results).sp1, (*mm_results).s1, (*mm_results).i1, (*mm_results).err
	}
	if mmModelReady.funcModelReady != nil {
		return mmModelReady.funcModelReady(ctx, modelName, version)
	}
	mmModelReady.t.Fatalf("Unexpected call to RayMock.ModelReady. %v %v %v", ctx, modelName, version)
	return
}

// ModelReadyAfterCounter returns a count of finished RayMock.ModelReady invocations
func (mmModelReady *RayMock) ModelReadyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelReady.afterModelReadyCounter)
}

// ModelReadyBeforeCounter returns a count of RayMock.ModelReady invocations
func (mmModelReady *RayMock) ModelReadyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModelReady.beforeModelReadyCounter)
}

// Calls returns a list of arguments used in each call to RayMock.ModelReady.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmModelReady *mRayMockModelReady) Calls() []*RayMockModelReadyParams {
	mmModelReady.mutex.RLock()

	argCopy := make([]*RayMockModelReadyParams, len(mmModelReady.callArgs))
	copy(argCopy, mmModelReady.callArgs)

	mmModelReady.mutex.RUnlock()

	return argCopy
}

// MinimockModelReadyDone returns true if the count of the ModelReady invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockModelReadyDone() bool {
	if m.ModelReadyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ModelReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ModelReadyMock.invocationsDone()
}

// MinimockModelReadyInspect logs each unmet expectation
func (m *RayMock) MinimockModelReadyInspect() {
	for _, e := range m.ModelReadyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterModelReadyCounter := mm_atomic.LoadUint64(&m.afterModelReadyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ModelReadyMock.defaultExpectation != nil && afterModelReadyCounter < 1 {
		if m.ModelReadyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s", m.ModelReadyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.ModelReady at\n%s with params: %#v", m.ModelReadyMock.defaultExpectation.expectationOrigins.origin, *m.ModelReadyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcModelReady != nil && afterModelReadyCounter < 1 {
		m.t.Errorf("Expected call to RayMock.ModelReady at\n%s", m.funcModelReadyOrigin)
	}

	if !m.ModelReadyMock.invocationsDone() && afterModelReadyCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.ModelReady at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ModelReadyMock.expectedInvocations), m.ModelReadyMock.expectedInvocationsOrigin, afterModelReadyCounter)
	}
}

type mRayMockUpdateContainerizedModel struct {
	optional           bool
	mock               *RayMock
	defaultExpectation *RayMockUpdateContainerizedModelExpectation
	expectations       []*RayMockUpdateContainerizedModelExpectation

	callArgs []*RayMockUpdateContainerizedModelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RayMockUpdateContainerizedModelExpectation specifies expectation struct of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelExpectation struct {
	mock               *RayMock
	params             *RayMockUpdateContainerizedModelParams
	paramPtrs          *RayMockUpdateContainerizedModelParamPtrs
	expectationOrigins RayMockUpdateContainerizedModelExpectationOrigins
	results            *RayMockUpdateContainerizedModelResults
	returnOrigin       string
	Counter            uint64
}

// RayMockUpdateContainerizedModelParams contains parameters of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelParams struct {
	ctx       context.Context
	modelName string
	userID    string
	imageName string
	version   string
	hardware  string
	action    mm_ray.Action
	numOfGPU  string
}

// RayMockUpdateContainerizedModelParamPtrs contains pointers to parameters of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelParamPtrs struct {
	ctx       *context.Context
	modelName *string
	userID    *string
	imageName *string
	version   *string
	hardware  *string
	action    *mm_ray.Action
	numOfGPU  *string
}

// RayMockUpdateContainerizedModelResults contains results of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelResults struct {
	err error
}

// RayMockUpdateContainerizedModelOrigins contains origins of expectations of the Ray.UpdateContainerizedModel
type RayMockUpdateContainerizedModelExpectationOrigins struct {
	origin          string
	originCtx       string
	originModelName string
	originUserID    string
	originImageName string
	originVersion   string
	originHardware  string
	originAction    string
	originNumOfGPU  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Optional() *mRayMockUpdateContainerizedModel {
	mmUpdateContainerizedModel.optional = true
	return mmUpdateContainerizedModel
}

// Expect sets up expected params for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Expect(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by ExpectParams functions")
	}

	mmUpdateContainerizedModel.defaultExpectation.params = &RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, numOfGPU}
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateContainerizedModel.expectations {
		if minimock.Equal(e.params, mmUpdateContainerizedModel.defaultExpectation.params) {
			mmUpdateContainerizedModel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateContainerizedModel.defaultExpectation.params)
		}
	}

	return mmUpdateContainerizedModel
}

// ExpectCtxParam1 sets up expected param ctx for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectCtxParam1(ctx context.Context) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectModelNameParam2 sets up expected param modelName for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectModelNameParam2(modelName string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.modelName = &modelName
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originModelName = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectUserIDParam3 sets up expected param userID for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectUserIDParam3(userID string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.userID = &userID
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectImageNameParam4 sets up expected param imageName for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectImageNameParam4(imageName string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.imageName = &imageName
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originImageName = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectVersionParam5 sets up expected param version for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectVersionParam5(version string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.version = &version
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectHardwareParam6 sets up expected param hardware for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectHardwareParam6(hardware string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.hardware = &hardware
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originHardware = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectActionParam7 sets up expected param action for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectActionParam7(action mm_ray.Action) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.action = &action
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originAction = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// ExpectNumOfGPUParam8 sets up expected param numOfGPU for Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) ExpectNumOfGPUParam8(numOfGPU string) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{}
	}

	if mmUpdateContainerizedModel.defaultExpectation.params != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Expect")
	}

	if mmUpdateContainerizedModel.defaultExpectation.paramPtrs == nil {
		mmUpdateContainerizedModel.defaultExpectation.paramPtrs = &RayMockUpdateContainerizedModelParamPtrs{}
	}
	mmUpdateContainerizedModel.defaultExpectation.paramPtrs.numOfGPU = &numOfGPU
	mmUpdateContainerizedModel.defaultExpectation.expectationOrigins.originNumOfGPU = minimock.CallerInfo(1)

	return mmUpdateContainerizedModel
}

// Inspect accepts an inspector function that has same arguments as the Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Inspect(f func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string)) *mRayMockUpdateContainerizedModel {
	if mmUpdateContainerizedModel.mock.inspectFuncUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("Inspect function is already set for RayMock.UpdateContainerizedModel")
	}

	mmUpdateContainerizedModel.mock.inspectFuncUpdateContainerizedModel = f

	return mmUpdateContainerizedModel
}

// Return sets up results that will be returned by Ray.UpdateContainerizedModel
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Return(err error) *RayMock {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	if mmUpdateContainerizedModel.defaultExpectation == nil {
		mmUpdateContainerizedModel.defaultExpectation = &RayMockUpdateContainerizedModelExpectation{mock: mmUpdateContainerizedModel.mock}
	}
	mmUpdateContainerizedModel.defaultExpectation.results = &RayMockUpdateContainerizedModelResults{err}
	mmUpdateContainerizedModel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel.mock
}

// Set uses given function f to mock the Ray.UpdateContainerizedModel method
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Set(f func(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string) (err error)) *RayMock {
	if mmUpdateContainerizedModel.defaultExpectation != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("Default expectation is already set for the Ray.UpdateContainerizedModel method")
	}

	if len(mmUpdateContainerizedModel.expectations) > 0 {
		mmUpdateContainerizedModel.mock.t.Fatalf("Some expectations are already set for the Ray.UpdateContainerizedModel method")
	}

	mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel = f
	mmUpdateContainerizedModel.mock.funcUpdateContainerizedModelOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel.mock
}

// When sets expectation for the Ray.UpdateContainerizedModel which will trigger the result defined by the following
// Then helper
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) When(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string) *RayMockUpdateContainerizedModelExpectation {
	if mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.mock.t.Fatalf("RayMock.UpdateContainerizedModel mock is already set by Set")
	}

	expectation := &RayMockUpdateContainerizedModelExpectation{
		mock:               mmUpdateContainerizedModel.mock,
		params:             &RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, numOfGPU},
		expectationOrigins: RayMockUpdateContainerizedModelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateContainerizedModel.expectations = append(mmUpdateContainerizedModel.expectations, expectation)
	return expectation
}

// Then sets up Ray.UpdateContainerizedModel return parameters for the expectation previously defined by the When method
func (e *RayMockUpdateContainerizedModelExpectation) Then(err error) *RayMock {
	e.results = &RayMockUpdateContainerizedModelResults{err}
	return e.mock
}

// Times sets number of times Ray.UpdateContainerizedModel should be invoked
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Times(n uint64) *mRayMockUpdateContainerizedModel {
	if n == 0 {
		mmUpdateContainerizedModel.mock.t.Fatalf("Times of RayMock.UpdateContainerizedModel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateContainerizedModel.expectedInvocations, n)
	mmUpdateContainerizedModel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateContainerizedModel
}

func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) invocationsDone() bool {
	if len(mmUpdateContainerizedModel.expectations) == 0 && mmUpdateContainerizedModel.defaultExpectation == nil && mmUpdateContainerizedModel.mock.funcUpdateContainerizedModel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateContainerizedModel.mock.afterUpdateContainerizedModelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateContainerizedModel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateContainerizedModel implements mm_ray.Ray
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModel(ctx context.Context, modelName string, userID string, imageName string, version string, hardware string, action mm_ray.Action, numOfGPU string) (err error) {
	mm_atomic.AddUint64(&mmUpdateContainerizedModel.beforeUpdateContainerizedModelCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateContainerizedModel.afterUpdateContainerizedModelCounter, 1)

	mmUpdateContainerizedModel.t.Helper()

	if mmUpdateContainerizedModel.inspectFuncUpdateContainerizedModel != nil {
		mmUpdateContainerizedModel.inspectFuncUpdateContainerizedModel(ctx, modelName, userID, imageName, version, hardware, action, numOfGPU)
	}

	mm_params := RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, numOfGPU}

	// Record call args
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.mutex.Lock()
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.callArgs = append(mmUpdateContainerizedModel.UpdateContainerizedModelMock.callArgs, &mm_params)
	mmUpdateContainerizedModel.UpdateContainerizedModelMock.mutex.Unlock()

	for _, e := range mmUpdateContainerizedModel.UpdateContainerizedModelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.paramPtrs

		mm_got := RayMockUpdateContainerizedModelParams{ctx, modelName, userID, imageName, version, hardware, action, numOfGPU}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.modelName != nil && !minimock.Equal(*mm_want_ptrs.modelName, mm_got.modelName) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter modelName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originModelName, *mm_want_ptrs.modelName, mm_got.modelName, minimock.Diff(*mm_want_ptrs.modelName, mm_got.modelName))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.imageName != nil && !minimock.Equal(*mm_want_ptrs.imageName, mm_got.imageName) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter imageName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originImageName, *mm_want_ptrs.imageName, mm_got.imageName, minimock.Diff(*mm_want_ptrs.imageName, mm_got.imageName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

			if mm_want_ptrs.hardware != nil && !minimock.Equal(*mm_want_ptrs.hardware, mm_got.hardware) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter hardware, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originHardware, *mm_want_ptrs.hardware, mm_got.hardware, minimock.Diff(*mm_want_ptrs.hardware, mm_got.hardware))
			}

			if mm_want_ptrs.action != nil && !minimock.Equal(*mm_want_ptrs.action, mm_got.action) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter action, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originAction, *mm_want_ptrs.action, mm_got.action, minimock.Diff(*mm_want_ptrs.action, mm_got.action))
			}

			if mm_want_ptrs.numOfGPU != nil && !minimock.Equal(*mm_want_ptrs.numOfGPU, mm_got.numOfGPU) {
				mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameter numOfGPU, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.originNumOfGPU, *mm_want_ptrs.numOfGPU, mm_got.numOfGPU, minimock.Diff(*mm_want_ptrs.numOfGPU, mm_got.numOfGPU))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateContainerizedModel.t.Errorf("RayMock.UpdateContainerizedModel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateContainerizedModel.UpdateContainerizedModelMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateContainerizedModel.t.Fatal("No results are set for the RayMock.UpdateContainerizedModel")
		}
		return (*mm_results).err
	}
	if mmUpdateContainerizedModel.funcUpdateContainerizedModel != nil {
		return mmUpdateContainerizedModel.funcUpdateContainerizedModel(ctx, modelName, userID, imageName, version, hardware, action, numOfGPU)
	}
	mmUpdateContainerizedModel.t.Fatalf("Unexpected call to RayMock.UpdateContainerizedModel. %v %v %v %v %v %v %v %v", ctx, modelName, userID, imageName, version, hardware, action, numOfGPU)
	return
}

// UpdateContainerizedModelAfterCounter returns a count of finished RayMock.UpdateContainerizedModel invocations
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContainerizedModel.afterUpdateContainerizedModelCounter)
}

// UpdateContainerizedModelBeforeCounter returns a count of RayMock.UpdateContainerizedModel invocations
func (mmUpdateContainerizedModel *RayMock) UpdateContainerizedModelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateContainerizedModel.beforeUpdateContainerizedModelCounter)
}

// Calls returns a list of arguments used in each call to RayMock.UpdateContainerizedModel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateContainerizedModel *mRayMockUpdateContainerizedModel) Calls() []*RayMockUpdateContainerizedModelParams {
	mmUpdateContainerizedModel.mutex.RLock()

	argCopy := make([]*RayMockUpdateContainerizedModelParams, len(mmUpdateContainerizedModel.callArgs))
	copy(argCopy, mmUpdateContainerizedModel.callArgs)

	mmUpdateContainerizedModel.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateContainerizedModelDone returns true if the count of the UpdateContainerizedModel invocations corresponds
// the number of defined expectations
func (m *RayMock) MinimockUpdateContainerizedModelDone() bool {
	if m.UpdateContainerizedModelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateContainerizedModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateContainerizedModelMock.invocationsDone()
}

// MinimockUpdateContainerizedModelInspect logs each unmet expectation
func (m *RayMock) MinimockUpdateContainerizedModelInspect() {
	for _, e := range m.UpdateContainerizedModelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateContainerizedModelCounter := mm_atomic.LoadUint64(&m.afterUpdateContainerizedModelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateContainerizedModelMock.defaultExpectation != nil && afterUpdateContainerizedModelCounter < 1 {
		if m.UpdateContainerizedModelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s", m.UpdateContainerizedModelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s with params: %#v", m.UpdateContainerizedModelMock.defaultExpectation.expectationOrigins.origin, *m.UpdateContainerizedModelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateContainerizedModel != nil && afterUpdateContainerizedModelCounter < 1 {
		m.t.Errorf("Expected call to RayMock.UpdateContainerizedModel at\n%s", m.funcUpdateContainerizedModelOrigin)
	}

	if !m.UpdateContainerizedModelMock.invocationsDone() && afterUpdateContainerizedModelCounter > 0 {
		m.t.Errorf("Expected %d calls to RayMock.UpdateContainerizedModel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateContainerizedModelMock.expectedInvocations), m.UpdateContainerizedModelMock.expectedInvocationsOrigin, afterUpdateContainerizedModelCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RayMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockInitInspect()

			m.MinimockIsRayReadyInspect()

			m.MinimockModelInferRequestInspect()

			m.MinimockModelReadyInspect()

			m.MinimockUpdateContainerizedModelInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RayMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RayMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockInitDone() &&
		m.MinimockIsRayReadyDone() &&
		m.MinimockModelInferRequestDone() &&
		m.MinimockModelReadyDone() &&
		m.MinimockUpdateContainerizedModelDone()
}
