// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_minio "github.com/instill-ai/model-backend/pkg/minio"
)

// MinioIMock implements minio.MinioI
type MinioIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDeleteFile          func(ctx context.Context, filePath string) (err error)
	inspectFuncDeleteFile   func(ctx context.Context, filePath string)
	afterDeleteFileCounter  uint64
	beforeDeleteFileCounter uint64
	DeleteFileMock          mMinioIMockDeleteFile

	funcGetFile          func(ctx context.Context, filePath string) (ba1 []byte, err error)
	inspectFuncGetFile   func(ctx context.Context, filePath string)
	afterGetFileCounter  uint64
	beforeGetFileCounter uint64
	GetFileMock          mMinioIMockGetFile

	funcGetFilesByPaths          func(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error)
	inspectFuncGetFilesByPaths   func(ctx context.Context, filePaths []string)
	afterGetFilesByPathsCounter  uint64
	beforeGetFilesByPathsCounter uint64
	GetFilesByPathsMock          mMinioIMockGetFilesByPaths

	funcUploadBase64File          func(ctx context.Context, filePath string, base64Content string, fileMimeType string) (err error)
	inspectFuncUploadBase64File   func(ctx context.Context, filePath string, base64Content string, fileMimeType string)
	afterUploadBase64FileCounter  uint64
	beforeUploadBase64FileCounter uint64
	UploadBase64FileMock          mMinioIMockUploadBase64File
}

// NewMinioIMock returns a mock for minio.MinioI
func NewMinioIMock(t minimock.Tester) *MinioIMock {
	m := &MinioIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteFileMock = mMinioIMockDeleteFile{mock: m}
	m.DeleteFileMock.callArgs = []*MinioIMockDeleteFileParams{}

	m.GetFileMock = mMinioIMockGetFile{mock: m}
	m.GetFileMock.callArgs = []*MinioIMockGetFileParams{}

	m.GetFilesByPathsMock = mMinioIMockGetFilesByPaths{mock: m}
	m.GetFilesByPathsMock.callArgs = []*MinioIMockGetFilesByPathsParams{}

	m.UploadBase64FileMock = mMinioIMockUploadBase64File{mock: m}
	m.UploadBase64FileMock.callArgs = []*MinioIMockUploadBase64FileParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMinioIMockDeleteFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockDeleteFileExpectation
	expectations       []*MinioIMockDeleteFileExpectation

	callArgs []*MinioIMockDeleteFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MinioIMockDeleteFileExpectation specifies expectation struct of the MinioI.DeleteFile
type MinioIMockDeleteFileExpectation struct {
	mock      *MinioIMock
	params    *MinioIMockDeleteFileParams
	paramPtrs *MinioIMockDeleteFileParamPtrs
	results   *MinioIMockDeleteFileResults
	Counter   uint64
}

// MinioIMockDeleteFileParams contains parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParams struct {
	ctx      context.Context
	filePath string
}

// MinioIMockDeleteFileParamPtrs contains pointers to parameters of the MinioI.DeleteFile
type MinioIMockDeleteFileParamPtrs struct {
	ctx      *context.Context
	filePath *string
}

// MinioIMockDeleteFileResults contains results of the MinioI.DeleteFile
type MinioIMockDeleteFileResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteFile *mMinioIMockDeleteFile) Optional() *mMinioIMockDeleteFile {
	mmDeleteFile.optional = true
	return mmDeleteFile
}

// Expect sets up expected params for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Expect(ctx context.Context, filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.paramPtrs != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by ExpectParams functions")
	}

	mmDeleteFile.defaultExpectation.params = &MinioIMockDeleteFileParams{ctx, filePath}
	for _, e := range mmDeleteFile.expectations {
		if minimock.Equal(e.params, mmDeleteFile.defaultExpectation.params) {
			mmDeleteFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteFile.defaultExpectation.params)
		}
	}

	return mmDeleteFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteFile
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) ExpectFilePathParam2(filePath string) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{}
	}

	if mmDeleteFile.defaultExpectation.params != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Expect")
	}

	if mmDeleteFile.defaultExpectation.paramPtrs == nil {
		mmDeleteFile.defaultExpectation.paramPtrs = &MinioIMockDeleteFileParamPtrs{}
	}
	mmDeleteFile.defaultExpectation.paramPtrs.filePath = &filePath

	return mmDeleteFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Inspect(f func(ctx context.Context, filePath string)) *mMinioIMockDeleteFile {
	if mmDeleteFile.mock.inspectFuncDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.DeleteFile")
	}

	mmDeleteFile.mock.inspectFuncDeleteFile = f

	return mmDeleteFile
}

// Return sets up results that will be returned by MinioI.DeleteFile
func (mmDeleteFile *mMinioIMockDeleteFile) Return(err error) *MinioIMock {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	if mmDeleteFile.defaultExpectation == nil {
		mmDeleteFile.defaultExpectation = &MinioIMockDeleteFileExpectation{mock: mmDeleteFile.mock}
	}
	mmDeleteFile.defaultExpectation.results = &MinioIMockDeleteFileResults{err}
	return mmDeleteFile.mock
}

// Set uses given function f to mock the MinioI.DeleteFile method
func (mmDeleteFile *mMinioIMockDeleteFile) Set(f func(ctx context.Context, filePath string) (err error)) *MinioIMock {
	if mmDeleteFile.defaultExpectation != nil {
		mmDeleteFile.mock.t.Fatalf("Default expectation is already set for the MinioI.DeleteFile method")
	}

	if len(mmDeleteFile.expectations) > 0 {
		mmDeleteFile.mock.t.Fatalf("Some expectations are already set for the MinioI.DeleteFile method")
	}

	mmDeleteFile.mock.funcDeleteFile = f
	return mmDeleteFile.mock
}

// When sets expectation for the MinioI.DeleteFile which will trigger the result defined by the following
// Then helper
func (mmDeleteFile *mMinioIMockDeleteFile) When(ctx context.Context, filePath string) *MinioIMockDeleteFileExpectation {
	if mmDeleteFile.mock.funcDeleteFile != nil {
		mmDeleteFile.mock.t.Fatalf("MinioIMock.DeleteFile mock is already set by Set")
	}

	expectation := &MinioIMockDeleteFileExpectation{
		mock:   mmDeleteFile.mock,
		params: &MinioIMockDeleteFileParams{ctx, filePath},
	}
	mmDeleteFile.expectations = append(mmDeleteFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.DeleteFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockDeleteFileExpectation) Then(err error) *MinioIMock {
	e.results = &MinioIMockDeleteFileResults{err}
	return e.mock
}

// Times sets number of times MinioI.DeleteFile should be invoked
func (mmDeleteFile *mMinioIMockDeleteFile) Times(n uint64) *mMinioIMockDeleteFile {
	if n == 0 {
		mmDeleteFile.mock.t.Fatalf("Times of MinioIMock.DeleteFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteFile.expectedInvocations, n)
	return mmDeleteFile
}

func (mmDeleteFile *mMinioIMockDeleteFile) invocationsDone() bool {
	if len(mmDeleteFile.expectations) == 0 && mmDeleteFile.defaultExpectation == nil && mmDeleteFile.mock.funcDeleteFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteFile.mock.afterDeleteFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteFile implements minio.MinioI
func (mmDeleteFile *MinioIMock) DeleteFile(ctx context.Context, filePath string) (err error) {
	mm_atomic.AddUint64(&mmDeleteFile.beforeDeleteFileCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteFile.afterDeleteFileCounter, 1)

	if mmDeleteFile.inspectFuncDeleteFile != nil {
		mmDeleteFile.inspectFuncDeleteFile(ctx, filePath)
	}

	mm_params := MinioIMockDeleteFileParams{ctx, filePath}

	// Record call args
	mmDeleteFile.DeleteFileMock.mutex.Lock()
	mmDeleteFile.DeleteFileMock.callArgs = append(mmDeleteFile.DeleteFileMock.callArgs, &mm_params)
	mmDeleteFile.DeleteFileMock.mutex.Unlock()

	for _, e := range mmDeleteFile.DeleteFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteFile.DeleteFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteFile.DeleteFileMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteFile.DeleteFileMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteFile.DeleteFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockDeleteFileParams{ctx, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameter filePath, want: %#v, got: %#v%s\n", *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteFile.t.Errorf("MinioIMock.DeleteFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteFile.DeleteFileMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteFile.t.Fatal("No results are set for the MinioIMock.DeleteFile")
		}
		return (*mm_results).err
	}
	if mmDeleteFile.funcDeleteFile != nil {
		return mmDeleteFile.funcDeleteFile(ctx, filePath)
	}
	mmDeleteFile.t.Fatalf("Unexpected call to MinioIMock.DeleteFile. %v %v", ctx, filePath)
	return
}

// DeleteFileAfterCounter returns a count of finished MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.afterDeleteFileCounter)
}

// DeleteFileBeforeCounter returns a count of MinioIMock.DeleteFile invocations
func (mmDeleteFile *MinioIMock) DeleteFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteFile.beforeDeleteFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.DeleteFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteFile *mMinioIMockDeleteFile) Calls() []*MinioIMockDeleteFileParams {
	mmDeleteFile.mutex.RLock()

	argCopy := make([]*MinioIMockDeleteFileParams, len(mmDeleteFile.callArgs))
	copy(argCopy, mmDeleteFile.callArgs)

	mmDeleteFile.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteFileDone returns true if the count of the DeleteFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockDeleteFileDone() bool {
	if m.DeleteFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteFileMock.invocationsDone()
}

// MinimockDeleteFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockDeleteFileInspect() {
	for _, e := range m.DeleteFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile with params: %#v", *e.params)
		}
	}

	afterDeleteFileCounter := mm_atomic.LoadUint64(&m.afterDeleteFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteFileMock.defaultExpectation != nil && afterDeleteFileCounter < 1 {
		if m.DeleteFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MinioIMock.DeleteFile")
		} else {
			m.t.Errorf("Expected call to MinioIMock.DeleteFile with params: %#v", *m.DeleteFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteFile != nil && afterDeleteFileCounter < 1 {
		m.t.Error("Expected call to MinioIMock.DeleteFile")
	}

	if !m.DeleteFileMock.invocationsDone() && afterDeleteFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.DeleteFile but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteFileMock.expectedInvocations), afterDeleteFileCounter)
	}
}

type mMinioIMockGetFile struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFileExpectation
	expectations       []*MinioIMockGetFileExpectation

	callArgs []*MinioIMockGetFileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MinioIMockGetFileExpectation specifies expectation struct of the MinioI.GetFile
type MinioIMockGetFileExpectation struct {
	mock      *MinioIMock
	params    *MinioIMockGetFileParams
	paramPtrs *MinioIMockGetFileParamPtrs
	results   *MinioIMockGetFileResults
	Counter   uint64
}

// MinioIMockGetFileParams contains parameters of the MinioI.GetFile
type MinioIMockGetFileParams struct {
	ctx      context.Context
	filePath string
}

// MinioIMockGetFileParamPtrs contains pointers to parameters of the MinioI.GetFile
type MinioIMockGetFileParamPtrs struct {
	ctx      *context.Context
	filePath *string
}

// MinioIMockGetFileResults contains results of the MinioI.GetFile
type MinioIMockGetFileResults struct {
	ba1 []byte
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFile *mMinioIMockGetFile) Optional() *mMinioIMockGetFile {
	mmGetFile.optional = true
	return mmGetFile
}

// Expect sets up expected params for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Expect(ctx context.Context, filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.paramPtrs != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by ExpectParams functions")
	}

	mmGetFile.defaultExpectation.params = &MinioIMockGetFileParams{ctx, filePath}
	for _, e := range mmGetFile.expectations {
		if minimock.Equal(e.params, mmGetFile.defaultExpectation.params) {
			mmGetFile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFile.defaultExpectation.params)
		}
	}

	return mmGetFile
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetFile
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) ExpectFilePathParam2(filePath string) *mMinioIMockGetFile {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{}
	}

	if mmGetFile.defaultExpectation.params != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Expect")
	}

	if mmGetFile.defaultExpectation.paramPtrs == nil {
		mmGetFile.defaultExpectation.paramPtrs = &MinioIMockGetFileParamPtrs{}
	}
	mmGetFile.defaultExpectation.paramPtrs.filePath = &filePath

	return mmGetFile
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Inspect(f func(ctx context.Context, filePath string)) *mMinioIMockGetFile {
	if mmGetFile.mock.inspectFuncGetFile != nil {
		mmGetFile.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFile")
	}

	mmGetFile.mock.inspectFuncGetFile = f

	return mmGetFile
}

// Return sets up results that will be returned by MinioI.GetFile
func (mmGetFile *mMinioIMockGetFile) Return(ba1 []byte, err error) *MinioIMock {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	if mmGetFile.defaultExpectation == nil {
		mmGetFile.defaultExpectation = &MinioIMockGetFileExpectation{mock: mmGetFile.mock}
	}
	mmGetFile.defaultExpectation.results = &MinioIMockGetFileResults{ba1, err}
	return mmGetFile.mock
}

// Set uses given function f to mock the MinioI.GetFile method
func (mmGetFile *mMinioIMockGetFile) Set(f func(ctx context.Context, filePath string) (ba1 []byte, err error)) *MinioIMock {
	if mmGetFile.defaultExpectation != nil {
		mmGetFile.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFile method")
	}

	if len(mmGetFile.expectations) > 0 {
		mmGetFile.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFile method")
	}

	mmGetFile.mock.funcGetFile = f
	return mmGetFile.mock
}

// When sets expectation for the MinioI.GetFile which will trigger the result defined by the following
// Then helper
func (mmGetFile *mMinioIMockGetFile) When(ctx context.Context, filePath string) *MinioIMockGetFileExpectation {
	if mmGetFile.mock.funcGetFile != nil {
		mmGetFile.mock.t.Fatalf("MinioIMock.GetFile mock is already set by Set")
	}

	expectation := &MinioIMockGetFileExpectation{
		mock:   mmGetFile.mock,
		params: &MinioIMockGetFileParams{ctx, filePath},
	}
	mmGetFile.expectations = append(mmGetFile.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFile return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFileExpectation) Then(ba1 []byte, err error) *MinioIMock {
	e.results = &MinioIMockGetFileResults{ba1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFile should be invoked
func (mmGetFile *mMinioIMockGetFile) Times(n uint64) *mMinioIMockGetFile {
	if n == 0 {
		mmGetFile.mock.t.Fatalf("Times of MinioIMock.GetFile mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFile.expectedInvocations, n)
	return mmGetFile
}

func (mmGetFile *mMinioIMockGetFile) invocationsDone() bool {
	if len(mmGetFile.expectations) == 0 && mmGetFile.defaultExpectation == nil && mmGetFile.mock.funcGetFile == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFile.mock.afterGetFileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFile.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFile implements minio.MinioI
func (mmGetFile *MinioIMock) GetFile(ctx context.Context, filePath string) (ba1 []byte, err error) {
	mm_atomic.AddUint64(&mmGetFile.beforeGetFileCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFile.afterGetFileCounter, 1)

	if mmGetFile.inspectFuncGetFile != nil {
		mmGetFile.inspectFuncGetFile(ctx, filePath)
	}

	mm_params := MinioIMockGetFileParams{ctx, filePath}

	// Record call args
	mmGetFile.GetFileMock.mutex.Lock()
	mmGetFile.GetFileMock.callArgs = append(mmGetFile.GetFileMock.callArgs, &mm_params)
	mmGetFile.GetFileMock.mutex.Unlock()

	for _, e := range mmGetFile.GetFileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ba1, e.results.err
		}
	}

	if mmGetFile.GetFileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFile.GetFileMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFile.GetFileMock.defaultExpectation.params
		mm_want_ptrs := mmGetFile.GetFileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFileParams{ctx, filePath}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameter filePath, want: %#v, got: %#v%s\n", *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFile.t.Errorf("MinioIMock.GetFile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFile.GetFileMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFile.t.Fatal("No results are set for the MinioIMock.GetFile")
		}
		return (*mm_results).ba1, (*mm_results).err
	}
	if mmGetFile.funcGetFile != nil {
		return mmGetFile.funcGetFile(ctx, filePath)
	}
	mmGetFile.t.Fatalf("Unexpected call to MinioIMock.GetFile. %v %v", ctx, filePath)
	return
}

// GetFileAfterCounter returns a count of finished MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.afterGetFileCounter)
}

// GetFileBeforeCounter returns a count of MinioIMock.GetFile invocations
func (mmGetFile *MinioIMock) GetFileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFile.beforeGetFileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFile *mMinioIMockGetFile) Calls() []*MinioIMockGetFileParams {
	mmGetFile.mutex.RLock()

	argCopy := make([]*MinioIMockGetFileParams, len(mmGetFile.callArgs))
	copy(argCopy, mmGetFile.callArgs)

	mmGetFile.mutex.RUnlock()

	return argCopy
}

// MinimockGetFileDone returns true if the count of the GetFile invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFileDone() bool {
	if m.GetFileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFileMock.invocationsDone()
}

// MinimockGetFileInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFileInspect() {
	for _, e := range m.GetFileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFile with params: %#v", *e.params)
		}
	}

	afterGetFileCounter := mm_atomic.LoadUint64(&m.afterGetFileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFileMock.defaultExpectation != nil && afterGetFileCounter < 1 {
		if m.GetFileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MinioIMock.GetFile")
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFile with params: %#v", *m.GetFileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFile != nil && afterGetFileCounter < 1 {
		m.t.Error("Expected call to MinioIMock.GetFile")
	}

	if !m.GetFileMock.invocationsDone() && afterGetFileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFile but found %d calls",
			mm_atomic.LoadUint64(&m.GetFileMock.expectedInvocations), afterGetFileCounter)
	}
}

type mMinioIMockGetFilesByPaths struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockGetFilesByPathsExpectation
	expectations       []*MinioIMockGetFilesByPathsExpectation

	callArgs []*MinioIMockGetFilesByPathsParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MinioIMockGetFilesByPathsExpectation specifies expectation struct of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsExpectation struct {
	mock      *MinioIMock
	params    *MinioIMockGetFilesByPathsParams
	paramPtrs *MinioIMockGetFilesByPathsParamPtrs
	results   *MinioIMockGetFilesByPathsResults
	Counter   uint64
}

// MinioIMockGetFilesByPathsParams contains parameters of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsParams struct {
	ctx       context.Context
	filePaths []string
}

// MinioIMockGetFilesByPathsParamPtrs contains pointers to parameters of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsParamPtrs struct {
	ctx       *context.Context
	filePaths *[]string
}

// MinioIMockGetFilesByPathsResults contains results of the MinioI.GetFilesByPaths
type MinioIMockGetFilesByPathsResults struct {
	fa1 []mm_minio.FileContent
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Optional() *mMinioIMockGetFilesByPaths {
	mmGetFilesByPaths.optional = true
	return mmGetFilesByPaths
}

// Expect sets up expected params for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Expect(ctx context.Context, filePaths []string) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by ExpectParams functions")
	}

	mmGetFilesByPaths.defaultExpectation.params = &MinioIMockGetFilesByPathsParams{ctx, filePaths}
	for _, e := range mmGetFilesByPaths.expectations {
		if minimock.Equal(e.params, mmGetFilesByPaths.defaultExpectation.params) {
			mmGetFilesByPaths.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFilesByPaths.defaultExpectation.params)
		}
	}

	return mmGetFilesByPaths
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) ExpectCtxParam1(ctx context.Context) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &MinioIMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetFilesByPaths
}

// ExpectFilePathsParam2 sets up expected param filePaths for MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) ExpectFilePathsParam2(filePaths []string) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{}
	}

	if mmGetFilesByPaths.defaultExpectation.params != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Expect")
	}

	if mmGetFilesByPaths.defaultExpectation.paramPtrs == nil {
		mmGetFilesByPaths.defaultExpectation.paramPtrs = &MinioIMockGetFilesByPathsParamPtrs{}
	}
	mmGetFilesByPaths.defaultExpectation.paramPtrs.filePaths = &filePaths

	return mmGetFilesByPaths
}

// Inspect accepts an inspector function that has same arguments as the MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Inspect(f func(ctx context.Context, filePaths []string)) *mMinioIMockGetFilesByPaths {
	if mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Inspect function is already set for MinioIMock.GetFilesByPaths")
	}

	mmGetFilesByPaths.mock.inspectFuncGetFilesByPaths = f

	return mmGetFilesByPaths
}

// Return sets up results that will be returned by MinioI.GetFilesByPaths
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Return(fa1 []mm_minio.FileContent, err error) *MinioIMock {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	if mmGetFilesByPaths.defaultExpectation == nil {
		mmGetFilesByPaths.defaultExpectation = &MinioIMockGetFilesByPathsExpectation{mock: mmGetFilesByPaths.mock}
	}
	mmGetFilesByPaths.defaultExpectation.results = &MinioIMockGetFilesByPathsResults{fa1, err}
	return mmGetFilesByPaths.mock
}

// Set uses given function f to mock the MinioI.GetFilesByPaths method
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Set(f func(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error)) *MinioIMock {
	if mmGetFilesByPaths.defaultExpectation != nil {
		mmGetFilesByPaths.mock.t.Fatalf("Default expectation is already set for the MinioI.GetFilesByPaths method")
	}

	if len(mmGetFilesByPaths.expectations) > 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Some expectations are already set for the MinioI.GetFilesByPaths method")
	}

	mmGetFilesByPaths.mock.funcGetFilesByPaths = f
	return mmGetFilesByPaths.mock
}

// When sets expectation for the MinioI.GetFilesByPaths which will trigger the result defined by the following
// Then helper
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) When(ctx context.Context, filePaths []string) *MinioIMockGetFilesByPathsExpectation {
	if mmGetFilesByPaths.mock.funcGetFilesByPaths != nil {
		mmGetFilesByPaths.mock.t.Fatalf("MinioIMock.GetFilesByPaths mock is already set by Set")
	}

	expectation := &MinioIMockGetFilesByPathsExpectation{
		mock:   mmGetFilesByPaths.mock,
		params: &MinioIMockGetFilesByPathsParams{ctx, filePaths},
	}
	mmGetFilesByPaths.expectations = append(mmGetFilesByPaths.expectations, expectation)
	return expectation
}

// Then sets up MinioI.GetFilesByPaths return parameters for the expectation previously defined by the When method
func (e *MinioIMockGetFilesByPathsExpectation) Then(fa1 []mm_minio.FileContent, err error) *MinioIMock {
	e.results = &MinioIMockGetFilesByPathsResults{fa1, err}
	return e.mock
}

// Times sets number of times MinioI.GetFilesByPaths should be invoked
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Times(n uint64) *mMinioIMockGetFilesByPaths {
	if n == 0 {
		mmGetFilesByPaths.mock.t.Fatalf("Times of MinioIMock.GetFilesByPaths mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetFilesByPaths.expectedInvocations, n)
	return mmGetFilesByPaths
}

func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) invocationsDone() bool {
	if len(mmGetFilesByPaths.expectations) == 0 && mmGetFilesByPaths.defaultExpectation == nil && mmGetFilesByPaths.mock.funcGetFilesByPaths == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.mock.afterGetFilesByPathsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetFilesByPaths.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetFilesByPaths implements minio.MinioI
func (mmGetFilesByPaths *MinioIMock) GetFilesByPaths(ctx context.Context, filePaths []string) (fa1 []mm_minio.FileContent, err error) {
	mm_atomic.AddUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter, 1)

	if mmGetFilesByPaths.inspectFuncGetFilesByPaths != nil {
		mmGetFilesByPaths.inspectFuncGetFilesByPaths(ctx, filePaths)
	}

	mm_params := MinioIMockGetFilesByPathsParams{ctx, filePaths}

	// Record call args
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Lock()
	mmGetFilesByPaths.GetFilesByPathsMock.callArgs = append(mmGetFilesByPaths.GetFilesByPathsMock.callArgs, &mm_params)
	mmGetFilesByPaths.GetFilesByPathsMock.mutex.Unlock()

	for _, e := range mmGetFilesByPaths.GetFilesByPathsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.params
		mm_want_ptrs := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockGetFilesByPathsParams{ctx, filePaths}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePaths != nil && !minimock.Equal(*mm_want_ptrs.filePaths, mm_got.filePaths) {
				mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameter filePaths, want: %#v, got: %#v%s\n", *mm_want_ptrs.filePaths, mm_got.filePaths, minimock.Diff(*mm_want_ptrs.filePaths, mm_got.filePaths))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFilesByPaths.t.Errorf("MinioIMock.GetFilesByPaths got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFilesByPaths.GetFilesByPathsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFilesByPaths.t.Fatal("No results are set for the MinioIMock.GetFilesByPaths")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFilesByPaths.funcGetFilesByPaths != nil {
		return mmGetFilesByPaths.funcGetFilesByPaths(ctx, filePaths)
	}
	mmGetFilesByPaths.t.Fatalf("Unexpected call to MinioIMock.GetFilesByPaths. %v %v", ctx, filePaths)
	return
}

// GetFilesByPathsAfterCounter returns a count of finished MinioIMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *MinioIMock) GetFilesByPathsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.afterGetFilesByPathsCounter)
}

// GetFilesByPathsBeforeCounter returns a count of MinioIMock.GetFilesByPaths invocations
func (mmGetFilesByPaths *MinioIMock) GetFilesByPathsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFilesByPaths.beforeGetFilesByPathsCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.GetFilesByPaths.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFilesByPaths *mMinioIMockGetFilesByPaths) Calls() []*MinioIMockGetFilesByPathsParams {
	mmGetFilesByPaths.mutex.RLock()

	argCopy := make([]*MinioIMockGetFilesByPathsParams, len(mmGetFilesByPaths.callArgs))
	copy(argCopy, mmGetFilesByPaths.callArgs)

	mmGetFilesByPaths.mutex.RUnlock()

	return argCopy
}

// MinimockGetFilesByPathsDone returns true if the count of the GetFilesByPaths invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockGetFilesByPathsDone() bool {
	if m.GetFilesByPathsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetFilesByPathsMock.invocationsDone()
}

// MinimockGetFilesByPathsInspect logs each unmet expectation
func (m *MinioIMock) MinimockGetFilesByPathsInspect() {
	for _, e := range m.GetFilesByPathsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths with params: %#v", *e.params)
		}
	}

	afterGetFilesByPathsCounter := mm_atomic.LoadUint64(&m.afterGetFilesByPathsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetFilesByPathsMock.defaultExpectation != nil && afterGetFilesByPathsCounter < 1 {
		if m.GetFilesByPathsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MinioIMock.GetFilesByPaths")
		} else {
			m.t.Errorf("Expected call to MinioIMock.GetFilesByPaths with params: %#v", *m.GetFilesByPathsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFilesByPaths != nil && afterGetFilesByPathsCounter < 1 {
		m.t.Error("Expected call to MinioIMock.GetFilesByPaths")
	}

	if !m.GetFilesByPathsMock.invocationsDone() && afterGetFilesByPathsCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.GetFilesByPaths but found %d calls",
			mm_atomic.LoadUint64(&m.GetFilesByPathsMock.expectedInvocations), afterGetFilesByPathsCounter)
	}
}

type mMinioIMockUploadBase64File struct {
	optional           bool
	mock               *MinioIMock
	defaultExpectation *MinioIMockUploadBase64FileExpectation
	expectations       []*MinioIMockUploadBase64FileExpectation

	callArgs []*MinioIMockUploadBase64FileParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MinioIMockUploadBase64FileExpectation specifies expectation struct of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileExpectation struct {
	mock      *MinioIMock
	params    *MinioIMockUploadBase64FileParams
	paramPtrs *MinioIMockUploadBase64FileParamPtrs
	results   *MinioIMockUploadBase64FileResults
	Counter   uint64
}

// MinioIMockUploadBase64FileParams contains parameters of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileParams struct {
	ctx           context.Context
	filePath      string
	base64Content string
	fileMimeType  string
}

// MinioIMockUploadBase64FileParamPtrs contains pointers to parameters of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileParamPtrs struct {
	ctx           *context.Context
	filePath      *string
	base64Content *string
	fileMimeType  *string
}

// MinioIMockUploadBase64FileResults contains results of the MinioI.UploadBase64File
type MinioIMockUploadBase64FileResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUploadBase64File *mMinioIMockUploadBase64File) Optional() *mMinioIMockUploadBase64File {
	mmUploadBase64File.optional = true
	return mmUploadBase64File
}

// Expect sets up expected params for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Expect(ctx context.Context, filePath string, base64Content string, fileMimeType string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by ExpectParams functions")
	}

	mmUploadBase64File.defaultExpectation.params = &MinioIMockUploadBase64FileParams{ctx, filePath, base64Content, fileMimeType}
	for _, e := range mmUploadBase64File.expectations {
		if minimock.Equal(e.params, mmUploadBase64File.defaultExpectation.params) {
			mmUploadBase64File.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUploadBase64File.defaultExpectation.params)
		}
	}

	return mmUploadBase64File
}

// ExpectCtxParam1 sets up expected param ctx for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectCtxParam1(ctx context.Context) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUploadBase64File
}

// ExpectFilePathParam2 sets up expected param filePath for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectFilePathParam2(filePath string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.filePath = &filePath

	return mmUploadBase64File
}

// ExpectBase64ContentParam3 sets up expected param base64Content for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectBase64ContentParam3(base64Content string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.base64Content = &base64Content

	return mmUploadBase64File
}

// ExpectFileMimeTypeParam4 sets up expected param fileMimeType for MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) ExpectFileMimeTypeParam4(fileMimeType string) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{}
	}

	if mmUploadBase64File.defaultExpectation.params != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Expect")
	}

	if mmUploadBase64File.defaultExpectation.paramPtrs == nil {
		mmUploadBase64File.defaultExpectation.paramPtrs = &MinioIMockUploadBase64FileParamPtrs{}
	}
	mmUploadBase64File.defaultExpectation.paramPtrs.fileMimeType = &fileMimeType

	return mmUploadBase64File
}

// Inspect accepts an inspector function that has same arguments as the MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Inspect(f func(ctx context.Context, filePath string, base64Content string, fileMimeType string)) *mMinioIMockUploadBase64File {
	if mmUploadBase64File.mock.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("Inspect function is already set for MinioIMock.UploadBase64File")
	}

	mmUploadBase64File.mock.inspectFuncUploadBase64File = f

	return mmUploadBase64File
}

// Return sets up results that will be returned by MinioI.UploadBase64File
func (mmUploadBase64File *mMinioIMockUploadBase64File) Return(err error) *MinioIMock {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	if mmUploadBase64File.defaultExpectation == nil {
		mmUploadBase64File.defaultExpectation = &MinioIMockUploadBase64FileExpectation{mock: mmUploadBase64File.mock}
	}
	mmUploadBase64File.defaultExpectation.results = &MinioIMockUploadBase64FileResults{err}
	return mmUploadBase64File.mock
}

// Set uses given function f to mock the MinioI.UploadBase64File method
func (mmUploadBase64File *mMinioIMockUploadBase64File) Set(f func(ctx context.Context, filePath string, base64Content string, fileMimeType string) (err error)) *MinioIMock {
	if mmUploadBase64File.defaultExpectation != nil {
		mmUploadBase64File.mock.t.Fatalf("Default expectation is already set for the MinioI.UploadBase64File method")
	}

	if len(mmUploadBase64File.expectations) > 0 {
		mmUploadBase64File.mock.t.Fatalf("Some expectations are already set for the MinioI.UploadBase64File method")
	}

	mmUploadBase64File.mock.funcUploadBase64File = f
	return mmUploadBase64File.mock
}

// When sets expectation for the MinioI.UploadBase64File which will trigger the result defined by the following
// Then helper
func (mmUploadBase64File *mMinioIMockUploadBase64File) When(ctx context.Context, filePath string, base64Content string, fileMimeType string) *MinioIMockUploadBase64FileExpectation {
	if mmUploadBase64File.mock.funcUploadBase64File != nil {
		mmUploadBase64File.mock.t.Fatalf("MinioIMock.UploadBase64File mock is already set by Set")
	}

	expectation := &MinioIMockUploadBase64FileExpectation{
		mock:   mmUploadBase64File.mock,
		params: &MinioIMockUploadBase64FileParams{ctx, filePath, base64Content, fileMimeType},
	}
	mmUploadBase64File.expectations = append(mmUploadBase64File.expectations, expectation)
	return expectation
}

// Then sets up MinioI.UploadBase64File return parameters for the expectation previously defined by the When method
func (e *MinioIMockUploadBase64FileExpectation) Then(err error) *MinioIMock {
	e.results = &MinioIMockUploadBase64FileResults{err}
	return e.mock
}

// Times sets number of times MinioI.UploadBase64File should be invoked
func (mmUploadBase64File *mMinioIMockUploadBase64File) Times(n uint64) *mMinioIMockUploadBase64File {
	if n == 0 {
		mmUploadBase64File.mock.t.Fatalf("Times of MinioIMock.UploadBase64File mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUploadBase64File.expectedInvocations, n)
	return mmUploadBase64File
}

func (mmUploadBase64File *mMinioIMockUploadBase64File) invocationsDone() bool {
	if len(mmUploadBase64File.expectations) == 0 && mmUploadBase64File.defaultExpectation == nil && mmUploadBase64File.mock.funcUploadBase64File == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.mock.afterUploadBase64FileCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUploadBase64File.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UploadBase64File implements minio.MinioI
func (mmUploadBase64File *MinioIMock) UploadBase64File(ctx context.Context, filePath string, base64Content string, fileMimeType string) (err error) {
	mm_atomic.AddUint64(&mmUploadBase64File.beforeUploadBase64FileCounter, 1)
	defer mm_atomic.AddUint64(&mmUploadBase64File.afterUploadBase64FileCounter, 1)

	if mmUploadBase64File.inspectFuncUploadBase64File != nil {
		mmUploadBase64File.inspectFuncUploadBase64File(ctx, filePath, base64Content, fileMimeType)
	}

	mm_params := MinioIMockUploadBase64FileParams{ctx, filePath, base64Content, fileMimeType}

	// Record call args
	mmUploadBase64File.UploadBase64FileMock.mutex.Lock()
	mmUploadBase64File.UploadBase64FileMock.callArgs = append(mmUploadBase64File.UploadBase64FileMock.callArgs, &mm_params)
	mmUploadBase64File.UploadBase64FileMock.mutex.Unlock()

	for _, e := range mmUploadBase64File.UploadBase64FileMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUploadBase64File.UploadBase64FileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUploadBase64File.UploadBase64FileMock.defaultExpectation.Counter, 1)
		mm_want := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.params
		mm_want_ptrs := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.paramPtrs

		mm_got := MinioIMockUploadBase64FileParams{ctx, filePath, base64Content, fileMimeType}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filePath != nil && !minimock.Equal(*mm_want_ptrs.filePath, mm_got.filePath) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter filePath, want: %#v, got: %#v%s\n", *mm_want_ptrs.filePath, mm_got.filePath, minimock.Diff(*mm_want_ptrs.filePath, mm_got.filePath))
			}

			if mm_want_ptrs.base64Content != nil && !minimock.Equal(*mm_want_ptrs.base64Content, mm_got.base64Content) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter base64Content, want: %#v, got: %#v%s\n", *mm_want_ptrs.base64Content, mm_got.base64Content, minimock.Diff(*mm_want_ptrs.base64Content, mm_got.base64Content))
			}

			if mm_want_ptrs.fileMimeType != nil && !minimock.Equal(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType) {
				mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameter fileMimeType, want: %#v, got: %#v%s\n", *mm_want_ptrs.fileMimeType, mm_got.fileMimeType, minimock.Diff(*mm_want_ptrs.fileMimeType, mm_got.fileMimeType))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUploadBase64File.t.Errorf("MinioIMock.UploadBase64File got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUploadBase64File.UploadBase64FileMock.defaultExpectation.results
		if mm_results == nil {
			mmUploadBase64File.t.Fatal("No results are set for the MinioIMock.UploadBase64File")
		}
		return (*mm_results).err
	}
	if mmUploadBase64File.funcUploadBase64File != nil {
		return mmUploadBase64File.funcUploadBase64File(ctx, filePath, base64Content, fileMimeType)
	}
	mmUploadBase64File.t.Fatalf("Unexpected call to MinioIMock.UploadBase64File. %v %v %v %v", ctx, filePath, base64Content, fileMimeType)
	return
}

// UploadBase64FileAfterCounter returns a count of finished MinioIMock.UploadBase64File invocations
func (mmUploadBase64File *MinioIMock) UploadBase64FileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.afterUploadBase64FileCounter)
}

// UploadBase64FileBeforeCounter returns a count of MinioIMock.UploadBase64File invocations
func (mmUploadBase64File *MinioIMock) UploadBase64FileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUploadBase64File.beforeUploadBase64FileCounter)
}

// Calls returns a list of arguments used in each call to MinioIMock.UploadBase64File.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUploadBase64File *mMinioIMockUploadBase64File) Calls() []*MinioIMockUploadBase64FileParams {
	mmUploadBase64File.mutex.RLock()

	argCopy := make([]*MinioIMockUploadBase64FileParams, len(mmUploadBase64File.callArgs))
	copy(argCopy, mmUploadBase64File.callArgs)

	mmUploadBase64File.mutex.RUnlock()

	return argCopy
}

// MinimockUploadBase64FileDone returns true if the count of the UploadBase64File invocations corresponds
// the number of defined expectations
func (m *MinioIMock) MinimockUploadBase64FileDone() bool {
	if m.UploadBase64FileMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UploadBase64FileMock.invocationsDone()
}

// MinimockUploadBase64FileInspect logs each unmet expectation
func (m *MinioIMock) MinimockUploadBase64FileInspect() {
	for _, e := range m.UploadBase64FileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MinioIMock.UploadBase64File with params: %#v", *e.params)
		}
	}

	afterUploadBase64FileCounter := mm_atomic.LoadUint64(&m.afterUploadBase64FileCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UploadBase64FileMock.defaultExpectation != nil && afterUploadBase64FileCounter < 1 {
		if m.UploadBase64FileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MinioIMock.UploadBase64File")
		} else {
			m.t.Errorf("Expected call to MinioIMock.UploadBase64File with params: %#v", *m.UploadBase64FileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUploadBase64File != nil && afterUploadBase64FileCounter < 1 {
		m.t.Error("Expected call to MinioIMock.UploadBase64File")
	}

	if !m.UploadBase64FileMock.invocationsDone() && afterUploadBase64FileCounter > 0 {
		m.t.Errorf("Expected %d calls to MinioIMock.UploadBase64File but found %d calls",
			mm_atomic.LoadUint64(&m.UploadBase64FileMock.expectedInvocations), afterUploadBase64FileCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MinioIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteFileInspect()

			m.MinimockGetFileInspect()

			m.MinimockGetFilesByPathsInspect()

			m.MinimockUploadBase64FileInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MinioIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MinioIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteFileDone() &&
		m.MinimockGetFileDone() &&
		m.MinimockGetFilesByPathsDone() &&
		m.MinimockUploadBase64FileDone()
}
