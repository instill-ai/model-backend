package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/gofrs/uuid"
	"github.com/iancoleman/strcase"
	"go.einride.tech/aip/filtering"
	"go.einride.tech/aip/ordering"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	fieldmask_utils "github.com/mennanov/fieldmask-utils"

	"github.com/instill-ai/model-backend/pkg/datamodel"
	"github.com/instill-ai/model-backend/pkg/resource"
	"github.com/instill-ai/model-backend/pkg/utils"
	"github.com/instill-ai/x/checkfield"

	modelpb "github.com/instill-ai/protogen-go/model/v1alpha"
	errorsx "github.com/instill-ai/x/errors"
)

func makeJSONResponse(w http.ResponseWriter, st int, title string, detail string) {
	w.Header().Add("Content-Type", "application/json+problem")
	w.WriteHeader(st)
	obj, _ := json.Marshal(datamodel.Error{
		Status: int32(st),
		Title:  title,
		Detail: detail,
	})
	_, _ = w.Write(obj)
}

// ListModels lists the models for a given user.
func (h *PublicHandler) ListModels(ctx context.Context, req *modelpb.ListModelsRequest) (*modelpb.ListModelsResponse, error) {

	if err := authenticateUser(ctx, true); err != nil {
		return &modelpb.ListModelsResponse{}, err
	}

	declarations, err := filtering.NewDeclarations([]filtering.DeclarationOption{
		filtering.DeclareStandardFunctions(),
		filtering.DeclareFunction("time.now", filtering.NewFunctionOverload("time.now", filtering.TypeTimestamp)),
		filtering.DeclareIdent("q", filtering.TypeString),
		filtering.DeclareIdent("uid", filtering.TypeString),
		filtering.DeclareIdent("id", filtering.TypeString),
		// Currently, we only have a "featured" tag, so we'll only support single tag filter for now.
		filtering.DeclareIdent("tag", filtering.TypeString),
		filtering.DeclareIdent("numberOfRuns", filtering.TypeInt),
		filtering.DeclareIdent("description", filtering.TypeString),
		filtering.DeclareIdent("owner", filtering.TypeString),
		filtering.DeclareIdent("createTime", filtering.TypeTimestamp),
		filtering.DeclareIdent("updateTime", filtering.TypeTimestamp),
	}...)
	if err != nil {
		return &modelpb.ListModelsResponse{}, err
	}

	filter, err := filtering.ParseFilter(req, declarations)
	if err != nil {
		return &modelpb.ListModelsResponse{}, err
	}
	visibility := req.GetVisibility()

	orderBy, err := ordering.ParseOrderBy(req)
	if err != nil {
		return &modelpb.ListModelsResponse{}, err
	}

	pbModels, totalSize, nextPageToken, err := h.service.ListModels(
		ctx, req.GetPageSize(), req.GetPageToken(), parseView(req.GetView()), &visibility, filter, req.GetShowDeleted(), orderBy)
	if err != nil {
		return &modelpb.ListModelsResponse{}, err
	}

	resp := modelpb.ListModelsResponse{
		Models:        pbModels,
		NextPageToken: nextPageToken,
		TotalSize:     totalSize,
	}

	return &resp, nil
}

// CreateNamespaceModel creates a model for a given namespace.
func (h *PublicHandler) CreateNamespaceModel(ctx context.Context, req *modelpb.CreateNamespaceModelRequest) (*modelpb.CreateNamespaceModelResponse, error) {

	modelToCreate := req.GetModel()

	// Set all OUTPUT_ONLY fields to zero value on the requested payload model resource
	if err := checkfield.CheckCreateOutputOnlyFields(modelToCreate, outputOnlyFields); err != nil {
		return nil, errorsx.ErrCheckOutputOnlyFields
	}

	// Note: Per AIP standard, id is OUTPUT_ONLY and auto-generated by the server.
	// The server generates the id (e.g., "mod-8f3A2k9E7c1") in the BeforeCreate hook.

	// validate model spec
	if err := datamodel.ValidateJSONSchema(datamodel.ModelJSONSchema, modelToCreate, false); err != nil {
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("Model spec is invalid %v", err.Error()))
	}

	namespaceID, err := parseNamespaceFromParent(req.GetParent())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	if _, err := h.service.GetNamespaceModelByID(ctx, ns, modelToCreate.GetId(), modelpb.View_VIEW_FULL); err == nil {
		return nil, status.Error(codes.AlreadyExists, "Model already existed")
	}

	if modelToCreate.GetConfiguration() == nil {
		return nil, status.Error(codes.InvalidArgument, "Missing Configuration")
	}

	modelDefinitionID, err := resource.GetDefinitionID(modelToCreate.GetModelDefinition())
	if err != nil {
		return nil, err
	}

	modelDefinition, err := h.service.GetRepository().GetModelDefinition(modelDefinitionID)
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	modelSpec := utils.ModelSpec{}
	if err := json.Unmarshal(modelDefinition.ModelSpec, &modelSpec); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	// validate model configuration
	if err := datamodel.ValidateJSONSchema(modelSpec.ModelConfigurationSchema, modelToCreate.GetConfiguration(), true); err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "Model configuration is invalid %v", err.Error())
	}

	switch modelDefinitionID {
	case "container":
		if _, err := h.service.CreateNamespaceModel(ctx, ns, modelDefinition, modelToCreate); err != nil {
			// Manually set the custom header to have a StatusBadRequest http response for REST endpoint
			if err := grpc.SetHeader(ctx, metadata.Pairs("x-http-code", strconv.Itoa(http.StatusBadRequest))); err != nil {
				return nil, err
			}
			return &modelpb.CreateNamespaceModelResponse{}, err
		}

		modelToCreate, _ = h.service.GetNamespaceModelByID(ctx, ns, modelToCreate.GetId(), modelpb.View_VIEW_FULL)

		// Manually set the custom header to have a StatusCreated http response for REST endpoint
		if err := grpc.SetHeader(ctx, metadata.Pairs("x-http-code", strconv.Itoa(http.StatusCreated))); err != nil {
			return nil, err
		}

		return &modelpb.CreateNamespaceModelResponse{
			Model: modelToCreate,
		}, nil
	default:
		return nil, status.Errorf(codes.InvalidArgument, "model definition %v is not supported", modelDefinitionID)
	}
}

// ListNamespaceModels lists the models for a given namespace.
func (h *PublicHandler) ListNamespaceModels(ctx context.Context, req *modelpb.ListNamespaceModelsRequest) (*modelpb.ListNamespaceModelsResponse, error) {

	namespaceID, err := parseNamespaceFromParent(req.GetParent())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	declarations, err := filtering.NewDeclarations([]filtering.DeclarationOption{
		filtering.DeclareStandardFunctions(),
		filtering.DeclareFunction("time.now", filtering.NewFunctionOverload("time.now", filtering.TypeTimestamp)),
		filtering.DeclareIdent("q", filtering.TypeString),
		filtering.DeclareIdent("uid", filtering.TypeString),
		filtering.DeclareIdent("id", filtering.TypeString),
		// Currently, we only have a "featured" tag, so we'll only support single tag filter for now.
		filtering.DeclareIdent("tag", filtering.TypeString),
		filtering.DeclareIdent("numberOfRuns", filtering.TypeInt),
		filtering.DeclareIdent("description", filtering.TypeString),
		filtering.DeclareIdent("owner", filtering.TypeString),
		filtering.DeclareIdent("createTime", filtering.TypeTimestamp),
		filtering.DeclareIdent("updateTime", filtering.TypeTimestamp),
	}...)
	if err != nil {
		return nil, err
	}

	filter, err := filtering.ParseFilter(req, declarations)
	if err != nil {
		return nil, err
	}
	visibility := req.GetVisibility()

	orderBy, err := ordering.ParseOrderBy(req)
	if err != nil {
		return nil, err
	}

	pbModels, totalSize, nextPageToken, err := h.service.ListNamespaceModels(ctx, ns, req.GetPageSize(), req.GetPageToken(), parseView(req.GetView()), &visibility, filter, req.GetShowDeleted(), orderBy)
	if err != nil {
		return nil, err
	}

	return &modelpb.ListNamespaceModelsResponse{
		Models:        pbModels,
		TotalSize:     totalSize,
		NextPageToken: nextPageToken,
	}, nil
}

// ListNamespaceModelVersions lists the model versions for a given namespace.
func (h *PublicHandler) ListNamespaceModelVersions(ctx context.Context, req *modelpb.ListNamespaceModelVersionsRequest) (resp *modelpb.ListNamespaceModelVersionsResponse, err error) {

	namespaceID, modelID, err := parseModelFromParent(req.GetParent())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	pbModelVersions, totalSize, pageSize, page, err := h.service.ListNamespaceModelVersions(ctx, ns, req.GetPage(), req.GetPageSize(), modelID)
	if err != nil {
		return nil, err
	}

	return &modelpb.ListNamespaceModelVersionsResponse{
		Versions:  pbModelVersions,
		TotalSize: totalSize,
		PageSize:  pageSize,
		Page:      page,
	}, nil
}

// DeleteNamespaceModelVersion deletes a model version for a given namespace.
func (h *PublicHandler) DeleteNamespaceModelVersion(ctx context.Context, req *modelpb.DeleteNamespaceModelVersionRequest) (*modelpb.DeleteNamespaceModelVersionResponse, error) {

	namespaceID, modelID, version, err := parseModelVersionFromName(req.GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}

	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	if err := h.service.DeleteModelVersionByID(ctx, ns, modelID, version); err != nil {
		return nil, err
	}

	return &modelpb.DeleteNamespaceModelVersionResponse{}, nil
}

// GetNamespaceModel gets a model by name for a given namespace.
func (h *PublicHandler) GetNamespaceModel(ctx context.Context, req *modelpb.GetNamespaceModelRequest) (*modelpb.GetNamespaceModelResponse, error) {

	namespaceID, modelID, err := parseModelFromName(req.GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	pbModel, err := h.service.GetNamespaceModelByID(ctx, ns, modelID, parseView(req.GetView()))
	if err != nil {
		return nil, err
	}

	return &modelpb.GetNamespaceModelResponse{Model: pbModel}, err
}

// UpdateNamespaceModel updates a model for a given namespace.
func (h *PublicHandler) UpdateNamespaceModel(ctx context.Context, req *modelpb.UpdateNamespaceModelRequest) (*modelpb.UpdateNamespaceModelResponse, error) {

	namespaceID, modelID, err := parseModelFromName(req.GetModel().GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	pbModel := req.GetModel()
	pbUpdateMask := req.GetUpdateMask()

	// metadata field is type google.protobuf.Struct, which needs to be updated as a whole
	for idx, path := range pbUpdateMask.Paths {
		if strings.Contains(path, "metadata") {
			pbUpdateMask.Paths[idx] = "metadata"
		}
	}
	if !pbUpdateMask.IsValid(pbModel) {
		return nil, status.Error(codes.InvalidArgument, "The update_mask is invalid")
	}

	getResp, err := h.GetNamespaceModel(ctx, &modelpb.GetNamespaceModelRequest{Name: req.GetModel().GetName(), View: modelpb.View_VIEW_FULL.Enum()})
	if err != nil {
		return nil, err
	}
	pbModelToUpdate := getResp.GetModel()

	pbUpdateMask, err = checkfield.CheckUpdateOutputOnlyFields(pbUpdateMask, outputOnlyFields)
	if err != nil {
		return nil, errorsx.ErrCheckOutputOnlyFields
	}

	mask, err := fieldmask_utils.MaskFromProtoFieldMask(pbUpdateMask, strcase.ToCamel)
	if err != nil {
		return nil, errorsx.ErrFieldMask
	}

	if mask.IsEmpty() {
		return nil, errorsx.ErrUpdateMask
	}

	// Return error if IMMUTABLE fields are intentionally changed
	if err := checkfield.CheckUpdateImmutableFields(pbModel, pbModelToUpdate, immutableFields); err != nil {
		return nil, errorsx.ErrCheckUpdateImmutableFields
	}

	// Only the fields mentioned in the field mask will be copied to `pbModelToUpdate`, other fields are left intact
	err = fieldmask_utils.StructToStruct(mask, pbModel, pbModelToUpdate)
	if err != nil {
		return nil, errorsx.ErrFieldMask
	}

	pbUpdatedModel, err := h.service.UpdateNamespaceModelByID(ctx, ns, modelID, pbModelToUpdate)
	if err != nil {
		return nil, err
	}

	return &modelpb.UpdateNamespaceModelResponse{Model: pbUpdatedModel}, err
}

// DeleteNamespaceModel deletes a model for a given namespace.
func (h *PublicHandler) DeleteNamespaceModel(ctx context.Context, req *modelpb.DeleteNamespaceModelRequest) (*modelpb.DeleteNamespaceModelResponse, error) {

	namespaceID, modelID, err := parseModelFromName(req.GetName())
	if err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	// Manually set the custom header to have a StatusNoContent http response for REST endpoint
	if err := grpc.SetHeader(ctx, metadata.Pairs("x-http-code", strconv.Itoa(http.StatusNoContent))); err != nil {
		return nil, err
	}

	if err := h.service.DeleteNamespaceModelByID(ctx, ns, modelID); err != nil {
		return nil, err
	}

	return &modelpb.DeleteNamespaceModelResponse{}, nil
}

// RenameNamespaceModel renames a model for a given namespace.
func (h *PublicHandler) RenameNamespaceModel(ctx context.Context, req *modelpb.RenameNamespaceModelRequest) (*modelpb.RenameNamespaceModelResponse, error) {

	// Parse namespace_id and model_id from name resource name
	// Format: namespaces/{namespace}/models/{model}
	name := req.GetName()
	parts := strings.Split(name, "/")
	if len(parts) < 4 {
		return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("invalid resource name: %s", name))
	}
	namespaceID := parts[1]
	modelID := parts[3]

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return nil, err
	}
	if err := authenticateUser(ctx, false); err != nil {
		return nil, err
	}

	pbModel, err := h.service.RenameNamespaceModelByID(ctx, ns, modelID, req.GetNewModelId())
	if err != nil {
		return nil, err
	}

	return &modelpb.RenameNamespaceModelResponse{Model: pbModel}, nil
}

// WatchNamespaceModelRequestInterface is an interface for watching a namespace model.
type WatchNamespaceModelRequestInterface interface {
	GetName() string
}

// WatchNamespaceModelRequestWithVersionInterface is an interface for watching a namespace model with a specific version.
type WatchNamespaceModelRequestWithVersionInterface interface {
	WatchNamespaceModelRequestInterface
	GetVersion() string
}

// WatchNamespaceModel watches a model for a given namespace.
func (h *PublicHandler) WatchNamespaceModel(ctx context.Context, req *modelpb.WatchNamespaceModelRequest) (resp *modelpb.WatchNamespaceModelResponse, err error) {
	resp = &modelpb.WatchNamespaceModelResponse{}

	resp.State, resp.Message, err = h.watchNamespaceModel(ctx, req)

	return resp, err
}

// WatchNamespaceLatestModel watches the latest model for a given namespace.
func (h *PublicHandler) WatchNamespaceLatestModel(ctx context.Context, req *modelpb.WatchNamespaceLatestModelRequest) (resp *modelpb.WatchNamespaceLatestModelResponse, err error) {
	resp = &modelpb.WatchNamespaceLatestModelResponse{}

	resp.State, resp.Message, err = h.watchNamespaceModel(ctx, req)

	return resp, err
}

func (h *PublicHandler) watchNamespaceModel(ctx context.Context, req WatchNamespaceModelRequestInterface) (modelpb.State, string, error) {

	// Parse namespace_id and model_id from name resource name
	// Format: namespaces/{namespace}/models/{model}
	name := req.GetName()
	parts := strings.Split(name, "/")
	if len(parts) < 4 {
		return modelpb.State_STATE_ERROR, "", status.Error(codes.InvalidArgument, fmt.Sprintf("invalid resource name: %s", name))
	}
	namespaceID := parts[1]
	modelID := parts[3]

	ns, err := h.service.GetRscNamespace(ctx, namespaceID)
	if err != nil {
		return modelpb.State_STATE_ERROR, "", err
	}

	if err := authenticateUser(ctx, true); err != nil {
		return modelpb.State_STATE_ERROR, "", err
	}

	pbModel, err := h.service.GetNamespaceModelByID(ctx, ns, modelID, modelpb.View_VIEW_BASIC)
	if err != nil {
		return modelpb.State_STATE_ERROR, "", err
	}

	// Get version if provided; otherwise use the latest version
	var versionID string
	if reqWithVersion, ok := req.(WatchNamespaceModelRequestWithVersionInterface); ok {
		versionID = reqWithVersion.GetVersion()
	}
	if versionID == "" {
		version, err := h.service.GetRepository().GetLatestModelVersionByModelUID(ctx, uuid.FromStringOrNil(pbModel.Id))
		if err != nil {
			return modelpb.State_STATE_ERROR, "", err
		}
		versionID = version.Version
	}

	state, message, err := h.service.WatchModel(ctx, ns, modelID, versionID)
	if err != nil {
		return modelpb.State_STATE_ERROR, "", err
	}

	return *state, message, nil
}

// GetModelDefinition gets a model definition by ID.
func (h *PublicHandler) GetModelDefinition(ctx context.Context, req *modelpb.GetModelDefinitionRequest) (*modelpb.GetModelDefinitionResponse, error) {

	pbModelDefinition, err := h.service.GetModelDefinition(ctx, req.ModelDefinitionId)
	if err != nil {
		return &modelpb.GetModelDefinitionResponse{}, err
	}

	return &modelpb.GetModelDefinitionResponse{ModelDefinition: pbModelDefinition}, nil
}

// ListModelDefinitions lists the model definitions.
func (h *PublicHandler) ListModelDefinitions(ctx context.Context, req *modelpb.ListModelDefinitionsRequest) (*modelpb.ListModelDefinitionsResponse, error) {

	pbModelDefinitions, totalSize, nextPageToken, err := h.service.ListModelDefinitions(ctx, parseView(req.GetView()), req.GetPageSize(), req.GetPageToken())
	if err != nil {
		return &modelpb.ListModelDefinitionsResponse{}, err
	}

	resp := modelpb.ListModelDefinitionsResponse{
		ModelDefinitions: pbModelDefinitions,
		NextPageToken:    nextPageToken,
		TotalSize:        totalSize,
	}

	return &resp, nil
}

// ListAvailableRegions lists the available regions.
func (h *PublicHandler) ListAvailableRegions(ctx context.Context, req *modelpb.ListAvailableRegionsRequest) (*modelpb.ListAvailableRegionsResponse, error) {

	regionsStruct := datamodel.RegionHardwareJSON.Properties.Region.OneOf
	hardwaresStruct := datamodel.RegionHardwareJSON.AllOf

	var regions []*modelpb.Region

	for _, r := range regionsStruct {
		subRegion := &modelpb.Region{
			RegionName: r.Const,
			Hardware:   []*modelpb.Hardware{},
		}
		for _, h := range hardwaresStruct {
			if h.If.Properties.Region.Const == r.Const {
				for _, hardware := range h.Then.Properties.Hardware.OneOf {
					subRegion.Hardware = append(subRegion.Hardware, &modelpb.Hardware{
						Title: hardware.Title,
						Value: hardware.Const,
					})
				}
				for _, hardware := range h.Then.Properties.Hardware.AnyOf {
					if hardware.Const != "" {
						subRegion.Hardware = append(subRegion.Hardware, &modelpb.Hardware{
							Title: hardware.Title,
							Value: hardware.Const,
						})
					} else if hardware.Title != "" {
						subRegion.Hardware = append(subRegion.Hardware, &modelpb.Hardware{
							Title: hardware.Title,
							Value: "",
						})
					}
				}
			}
		}
		regions = append(regions, subRegion)
	}

	return &modelpb.ListAvailableRegionsResponse{
		Regions: regions,
	}, nil
}

// ListModelRuns lists the model runs.
func (h *PublicHandler) ListModelRuns(ctx context.Context, req *modelpb.ListModelRunsRequest) (*modelpb.ListModelRunsResponse, error) {

	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	declarations, err := filtering.NewDeclarations([]filtering.DeclarationOption{
		filtering.DeclareStandardFunctions(),
		filtering.DeclareIdent("uid", filtering.TypeString),
		filtering.DeclareIdent("modelVersion", filtering.TypeString),
		filtering.DeclareIdent("status", filtering.TypeString),
		filtering.DeclareIdent("source", filtering.TypeString),
		filtering.DeclareIdent("createTime", filtering.TypeTimestamp),
		filtering.DeclareIdent("updateTime", filtering.TypeTimestamp),
	}...)
	if err != nil {
		return nil, err
	}

	filter, err := filtering.ParseFilter(req, declarations)
	if err != nil {
		return nil, err
	}

	resp, err := h.service.ListModelRuns(ctx, req, filter)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

// ListModelRunsByRequester lists the model runs by requester.
func (h *PublicHandler) ListModelRunsByRequester(ctx context.Context, req *modelpb.ListModelRunsByRequesterRequest) (*modelpb.ListModelRunsByRequesterResponse, error) {

	if err := authenticateUser(ctx, true); err != nil {
		return nil, err
	}

	resp, err := h.service.ListModelRunsByRequester(ctx, req)
	if err != nil {
		return nil, err
	}

	return resp, nil
}
